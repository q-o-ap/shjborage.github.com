<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">

  <title><![CDATA[Tag: iOS7 | Eric's 后花园]]></title>
  <link href="http://shjborage.github.io/tags/ios7/atom.xml" rel="self"/>
  <link href="http://shjborage.github.io/"/>
  <updated>2018-12-02T21:02:49+08:00</updated>
  <id>http://shjborage.github.io/</id>
  <author>
    <name><![CDATA[Eric Shi]]></name>
    <email><![CDATA[shjborage@163.com]]></email>
  </author>
  <generator uri="http://octopress.org/">Octopress</generator>

  
  <entry>
    <title type="html"><![CDATA[iOS7 UI兼容 导航栏按钮边框 UINavigationItem left and right padding]]></title>
    <link href="http://shjborage.github.io/blog/2014/01/20/ios7-uijian-rong-dao-hang-lan-an-niu-bian-kuang-uinavigationitem-left-and-right-padding/"/>
    <updated>2014-01-20T23:16:00+08:00</updated>
    <id>http://shjborage.github.io/blog/2014/01/20/ios7-uijian-rong-dao-hang-lan-an-niu-bian-kuang-uinavigationitem-left-and-right-padding</id>
    <content type="html"><![CDATA[<p>iOS7之前的UI为：</p>

<iframe src="https://www.flickr.com/photos/shjborage/12052252814/player/120d793b08" height="44" width="324"  frameborder="0" allowfullscreen webkitallowfullscreen mozallowfullscreen oallowfullscreen msallowfullscreen></iframe>


<p>而在iOS7中，由于设计方面的原因，使得UI变为:</p>

<iframe src="https://www.flickr.com/photos/shjborage/12052149003/player/bb36320bc9" height="44" width="322"  frameborder="0" allowfullscreen webkitallowfullscreen mozallowfullscreen oallowfullscreen msallowfullscreen></iframe>




<!-- more -->


<p>修改的方法重写UINavigationItem的setLeftBarButtonItem和setRightBarButtonItem方法，使之与之前版本兼容；</p>

<p>代码如下：</p>

<p><em>UINavigationItem+margin.h</em></p>

<p>```
//
//  UINavigationItem+margin.h
//
//  Created by shjborage on 1/20/14.
//  Copyright &copy; 2014 Saick. All rights reserved.
//</p>

<h1>import &lt;UIKit/UIKit.h></h1>

<p>@interface UINavigationItem (margin)</p>

<p>@end</p>

<p>```</p>

<p><em>UINavigationItem+margin.m</em></p>

<p>```
//
//  UINavigationItem+margin.m
//
//  Created by shjborage on 1/20/14.
//  Copyright &copy; 2014 Saick. All rights reserved.
//</p>

<h1>import &ldquo;UINavigationItem+margin.h&rdquo;</h1>

<p>@implementation UINavigationItem (margin)</p>

<h1>if <strong>IPHONE_OS_VERSION_MAX_ALLOWED > </strong>IPHONE_6_1</h1>

<ul>
<li><p>(void)setLeftBarButtonItem:(UIBarButtonItem <em>)_leftBarButtonItem
{
if ([[[UIDevice currentDevice] systemVersion] floatValue] >= 7.0) {
  UIBarButtonItem </em>negativeSeperator = [[UIBarButtonItem alloc] initWithBarButtonSystemItem:UIBarButtonSystemItemFixedSpace target:nil action:nil];
  negativeSeperator.width = -10.0f;</p>

<p>  if (<em>leftBarButtonItem) {
    [self setLeftBarButtonItems:@[negativeSeperator, </em>leftBarButtonItem]];
  } else {
    [self setLeftBarButtonItems:@[negativeSeperator]];
  }
} else {
  [self setLeftBarButtonItem:_leftBarButtonItem animated:NO];
}
}</p></li>
</ul>


<p>//&ndash; (void)setLeftBarButtonItems:(NSArray <em>)leftBarButtonItems
//{
//  if ([[[UIDevice currentDevice] systemVersion] floatValue] >= 7.0) {
//    UIBarButtonItem </em>negativeSeperator = [[UIBarButtonItem alloc] initWithBarButtonSystemItem:UIBarButtonSystemItemFixedSpace target:nil action:nil];
//    negativeSeperator.width = -10.0f;
//  <br/>
//    if ([_leftBarButtonItems count] > 0) {
//      NSMutableArray *items = [NSMutableArray arrayWithArray:leftBarButtonItems];
//      [items insertObject:negativeSeperator atIndex:0];
//      [self setLeftBarButtonItems:items animated:NO];
//    } else {
//      [self setLeftBarButtonItems:leftBarButtonItems animated:NO];
//    }
//  } else {
//    [self setLeftBarButtonItems:leftBarButtonItems animated:NO];
//  }
//}</p>

<ul>
<li><p>(void)setRightBarButtonItem:(UIBarButtonItem <em>)_rightBarButtonItem
{
if ([[[UIDevice currentDevice] systemVersion] floatValue] >= 7.0) {
  UIBarButtonItem </em>negativeSeperator = [[UIBarButtonItem alloc] initWithBarButtonSystemItem:UIBarButtonSystemItemFixedSpace target:nil action:nil];
  negativeSeperator.width = -10.0f;</p>

<p>  if (<em>rightBarButtonItem) {
    [self setRightBarButtonItems:@[negativeSeperator, </em>rightBarButtonItem]];
  } else {
    [self setRightBarButtonItems:@[negativeSeperator]];
  }
} else {
  [self setRightBarButtonItem:_rightBarButtonItem animated:NO];
}
}</p></li>
</ul>


<p>//&ndash; (void)setRightBarButtonItems:(NSArray <em>)rightBarButtonItems
//{
//  if ([[[UIDevice currentDevice] systemVersion] floatValue] >= 7.0) {
//    UIBarButtonItem </em>negativeSeperator = [[UIBarButtonItem alloc] initWithBarButtonSystemItem:UIBarButtonSystemItemFixedSpace target:nil action:nil];
//    negativeSeperator.width = -10.0f;
//  <br/>
//    if ([_leftBarButtonItems count] > 0) {
//      NSMutableArray *items = [NSMutableArray arrayWithArray:rightBarButtonItems];
//      [items insertObject:negativeSeperator atIndex:0];
//      [self setRightBarButtonItems:items animated:NO];
//    } else {
//      [self setRightBarButtonItems:rightBarButtonItems animated:NO];
//    }
//  } else {
//    [self setRightBarButtonItems:rightBarButtonItems animated:NO];
//  }
//}</p>

<h1>endif</h1>

<p>@end</p>

<p>```</p>

<p>项目源码不做任何修改，问题解决；</p>

<p>添加Button：</p>

<p><code>
UIBarButtonItem *leftBarItem = [[UIBarButtonItem alloc] initWithCustomView:btnBack];
self.navigationItem.leftBarButtonItem = leftBarItem;
[leftBarItem release];
</code></p>

<p>如果原来项目中有使用<code>self.navigationItem.leftBarButtonItems</code>或<code>self.navigationItem.rightBarButtonItems</code>可参考注释部分内容。如果都是多个的，那么直接换把注释解开，把单个的给注释掉。<strong>搞懂原理才是重要的</strong></p>

<p><a href="http://www.cnblogs.com/maxfong/p/3375167.html">原文地址</a></p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[定制iOS 7中的导航栏和状态栏]]></title>
    <link href="http://shjborage.github.io/blog/2013/12/08/ding-zhi-ios-7zhong-de-dao-hang-lan-he-zhuang-tai-lan/"/>
    <updated>2013-12-08T02:30:00+08:00</updated>
    <id>http://shjborage.github.io/blog/2013/12/08/ding-zhi-ios-7zhong-de-dao-hang-lan-he-zhuang-tai-lan</id>
    <content type="html"><![CDATA[<p>近期，跟大多数开发者一样，我也正忙于对程序进行升级以适配iOS 7。最新的iOS 7外观上有大量的改动。从开发者的角度来看，导航栏和状态栏就发生了明显的变化。状态栏现在是半透明的了，这也就意味着导航栏会显示在状态栏后面。有些情况下，导航栏的背景图片可以延伸显示到状态栏后面。</p>

<p>之前我曾经写过一篇关于如何定制导航栏的文章。
不过现在是时候对其进行更新了。下面就是本文将要介绍的内容：</p>

<ul>
<li>iOS 7中默认的导航栏</li>
<li>设置导航栏的背景颜色</li>
<li>在导航栏中使用背景图片</li>
<li>定制返回按钮的颜色</li>
<li>修改导航栏标题的字体</li>
<li>修改导航栏标题为图片</li>
<li>添加多个按钮</li>
<li>修改状态栏的风格</li>
<li>隐藏状态栏</li>
<li>总结</li>
</ul>


<!-- more -->


<p><a href="http://www.flickr.com/photos/shjborage/11263366886/" title="2013-12-08-1 by EricShj, on Flickr"><img src="http://farm6.staticflickr.com/5537/11263366886_50b10421ff.jpg" width="500" height="473" alt="2013-12-08-1"></a></p>

<p>本文提供的代码需要用Xcode 5来执行。如果你还在使用老版本的Xcode，那么在运行示例之前请将Xcode升级到Xcode 5。</p>

<h3>iOS 7中默认的导航栏</h3>

<p>在开始定制之前，我们先来看看iOS 7中默认导航栏的外观。通过Xcode用Single View Controller模板创建一个工程。然后将view controller嵌入到一个navigation controller中。如果你不想从头开始，那么也可以在这里下载到这个<a href="https://dl.dropboxusercontent.com/u/2857188/NavigationBarDemo.zip">示例工程</a>。Xcode 5包含有iOS 6和iOS 7模拟器，我们可以在这两个不同的模拟器版本中运行示例程序，进行对比，如下图所示：</p>

<p><a href="http://www.flickr.com/photos/shjborage/11263379574/" title="2013-12-08-2 by EricShj, on Flickr"><img src="http://farm6.staticflickr.com/5478/11263379574_391625e690.jpg" width="500" height="144" alt="2013-12-08-2"></a></p>

<p>如上图所示，在iOS 7中的导航栏默认情况下跟状态栏是交织在一起的，并且它的颜色也被修改为亮灰色。</p>

<h3>设置导航栏的背景颜色</h3>

<p>在iOS 7中，不再使用tintColor属性来设置导航栏的颜色，而是使用barTintColor属性来修改背景色。我们可以在AppDelegate.m文件中的方法didFinishLaunchingWithOptions:里面添加如下代码来修改颜色：</p>

<p><code>
[[UINavigationBar appearance] setBarTintColor:[UIColor yellowColor]];
</code></p>

<p>效果如下图所示：</p>

<p><a href="http://www.flickr.com/photos/shjborage/11263420823/" title="2013-12-08-3 by EricShj, on Flickr"><img src="http://farm4.staticflickr.com/3775/11263420823_9eb0bab4f9.jpg" width="500" height="242" alt="2013-12-08-3"></a></p>

<p>一般情况，我们都会使用自己的颜色，下面这个宏用来设置RGB颜色非常方便：</p>

<p>```</p>

<h1>define UIColorFromRGB(rgbValue) [UIColor colorWithRed:((float)((rgbValue &amp; 0xFF0000) >> 16))/255.0 green:((float)((rgbValue &amp; 0xFF00) >> 8))/255.0 blue:((float)(rgbValue &amp; 0xFF))/255.0 alpha:1.0]</h1>

<p>```</p>

<p>将上面这个宏放到AppDelegate.m文件中，然后通过这个宏来创建一个UIColor对象(根据指定的RGB)。如下示例：</p>

<p><code>
[[UINavigationBar appearance] setBarTintColor:UIColorFromRGB(0x067AB5)];
</code></p>

<p>默认情况下，导航栏的translucent属性为YES。另外，系统还会对所有的导航栏做模糊处理，这样可以让iOS 7中导航栏的颜色更加饱和。如下图，是translucent值为NO和YES的对比效果：</p>

<p><a href="http://www.flickr.com/photos/shjborage/11263366646/" title="2013-12-08-4 by EricShj, on Flickr"><img src="http://farm4.staticflickr.com/3749/11263366646_9f55687f4e.jpg" width="500" height="109" alt="2013-12-08-4"></a></p>

<p>要想禁用translucent属性，可以在Storyboard中选中导航栏，然后在Attribute Inspectors中，取消translucent的勾选。</p>

<h3>在导航栏中使用背景图片</h3>

<p>如果希望在导航栏中使用一个图片当做背景，那么你需要提供一个稍微高一点的图片(这样可以延伸到导航栏背后)。导航栏的高度从44 points(88 pixels)变为了64 points(128 pixels)。我们依然可以使用setBackgroundImage:方法为导航栏设置自定义图片。如下代码所示：</p>

<p><code>
[[UINavigationBar appearance] setBackgroundImage:[UIImage imageNamed:@"nav_bg.png"] forBarMetrics:UIBarMetricsDefault];
</code></p>

<p>示例工程中提供了两个背景图片：nav_bg.png 和 nav_bg_ios7.png。运行一下试试看吧，如下效果：</p>

<p><a href="http://www.flickr.com/photos/shjborage/11263366636/" title="2013-12-08-5 by EricShj, on Flickr"><img src="http://farm4.staticflickr.com/3822/11263366636_79a3394899.jpg" width="500" height="155" alt="2013-12-08-5"></a></p>

<h3>定制返回按钮的颜色</h3>

<p>在iOS 7中，所有的按钮都是无边框的。其中返回按钮会有一个V型箭头，以及上一个屏幕中的标题(如果上一屏幕的标题是空，那么就显示”返回”)。要想给返回按钮着色，可以使用tintColor属性。如下代码所示：</p>

<p><code>
[[UINavigationBar appearance] setTintColor:[UIColor whiteColor]];
</code></p>

<p>除了返回按钮，tintColor属性会影响到所有按钮标题和图片。</p>

<p><a href="http://www.flickr.com/photos/shjborage/11263366586/" title="2013-12-08-6 by EricShj, on Flickr"><img src="http://farm3.staticflickr.com/2824/11263366586_d932478c3e.jpg" width="500" height="102" alt="2013-12-08-6"></a></p>

<p>如果想要用自己的图片替换V型，可以设置图片的backIndicatorImage和backIndicatorTransitionMaskImage。如下代码所示：</p>

<p><code>
[[UINavigationBar appearance] setBackIndicatorImage:[UIImage imageNamed:@"back_btn.png"]];
[[UINavigationBar appearance] setBackIndicatorTransitionMaskImage:[UIImage imageNamed:@"back_btn.png"]];
</code></p>

<p>图片的颜色是由tintColor属性控制的。</p>

<p><a href="http://www.flickr.com/photos/shjborage/11263366576/" title="2013-12-08-7 by EricShj, on Flickr"><img src="http://farm4.staticflickr.com/3679/11263366576_708e24cb31.jpg" width="500" height="102" alt="2013-12-08-7"></a></p>

<h3>修改导航栏标题的字体</h3>

<p>跟iOS 6一样，我们可以使用导航栏的titleTextAttributes属性来定制导航栏的文字风格。在text attributes字典中使用如下一些key，可以指定字体、文字颜色、文字阴影色以及文字阴影偏移量：
UITextAttributeFont – 字体key
UITextAttributeTextColor – 文字颜色key
UITextAttributeTextShadowColor – 文字阴影色key
UITextAttributeTextShadowOffset – 文字阴影偏移量key</p>

<p>如下代码所示，对导航栏的标题风格做了修改：</p>

<p>```
NSShadow *shadow = [[NSShadow alloc] init];</p>

<pre><code>shadow.shadowColor = [UIColor colorWithRed:0.0 green:0.0 blue:0.0 alpha:0.8]; 
shadow.shadowOffset = CGSizeMake(0, 1); 
[[UINavigationBar appearance] setTitleTextAttributes: [NSDictionary dictionaryWithObjectsAndKeys: 
                                                       [UIColor colorWithRed:245.0/255.0 green:245.0/255.0 blue:245.0/255.0 alpha:1.0], NSForegroundColorAttributeName, 
                                                       shadow, NSShadowAttributeName, 
                                                       [UIFont fontWithName:@"HelveticaNeue-CondensedBlack" size:21.0], NSFontAttributeName, nil]]; 
</code></pre>

<p>```</p>

<p>运行效果如下图所示：</p>

<p><a href="http://www.flickr.com/photos/shjborage/11263330475/" title="2013-12-08-8 by EricShj, on Flickr"><img src="http://farm6.staticflickr.com/5491/11263330475_6a2fa2d7a0.jpg" width="500" height="199" alt="2013-12-08-8"></a></p>

<h3>修改导航栏标题为图片</h3>

<p>如果要想将导航栏标题修改为一个图片或者logo，那么只需要使用下面这行代码即可：</p>

<p><code>
self.navigationItem.titleView = [[UIImageView alloc] initWithImage:[UIImage imageNamed:@"appcoda-logo.png"]];
</code></p>

<p>上面的代码简单的修改了titleView属性，将一个图片赋值给它。 注意：这不是iOS 7中的新功能，之前的iOS版本就可以已经有了。具体效果如下图所示：</p>

<p><a href="http://www.flickr.com/photos/shjborage/11263420343/" title="2013-12-08-9 by EricShj, on Flickr"><img src="http://farm6.staticflickr.com/5536/11263420343_e744b52709.jpg" width="500" height="194" alt="2013-12-08-9"></a></p>

<h3>添加多个按钮</h3>

<p>同样，这个技巧也不是iOS 7的，开发者经常会在导航栏中添加多个按钮，所以我决定在这里进行介绍。我们可以在导航栏左边或者右边添加多个按钮。例如，我们希望在导航栏右边添加一个照相机和分享按钮，那只需要使用下面的代码即可：</p>

<p><code>
UIBarButtonItem *shareItem = [[UIBarButtonItem alloc] initWithBarButtonSystemItem:UIBarButtonSystemItemAction target:self action:nil];
UIBarButtonItem *cameraItem = [[UIBarButtonItem alloc] initWithBarButtonSystemItem:UIBarButtonSystemItemCamera target:self action:nil];  
NSArray *actionButtonItems = @[shareItem, cameraItem];
self.navigationItem.rightBarButtonItems = actionButtonItems;
</code></p>

<p>如下效果：</p>

<p><a href="http://www.flickr.com/photos/shjborage/11263379424/" title="2013-12-08-10 by EricShj, on Flickr"><img src="http://farm3.staticflickr.com/2810/11263379424_d57a82b2a7.jpg" width="500" height="171" alt="2013-12-08-10"></a></p>

<h3>修改状态栏的风格</h3>

<p>在老版本的iOS中，状态栏永远都是白色风格。而在iOS 7中，我们可以修改每个view controller中状态栏的外观。通过UIStatusBarStyle常量可以指定状态栏的内容是暗色或亮色。默认情况下，状态栏的显示是暗色。也就是说，状态栏上的时间、电池指示器和Wi-Fi信号显示为暗色。如果导航栏中使用暗色为背景，那么看起来的效果如下图所示：</p>

<p><a href="http://www.flickr.com/photos/shjborage/11263366266/" title="2013-12-08-11 by EricShj, on Flickr"><img src="http://farm8.staticflickr.com/7447/11263366266_e0161eb7bf.jpg" width="500" height="174" alt="2013-12-08-11"></a></p>

<p>如上图这种情况下，我们可能希望将导航栏的风格修改为亮色。这里有两个方法可以实现。在iOS 7中，我们可以在每个view controller中overridingpreferredStatusBarStyle:方法，如下所示：</p>

<p>```
&ndash;(UIStatusBarStyle)preferredStatusBarStyle
{</p>

<pre><code>return UIStatusBarStyleLightContent; 
</code></pre>

<p>}
```</p>

<p>上面代码的效果如下图所示：</p>

<p><a href="http://www.flickr.com/photos/shjborage/11263330045/" title="2013-12-08-12 by EricShj, on Flickr"><img src="http://farm4.staticflickr.com/3745/11263330045_77ed88449d.jpg" width="500" height="173" alt="2013-12-08-12"></a></p>

<p>在iOS 7中，通过上面的方法来修改状态栏风格非常的棒。另外，我们也可以使用UIApplication的statusBarStyle方法来设置状态栏，不过，首先需要停止使用View controller-based status bar appearance。在project target的Info tab中，插入一个新的key，名字为View controller-based status bar appearance，并将其值设置为NO。</p>

<p>然后就可以使用下面的代码来设置状态栏风格了：</p>

<p><code>
[[UIApplication sharedApplication] setStatusBarStyle:UIStatusBarStyleLightContent];
</code></p>

<h3>隐藏状态栏</h3>

<p>有时候我们需要隐藏状态栏，那么此时我们在view controller中override方法prefersStatusBarHidden:即可，如下代码所示：</p>

<p>```
&ndash; (BOOL)prefersStatusBarHidden
{</p>

<pre><code>return YES; 
</code></pre>

<p>}
```</p>

<h3>总结</h3>

<p>iOS 7给开发者提供了一些新的自由度来定制导航栏和状态栏的外观。希望上面的这些技巧能对你有用。这里可以下载到<a href="https://dl.dropboxusercontent.com/u/2857188/NavigationBarDemo.zip">示例工程源码</a>。只需要取消相关代码注释即可进行测试。</p>

<p>来源：破船的博客
原文：<a href="http://www.appcoda.com/customize-navigation-status-bar-ios-7/">Customizing Navigation Bar and Status Bar in iOS 7</a></p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[iOS 7教程：浅析Text Kit]]></title>
    <link href="http://shjborage.github.io/blog/2013/11/23/ios-7jiao-cheng-qian-xi-text-kit/"/>
    <updated>2013-11-23T22:06:00+08:00</updated>
    <id>http://shjborage.github.io/blog/2013/11/23/ios-7jiao-cheng-qian-xi-text-kit</id>
    <content type="html"><![CDATA[<p>转自<a href="http://beyondvincent.com/blog/2013/11/12/121-brief-analysis-text-kit/">破船</a>的博客</p>

<p>Text Kit是iOS 7中引入的一个新功能，非常值得开发者使用，下面先看看本文的目录结构：</p>

<ul>
<li>什么是Text Kit</li>
<li>Text Kit架构</li>
<li>Text Kit特点</li>
<li>Text Kit功能概述</li>
<li>Text Kit中重要的一些对象</li>
<li>Text Kit示例</li>
<li>小结</li>
<li>推荐Text Kit学习资源</li>
</ul>


<!-- more -->


<h3>什么是Text Kit</h3>

<p>在iOS7中，苹果引入了Text Kit&mdash;Text Kit是一个快速而又现代化的文字排版和渲染引擎。Text Kit在UIKit framework中的定义了一些类和相关协议，它最主要的作用就是为程序提供文字排版和渲染的功能。在程序中，通过Text Kit可以对文字进行存储(store)、布局(lay out)，以及用最精细的排版方式(例如文字间距、换行和对齐等)来显示文本内容。 苹果引入Text Kit的目的并非要取代已有的Core Text，Core Text的主要作用也是用于文字的排版和渲染中，它是一种先进而又处于底层技术，如果我们需要将文本内容直接渲染到图形上下文(Graphics context)时，从性能和易用性来考虑，最佳方案就是使用Core Text。而如果我们直接利用苹果提供的一些控件(例如UITextView、UILabel和UITextField等)对文字进行排版，无疑就是借助于UIkit framework中Text Kit提供的API。</p>

<h3>Text Kit架构</h3>

<p>下面，我们通过图1(此图来自WWDC2013 Session 210)来了解一下Text Kit的架构。图1是基于iOS 7绘制的，从图中，我们可以看到Text Kit是基于Core Text构建的，它通过Core Text与Core Graphics进行交互。而UI控件(UILabel、UITextField和UITextView)则构建于Text Kit之上，可见这些文本控件可以利用Text Kit提供的API来对文字进行排版和渲染处理。 从图中我们也可以看到SDK提供的UIWebView是基于WebKit的，它不能使用Text Kit提供的功能。</p>

<p><a href="http://www.flickr.com/photos/105999540@N03/11028898935/" title="2013-11-24-1 by EricShj, on Flickr"><img src="http://farm8.staticflickr.com/7439/11028898935_e836a8c934.jpg" width="500" height="211" alt="2013-11-24-1"></a></p>

<p>图1 Text Kit在iOS 7 SDK中的位置</p>

<p>我们再来看看图1中的相关组件在iOS6里面是如何对应的，如图2所示，可以看出在iOS 6中是没有Text Kit，并且UILabel、UIText和UITextView是基于String Drawing和WebKit构建的。其中String Drawing是与Core Graphics直接通讯。</p>

<p><a href="http://www.flickr.com/photos/105999540@N03/11029000326/" title="2013-11-24-2 by EricShj, on Flickr"><img src="http://farm8.staticflickr.com/7430/11029000326_f1345af879.jpg" width="500" height="242" alt="2013-11-24-2"></a></p>

<p>图2 在iOS 6中并没有Text Kit</p>

<h3>Text Kit特点</h3>

<p>从上面的介绍中，我们可以了解到Text Kit在UIKit中的作用非常重要。Text Kit在实际开发中具有如下特点：</p>

<ul>
<li>1.在UI控件中Text Kit完全掌控着文字的排版和渲染</li>
<li>2.UITextView、UITextField和UILabel是构建于Text Kit之上的</li>
<li>3.能够与动画、UICollectionView和UITableView做到无缝集成</li>
<li>4.Text Kit具有这样一些能力：Subclassing、Delegation和Notifcation。</li>
</ul>


<h3>Text Kit功能概述</h3>

<p>下面我们看看通过Text Kit，都能实现那些功能(这里列出了是一些常用和重要功能)：</p>

<ul>
<li>1.对文字进行分页或多列排版</li>
<li>2.支持文字的换行、折叠和着色等处理</li>
<li>3.可以调整字与字之间的距离、行间距、文字大小、指定特定的字体</li>
<li>4.支持富文本编辑，可以自定义文字截断</li>
<li>5.支持凸版印刷效果(letterpress)</li>
<li>6.支持数据类型的检测(例如链接、附件等)</li>
</ul>


<p>如图3，是利用Text Kit对文字做的分页排版</p>

<p><a href="http://www.flickr.com/photos/105999540@N03/11028898985/" title="2013-11-24-3 by EricShj, on Flickr"><img src="http://farm8.staticflickr.com/7420/11028898985_e42af249cf.jpg" width="500" height="303" alt="2013-11-24-3"></a></p>

<p>图3 利用Text Kit做的分页排版效果</p>

<p>再看图4，是利用Text Kit做的换行处理，其中对某个路径范围做了排除。</p>

<p><a href="http://www.flickr.com/photos/105999540@N03/11029105983/" title="2013-11-24-4 by EricShj, on Flickr"><img src="http://farm6.staticflickr.com/5530/11029105983_dba9ffd9fb.jpg" width="500" height="359" alt="2013-11-24-4"></a></p>

<p>图4 利用Text Kit做的换行处理效果</p>

<p>再来看看利用Text Kit做的凸版印刷效果，如图5所示</p>

<p><a href="http://www.flickr.com/photos/105999540@N03/11029054444/" title="2013-11-24-5 by EricShj, on Flickr"><img src="http://farm3.staticflickr.com/2885/11029054444_fd67572185.jpg" width="500" height="365" alt="2013-11-24-5"></a></p>

<p>图5 利用Text Kit做的凸版印刷效果</p>

<h3>Text Kit中重要的一些对象</h3>

<p>下面我们来看看Text Kit中重要的几个对象。</p>

<p><a href="http://www.flickr.com/photos/105999540@N03/11029054134/" title="2013-11-24-6 by EricShj, on Flickr"><img src="http://farm3.staticflickr.com/2849/11029054134_87158b12d4.jpg" width="500" height="293" alt="2013-11-24-6"></a></p>

<p>图6 Text Kit中重要的几个对象</p>

<p>如图6所示，Text Kit中主要有4个重要的对象。</p>

<ul>
<li>1.Text View是用来显示文本内容的控件，主要包括UILabel、UITextView和UITextField。</li>
<li>2.Text containers对应着NSTextContainer类。NSTextContainer定义了文本可以排版的区域。一般来说，都是矩形区域，当然，也可以根据需求，通过子类化NSTextContainer来创建别的一些形状，例如圆形、不规则的形状等。NSTextContainer不仅可以创建文本可以填充的区域，它还维护着一个数组——该数组定义了一个区域，排版的时候文字不会填充该区域，因此，我们可以在排版文字的时候，填充非文本元素(例如图片，如图4所示)。</li>
<li>3.Layout manager对应着NSLayoutManager类。该类负责对文字进行编辑排版处理——通过将存储在NSTextStorage中的数据转换为可以在视图控件中显示的文本内容，并把统一的字符编码映射到对应的字形(glyphs)上，然后将字形排版到NSTextContainer定义的区域中。</li>
<li>4.Text storage对应着NSTextStorage类。该类定义了Text Kit扩展文本处理系统中的基本存储机制。NSTextStorage继承自NSmutableAttributedString，主要用来存储文本的字符和相关属性。另外，当NSTextStorage中的字符或属性发生了改变，会通知NSLayoutManager，进而做到文本内容的显示更新。</li>
</ul>


<p>通常情况下，NSTextStorage、NSLayoutManager和NSTextContainer是一一对应的。如图7所示关系：</p>

<p><a href="http://www.flickr.com/photos/105999540@N03/11028999346/" title="2013-11-24-7 by EricShj, on Flickr"><img src="http://farm4.staticflickr.com/3722/11028999346_3d78e9639e.jpg" width="500" height="41" alt="2013-11-24-7"></a></p>

<p>图7 普通排版</p>

<p>当然，如果需要将文字显示为多列，或多页，可以按照如图8所示关系——使用多个NSTextContainer。</p>

<p><a href="http://www.flickr.com/photos/105999540@N03/11029104793/" title="2013-11-24-8 by EricShj, on Flickr"><img src="http://farm6.staticflickr.com/5472/11029104793_ed7de38158.jpg" width="500" height="64" alt="2013-11-24-8"></a></p>

<p>图8 多页或者多列排版</p>

<p>如果针对不同的排版方式，则可以使用多个NSLayoutManager，如图9所示</p>

<p><a href="http://www.flickr.com/photos/105999540@N03/11029104933/" title="2013-11-24-9 by EricShj, on Flickr"><img src="http://farm4.staticflickr.com/3826/11029104933_824d194d5f.jpg" width="500" height="59" alt="2013-11-24-9"></a></p>

<p>图9 不同的排版方式</p>

<p>如图10所示，通过形象的方式，对UITextView的组成做了分解。通常，我们在设备上只能看到最右边的文本显示界面，而内部的NSTextStorage、NSLayoutManager和NSTextContainer是看不出来的。通常由NSLayoutManager从NSTextStorage中读取出文本数据，然后根据一定的排版方式，将文本排版到NSTextContainer中，再由NSTextContainer结合UITextView将最终效果显示出来。</p>

<p><a href="http://www.flickr.com/photos/105999540@N03/11029105053/" title="2013-11-24-10 by EricShj, on Flickr"><img src="http://farm8.staticflickr.com/7294/11029105053_875c954204.jpg" width="500" height="319" alt="2013-11-24-10"></a></p>

<p>图10 UITextView的分解</p>

<h3>Text Kit示例</h3>

<p>前面对Text Kit做了一些介绍，下面我们配合一个例子(图文排版)，来进一步加深对Text Kit的认识。具体实现步骤如下：</p>

<ul>
<li>1.打开Xcode 5，新建一个Single View Application模板的程序，将工程命名为ExclusionPath。</li>
<li>2.打开Main.storyboard文件，然后再默认View Controller的View里面分别添加一个UITextView和UIImageView。并将这两个控件连接到ViewController.h中(名称分别为textView何imageView)。然后给textView设置一些字符串，imageView设置一个图片。</li>
<li>3.打开ViewController.m文件，找到viewDidLoad方法，用如下代码替换该方法：</li>
</ul>


<p>```
&ndash; (void)viewDidLoad
{</p>

<pre><code>[super viewDidLoad]; 

//创建一个平移手势对象，该对象可以调用imagePanned：方法 
UIPanGestureRecognizer *panGes = [[UIPanGestureRecognizer alloc] initWithTarget:self action:@selector(imagePanned:)]; 
[self.imageView addGestureRecognizer:panGes]; 

self.textView.textContainer.exclusionPaths = @[[self translatedBezierPath]]; 
</code></pre>

<p>}
```</p>

<p>在上面的代码中，给imageView添加了一个平移手势。另外通过调用translatedBezierPath方法，给textView的textContainer设置exclusionPaths属性值。表示需要排除的区域（也就是图片在排版中显示的位置）。</p>

<ul>
<li>4.下面来看一下translatedBezierPath方法的实现，如下代码所示</li>
</ul>


<p>```
&ndash; (UIBezierPath *)translatedBezierPath
{</p>

<pre><code>CGRect butterflyImageRect = [self.textView convertRect:self.imageView.frame fromView:self.view]; 
UIBezierPath *newButterflyPath = [UIBezierPath bezierPathWithRect:butterflyImageRect]; 

return newButterflyPath; 
</code></pre>

<p>}
```</p>

<p>在上面的代码中，利用imageView的frame属性创建了一个UIBezierPath，然后将该值返回。</p>

<ul>
<li>5, 还记得第3步中创建的平移手势吗。里面有一个action需要实现imagePanned:，下面来看看这个方法的实现：</li>
</ul>


<p>```
&ndash; (void)imagePanned:(id)sender
{</p>

<pre><code>if ([sender isKindOfClass:[UIPanGestureRecognizer class]]) { 
    UIPanGestureRecognizer *localSender = sender; 

    if (localSender.state == UIGestureRecognizerStateBegan) { 
        self.gestureStartingPoint = [localSender translationInView:self.textView]; 
        self.gestureStartingCenter = self.imageView.center; 
    } else if (localSender.state == UIGestureRecognizerStateChanged) { 
        CGPoint currentPoint = [localSender translationInView:self.textView]; 

        CGFloat distanceX = currentPoint.x - self.gestureStartingPoint.x; 
        CGFloat distanceY = currentPoint.y - self.gestureStartingPoint.y; 

        CGPoint newCenter = self.gestureStartingCenter; 

        newCenter.x += distanceX; 
        newCenter.y += distanceY; 

        self.imageView.center = newCenter; 

        self.textView.textContainer.exclusionPaths = @[[self translatedBezierPath]]; 
    } else if (localSender.state == UIGestureRecognizerStateEnded) { 
        self.gestureStartingPoint = CGPointZero; 
        self.gestureStartingCenter = CGPointZero; 
    } 
} 
</code></pre>

<p>}
```</p>

<p>在上面的代码中首先根据平移的距离来设置imageView的位置，然后利用translatedBezierPath方法重新计算了一下排除区域。</p>

<ul>
<li>6, 至此代码编写完毕，下面来运行程序，看看实际效果。如图11所示：</li>
</ul>


<p><a href="http://www.flickr.com/photos/105999540@N03/11028998926/" title="2013-11-24-11 by EricShj, on Flickr"><img src="http://farm4.staticflickr.com/3709/11028998926_73393ee43a.jpg" width="332" height="500" alt="2013-11-24-11"></a></p>

<p>图11 运行效果</p>

<h3>小结</h3>

<p>实际上，上面的示例，只是揭秘了Text Kit功能的冰山一角。从iOS7及以后的版本中，Text Kit在UIKit framework里面占据重要的地位，Text Kit在文字处理方面，具有非常强大的功能，并且开发者可以对Text Kit进行定制和扩展。据悉，苹果利用了2年的时间来开发Text Kit，相信这对许多开发者来说都是福音。</p>

<p>推荐Text Kit学习资源
更多关于Text Kit的学习资料，请参考下面的内容：
wwdc视频:
Introducing Text Kit
Advanced Text Layouts and Effects with Text Kit
Using Fonts with Text Kit</p>

<p>苹果官方参考文档
Text Programming Guide for iOS.pdf
NSLayoutManager Class Reference for iOS.pdf
NSLayoutManagerDelegate Protocol Reference for iOS.pdf
NSTextContainer Class Reference for iOS.pdf
NSTextStorage Class Reference for iOS.pdf
NSTextStorageDelegate Protocol Reference for iOS.pdf</p>

<p>苹果官方示例：
IntroToTextKit</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[iOS Quick Tip: 7 Tips to Speed Up Your Development]]></title>
    <link href="http://shjborage.github.io/blog/2013/11/23/ios-quick-tip-7-tips-to-speed-up-your-development/"/>
    <updated>2013-11-23T16:18:00+08:00</updated>
    <id>http://shjborage.github.io/blog/2013/11/23/ios-quick-tip-7-tips-to-speed-up-your-development</id>
    <content type="html"><![CDATA[<p><a href="http://mobile.tutsplus.com/tutorials/iphone/ios-quick-tip-7-tips-to-speed-up-your-development/">origin</a></p>

<p>Most developers are always looking for ways to improve or automate their workflow being it with a simple script to automate a common task or by learning every possible keyboard shortcut of their favorite text editor. In this article, I will show you seven tips that will speed up and streamline your workflow in Xcode.</p>

<!-- more -->


<h3>1. Keyboard Shortcuts</h3>

<p>Virtually every Xcode command has a keyboard shortcut that you can learn and even customize. Investing the time to learn keyboard shortcuts will increase your efficiency tremendously. If you are like me, and a lot of other developers, you prefer to keep your hands on the keyboard when you’re writing code and that is exactly what most key bindings are for.</p>

<p>If you don’t like the default keyboard shortcuts, then you’ll be happy to learn that you can customize Xcode’s default keyboard shortcuts in the <strong>Preferences</strong> window under the <strong>Key Bindings</strong> tab.</p>

<p><a href="http://www.flickr.com/photos/105999540@N03/11006344093/" title="2013-11-23-1 by EricShj, on Flickr"><img src="http://farm4.staticflickr.com/3817/11006344093_814a28a77f.jpg" width="500" height="367" alt="2013-11-23-1"></a>
iOS Quick Tip: 5 Tips to Speed Up Your Development &ndash; Managing Key Bindings in Xcode&rsquo;s Preferences Window</p>

<p>If you don’t want to scroll through the long list of keyboard shortcuts to learn the most important ones, then I recommend browsing through this <a href="http://stackoverflow.com/questions/146297/hidden-features-of-xcode">question on Stack Overflow</a>. It lists the most important key bindings in Xcode and also includes a number of other neat tips and tricks.</p>

<h3>2. Cocoapods</h3>

<p>Cocoapods, a great project started by Eloy Durán, has gained significant traction in the Cocoa community. What is Cocoapods? Cocoapods is a tool for managing dependencies in Xcode projects. Due to Cocoapods’ popularity, hundreds of third party libraries have been updated to support Cocoapods. Even though Cocoapods is distributed as a Ruby gem, you don’t need to understand Ruby to benefit from Cocoapods.</p>

<p>If you are tired of manually managing third party libraries in your iOS or OS X projects, or you’re looking for a solution that makes updating third party libraries easier, then Cocoapods is the best solution available. If you want to learn about Cocoapods, then I recommend reading <a href="http://mobile.tutsplus.com/tutorials/iphone/streamlining-cocoa-development-with-cocoapods/">a post about Cocoapods</a> that I wrote earlier this year. It will get you up and running in minutes.</p>

<h3>3. Code Snippets</h3>

<p>Chances are that you use a text or code snippet manager, such as <strong>TextExpander</strong> or <strong>CodeBox</strong>. I use TextExpander all the time and it has saved me countless keystrokes over the years. <em>I use Dash to manage my document sets and code snippets.</em> However, Xcode also has a snippet manager. It lives in Xcode’s right sidebar next to the Object Library.</p>

<p>Why should you use Xcode’s snippet manager instead of the alternatives I mentioned earlier? In Xcode, each snippet has a number of additional attributes that really make snippets powerful and flexible. Each snippet has a Platform and Language attribute as well as a completion scope. A snippet’s completion scope is especially useful and integrates neatly with Xcode’s editor. Did I mention that each snippet can have multiple placeholders?</p>

<p><a href="http://www.flickr.com/photos/105999540@N03/11006222706/" title="2013-11-23-2 by EricShj, on Flickr"><img src="http://farm8.staticflickr.com/7364/11006222706_6e4d20315d.jpg" width="500" height="212" alt="2013-11-23-2"></a></p>

<p>iOS Quick Tip: 5 Tips to Speed Up Your Development &ndash; Creating and Managing Code Snippets is Very Easy in Xcode</p>

<h3>4. Learn Git</h3>

<p>If you’ve just started to learn how to program and the concept source control is new to you, then I strongly recommend that you take some time to learn the basics of Git. Git is <a href="http://en.wikipedia.org/wiki/Git_(software">a distributed version control and source code management system</a>). Euh … what? In short, Git helps you manage your source code easily and efficiently. Combine Git with GitHub or BitBucket and you are starting to look like a professional programmer. The added benefit is that Xcode integrates nicely with Git and this integration will only improve over time.</p>

<p>Once you’ve learned the basics of Git, it is recommended to include a proper .gitignore file in your Xcode project. A good place to start is this question on Stack Overflow.</p>

<p>Even though Git is commonly used through the command line, there are a number of applications that provide a GUI (Graphical User Interface). My favorite is <a href="http://www.git-tower.com/">Tower</a>, developed by Fournova, which recently reached version 1.5. Atlassian‘s <a href="https://www.atlassian.com/software/sourcetree/overview">SourceTree</a> is another great and free alternative.</p>

<h3>5. Xcode Behaviors</h3>

<p>Xcode is an incredibly powerful editor and it only gets better over the years. One of the aspects that I use frequently is Xcode’s <strong>Behaviors</strong> feature. By defining behaviors, you can tell Xcode what it should do when a particular event occurs, such as when a crash occurs while debugging or when you’ve successfully archived an application.</p>

<p>You can configure these behaviors in Xcode’s Preferences Window. If you don’t like it when Xcode shows the console when output is generated, you can disable this behavior in the <strong>Behaviors</strong> panel. Do you want Xcode to show the <strong>Issues Navigator</strong> when one or more tests fail? This is all possible with Xcode Behaviors.</p>

<p><a href="http://www.flickr.com/photos/105999540@N03/11006291054/" title="2013-11-23-3 by EricShj, on Flickr"><img src="http://farm4.staticflickr.com/3812/11006291054_0794190295.jpg" width="500" height="367" alt="2013-11-23-3"></a></p>

<p>iOS Quick Tip: 5 Tips to Speed Up Your Development &ndash; Managing Behaviors in Xcode&rsquo;s Preferences Window</p>

<p>Xcode predefines a number of common behaviors for you, such as Build, Testing, and Running. However, you can also define custom behaviors and assign a keyboard shortcut to it. This is a convenient way to set up Xcode the way you want with a single key binding.</p>

<h3>6. Tabs and Windows</h3>

<p>I really like the unified look of Xcode 4 and the integration of Interface Builder. However, it is sometimes useful to have more than one window at hand, for example, when you are working in the console and the editor at the same time or you use multiple monitors. In Xcode 4, it is still possible to work with multiple windows. You can create a new window using the keyboard shortcut <code>Shift + Cmd + T</code> or use the menu, <strong>File > New > Window</strong>.</p>

<p>Even more useful are tabs. Almost every code editor has tabs these days and Xcode is no exception. I rarely find myself in an Xcode window that has no, or one, tab. What few people know is that Xcode tabs can be named. You can even tie named tabs and Xcode behaviors together, which is especially useful during debugging.</p>

<h3>7. Documentation</h3>

<p>Even if you’ve been developing Cocoa applications for years, the documentation should never be more than a click away. There are a number of ways to quickly access Xcode’s documentation browser. The solution I use most often is holding the option key and clicking a method in Xcode’s code editor. This presents you with a summary of the particular method. If you want to read more or open the documentation browser, you can click one of the links in the pop up window.</p>

<p><a href="http://www.flickr.com/photos/105999540@N03/11006118705/" title="2013-11-23-4 by EricShj, on Flickr"><img src="http://farm8.staticflickr.com/7341/11006118705_ee2259bfdf.jpg" width="500" height="309" alt="2013-11-23-4"></a></p>

<p>iOS Quick Tip: 5 Tips to Speed Up Your Development &ndash; The Documentation is Your Friend</p>

<p>You can achieve the same by opening Xcode’s right sidebar and open the Quick Help Inspector tab. The help inspector updates as the cursor moves. As with the pop up window, clicking on one of the links in the help inspector takes you to the respective section in the documentation in the documentation browser.</p>

<p><a href="http://www.flickr.com/photos/105999540@N03/11006118685/" title="2013-11-23-5 by EricShj, on Flickr"><img src="http://farm4.staticflickr.com/3782/11006118685_ec1975ac10.jpg" width="500" height="422" alt="2013-11-23-5"></a></p>

<p>iOS Quick Tip: 5 Tips to Speed Up Your Development &ndash; The Quick Help Inspector</p>

<p>One of the downsides of Xcode’s documentation browser is that it can be slow at times. For this reason, I frequently use Dash, a dedicated documentation and snippet manager. Dash is very fast and provides support for more than eighty languages, libraries, frameworks, and APIs. It is well worth checking out.</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[iOS7 初步适配，与iOS6共存]]></title>
    <link href="http://shjborage.github.io/blog/2013/10/14/ios7-chu-bu-gua-pei-%2Cyu-ios6gong-cun/"/>
    <updated>2013-10-14T15:43:00+08:00</updated>
    <id>http://shjborage.github.io/blog/2013/10/14/ios7-chu-bu-gua-pei-,yu-ios6gong-cun</id>
    <content type="html"><![CDATA[<h4>状态栏隐藏问题</h4>

<p><strong>使用代码</strong>
<div class='bogus-wrapper'><notextile><figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
<span class='line-number'>11</span>
<span class='line-number'>12</span>
<span class='line-number'>13</span>
<span class='line-number'>14</span>
<span class='line-number'>15</span>
<span class='line-number'>16</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>&ndash; (BOOL)prefersStatusBarHidden
</span><span class='line'>{
</span><span class='line'>  return _isStatusHidden;//隐藏为YES，显示为NO
</span><span class='line'>}&lt;/p>
</span><span class='line'>
</span><span class='line'>&lt;ul>
</span><span class='line'>&lt;li>(void)hideStatusBar:(BOOL)isHidden
</span><span class='line'>{
</span><span class='line'>if ([self respondsToSelector:@selector(setNeedsStatusBarAppearanceUpdate)]) {
</span><span class='line'>  // iOS 7
</span><span class='line'>  _isStatusHidden = isHidden;
</span><span class='line'>  [self performSelector:@selector(setNeedsStatusBarAppearanceUpdate)];
</span><span class='line'>} else {
</span><span class='line'>  [[UIApplication sharedApplication] setStatusBarHidden:isHidden];
</span><span class='line'>}
</span><span class='line'>}</span></code></pre></td></tr></table></div></figure></notextile></div></li>
</ul>


<!-- more -->


<p><strong>Catagory</strong> 此处与root ViewController有关，不一定这样解决
<div class='bogus-wrapper'><notextile><figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
<span class='line-number'>11</span>
<span class='line-number'>12</span>
<span class='line-number'>13</span>
<span class='line-number'>14</span>
<span class='line-number'>15</span>
<span class='line-number'>16</span>
<span class='line-number'>17</span>
<span class='line-number'>18</span>
<span class='line-number'>19</span>
<span class='line-number'>20</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>@implementation UINavigationController (StatusBar)&lt;/p>
</span><span class='line'>
</span><span class='line'>&lt;ul>
</span><span class='line'>&lt;li>&lt;p>(UIStatusBarStyle)preferredStatusBarStyle
</span><span class='line'>{
</span><span class='line'>return UIStatusBarStyleLightContent;
</span><span class='line'>}&lt;/p>&lt;/li>
</span><span class='line'>&lt;li>&lt;p>(BOOL)prefersStatusBarHidden
</span><span class='line'>{
</span><span class='line'>if ([[self topViewController] isKindOfClass:[MovieDetailViewController class]]) {
</span><span class='line'>  MovieDetailViewController &lt;em>movieVC = (MovieDetailViewController &lt;/em>)[self topViewController];
</span><span class='line'>  return [movieVC prefersStatusBarHidden];
</span><span class='line'>}&lt;/p>
</span><span class='line'>
</span><span class='line'>&lt;p>return NO;
</span><span class='line'>}&lt;/p>&lt;/li>
</span><span class='line'>&lt;/ul>
</span><span class='line'>
</span><span class='line'>
</span><span class='line'>&lt;p>@end</span></code></pre></td></tr></table></div></figure></notextile></div></p>

<h4>与iOS6 共存问题</h4>

<p><strong>旋转方面还是iOS6里面那些改动，iOS7基本上没啥变化</strong></p>

<p>主要区别就是相对坐标问题，简单处理如下：</p>

<p>定义全局父类，使得所有ViewController处理些事件。<em>每个都加显然很麻烦的啦</em></p>

<p>```
//global_Header.h中相关的定义</p>

<h1>define kOSVersion (double)([[[UIDevice currentDevice] systemVersion] length] > 0 ? \</h1>

<p>(double)[[[UIDevice currentDevice] systemVersion] doubleValue] : (double)kMinOSVersion)
```</p>

<p><div class='bogus-wrapper'><notextile><figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
<span class='line-number'>11</span>
<span class='line-number'>12</span>
<span class='line-number'>13</span>
<span class='line-number'>14</span>
<span class='line-number'>15</span>
<span class='line-number'>16</span>
<span class='line-number'>17</span>
<span class='line-number'>18</span>
<span class='line-number'>19</span>
<span class='line-number'>20</span>
<span class='line-number'>21</span>
<span class='line-number'>22</span>
<span class='line-number'>23</span>
<span class='line-number'>24</span>
<span class='line-number'>25</span>
<span class='line-number'>26</span>
<span class='line-number'>27</span>
<span class='line-number'>28</span>
<span class='line-number'>29</span>
<span class='line-number'>30</span>
<span class='line-number'>31</span>
<span class='line-number'>32</span>
<span class='line-number'>33</span>
<span class='line-number'>34</span>
<span class='line-number'>35</span>
<span class='line-number'>36</span>
<span class='line-number'>37</span>
<span class='line-number'>38</span>
<span class='line-number'>39</span>
<span class='line-number'>40</span>
<span class='line-number'>41</span>
<span class='line-number'>42</span>
<span class='line-number'>43</span>
<span class='line-number'>44</span>
<span class='line-number'>45</span>
<span class='line-number'>46</span>
<span class='line-number'>47</span>
<span class='line-number'>48</span>
<span class='line-number'>49</span>
<span class='line-number'>50</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>&lt;/p>
</span><span class='line'>
</span><span class='line'>&lt;p>//
</span><span class='line'>//  UniversalViewController.m
</span><span class='line'>//  BFServiceStation
</span><span class='line'>//
</span><span class='line'>//  Created by Eric on 10/7/13.
</span><span class='line'>//  Copyright &copy; 2013 Baofeng. All rights reserved.
</span><span class='line'>//&lt;/p>
</span><span class='line'>
</span><span class='line'>&lt;h1>import &ldquo;UniversalViewController.h&rdquo;&lt;/h1>
</span><span class='line'>
</span><span class='line'>&lt;h1>import &ldquo;global_Header.h&rdquo;&lt;/h1>
</span><span class='line'>
</span><span class='line'>&lt;p>@interface UniversalViewController ()&lt;/p>
</span><span class='line'>
</span><span class='line'>&lt;p>@end&lt;/p>
</span><span class='line'>
</span><span class='line'>&lt;p>@implementation UniversalViewController&lt;/p>
</span><span class='line'>
</span><span class='line'>&lt;ul>
</span><span class='line'>&lt;li>&lt;p>(id)initWithNibName:(NSString &lt;em>)nibNameOrNil bundle:(NSBundle &lt;/em>)nibBundleOrNil
</span><span class='line'>{
</span><span class='line'>self = [super initWithNibName:nibNameOrNil bundle:nibBundleOrNil];
</span><span class='line'>if (self) {
</span><span class='line'>  // Custom initialization
</span><span class='line'>}
</span><span class='line'>return self;
</span><span class='line'>}&lt;/p>&lt;/li>
</span><span class='line'>&lt;li>&lt;p>(void)viewDidLoad
</span><span class='line'>{
</span><span class='line'>[super viewDidLoad];
</span><span class='line'>  // Do any additional setup after loading the view.&lt;/p>
</span><span class='line'>
</span><span class='line'>&lt;p>if (kOSVersion >= 7.0f) {
</span><span class='line'>  self.automaticallyAdjustsScrollViewInsets = NO;
</span><span class='line'>  [self setEdgesForExtendedLayout:UIRectEdgeNone];
</span><span class='line'>}
</span><span class='line'>}&lt;/p>&lt;/li>
</span><span class='line'>&lt;li>&lt;p>(void)didReceiveMemoryWarning
</span><span class='line'>{
</span><span class='line'>[super didReceiveMemoryWarning];
</span><span class='line'>// Dispose of any resources that can be recreated.
</span><span class='line'>}&lt;/p>&lt;/li>
</span><span class='line'>&lt;/ul>
</span><span class='line'>
</span><span class='line'>
</span><span class='line'>&lt;p>@end&lt;/p>
</span><span class='line'>
</span><span class='line'>&lt;p></span></code></pre></td></tr></table></div></figure></notextile></div></p>

<p>// 引用自CocoaChina</p>

<ul>
<li>1、如果设置了self.navigationController.navigationBar 设置了UIBarMetricsLandscapePhone的背景;而没有设置UIBarMetricsDefault的背景，navigationBar会变透明</li>
</ul>


<p>如图所示： navigationBar透明</p>

<p><a href="http://www.flickr.com/photos/105999540@N03/10374769665/" title="2013-10-14-4 by EricShj, on Flickr"><img src="http://farm6.staticflickr.com/5503/10374769665_9d71dd11b1.jpg" width="331" height="135" alt="2013-10-14-4"></a></p>

<ul>
<li>2、上图还出现了一个问题，如果没有设置self.automaticallyAdjustsScrollViewInsets = NO，那么iOS7下会自动让scrollView滑动多次，以满足UITableView第一行的显示需要，这又带来了另外一个问题，下拉刷新的View的frame也随之发生了改变，导致整个下拉刷新不可用了</li>
<li>3、self.automaticallyAdjustsScrollViewInsets 这个属性是IOS7才有的新方法，目的就是为了让scrollView自动适应屏幕，如果self.automaticallyAdjustsScrollViewInsets = NO，那么效果会变成下图所示：</li>
</ul>


<p><a href="http://www.flickr.com/photos/105999540@N03/10374769645/" title="2013-10-14-5 by EricShj, on Flickr"><img src="http://farm3.staticflickr.com/2856/10374769645_03d52ff8e7.jpg" width="332" height="122" alt="2013-10-14-5"></a></p>

<p>我的ViewController继承的是UITableViewController, 所以TableView是随系统而产生的，在IOS7之前，tableView的Frame的起始点是(0, 20),在IOS7之后，它的起始点变成了(0,0),这个时候如果为了让下拉刷新能正常工作，必须设置self.edgesForExtendedLayout = UIRectEdgeNone
（这种情况适用于容器建立在UINavigationController）.</p>

<ul>
<li>4、如果设置了self.navigationController.navigationBar 设置UIBarMetricsDefault的背景为空，则默认的是IOS7上边栏平铺效果，如果设置了图片，并且这个图片高度保持在44（88）,那么IOS5,6,7的效果是一致的。</li>
<li>5、iOS7中的StatusBar的没有了背景，他的UIStatusBarStyleLightContent和UIStatusBarStyleDefault只会改变StatusBar的文字，都不会有背景</li>
<li><p>6、ViewController-Based Status Bar Appearance控制了StatusBar的外观，如果设置为YES，则会调用preferredStatusBarStyle。如果为NO,则通过传统方式来控制</p>

<p>下图示IOS6，7上的正常情况</p></li>
</ul>


<p><a href="http://www.flickr.com/photos/105999540@N03/10374785016/" title="2013-10-14-6 by EricShj, on Flickr"><img src="http://farm3.staticflickr.com/2859/10374785016_dd23dccba9.jpg" width="332" height="122" alt="2013-10-14-6"></a></p>

<p><a href="http://www.flickr.com/photos/105999540@N03/10374784856/" title="2013-10-14-7 by EricShj, on Flickr"><img src="http://farm6.staticflickr.com/5501/10374784856_3cfc6e2085.jpg" width="322" height="210" alt="2013-10-14-7"></a></p>

<p><a href="http://www.flickr.com/photos/105999540@N03/10374769455/" title="2013-10-14-8 by EricShj, on Flickr"><img src="http://farm3.staticflickr.com/2840/10374769455_0e5a15cd77.jpg" width="394" height="155" alt="2013-10-14-8"></a></p>

<p>7、在IOS7下，如果不设置navigationBar的背景图片，而且设置[navigationBar setBarStyle:UIBarStyleBlackTranslucent];可以获取默认的黑色毛玻璃效果哟</p>

<p>如果大家还有遇到一些奇怪的问题，欢迎大家来补充</p>

<p><a href="http://www.flickr.com/photos/105999540@N03/10374769885/" title="2013-10-14-9 by EricShj, on Flickr"><img src="http://farm8.staticflickr.com/7389/10374769885_12ea31ec14_z.jpg" width="640" height="363" alt="2013-10-14-9"></a></p>

<p>本文参考文档:</p>

<p><a href="http://blog.jaredsinclair.com/post/61507315630/wrestling-with-status-bars-and-navigation-bars-on-ios-7">http://blog.jaredsinclair.com/post/61507315630/wrestling-with-status-bars-and-navigation-bars-on-ios-7</a>
<a href="https://developer.apple.com/library/ios/documentation/userexperience/conceptual/TransitionGuide/index.html">https://developer.apple.com/library/ios/documentation/userexperience/conceptual/TransitionGuide/index.html</a></p>
]]></content>
  </entry>
  
</feed>
