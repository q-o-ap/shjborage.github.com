<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">

  <title><![CDATA[Saick Blog - 专注技术，乐在其中]]></title>
  <link href="http://saick.net/atom.xml" rel="self"/>
  <link href="http://saick.net/"/>
  <updated>2013-10-30T23:35:53+08:00</updated>
  <id>http://saick.net/</id>
  <author>
    <name><![CDATA[Eric Shi]]></name>
    
  </author>
  <generator uri="http://octopress.org/">Octopress</generator>

  
  <entry>
    <title type="html"><![CDATA[ python MySQLdb安装以及问题汇总]]></title>
    <link href="http://saick.net/blog/2013/10/30/python-mysqldban-zhuang-yi-ji-wen-ti-hui-zong/"/>
    <updated>2013-10-30T23:17:00+08:00</updated>
    <id>http://saick.net/blog/2013/10/30/python-mysqldban-zhuang-yi-ji-wen-ti-hui-zong</id>
    <content type="html"><![CDATA[<p>自已备注一些, 斜体</p>

<p>转自：<a href="http://blog.chinaunix.net/uid-8487640-id-3183185.html">http://blog.chinaunix.net/uid-8487640-id-3183185.html</a></p>

<p>MySQLdb是Python连接MySQL的模块，下面介绍一下源码方式安装MySQLdb：</p>

<p>首先要下载下载：请到官方网站<a href="http://sourceforge.net/projects/mysql-python/%E6%88%96%E8%80%85">http://sourceforge.net/projects/mysql-python/%E6%88%96%E8%80%85</a> <a href="http://downloads.sourceforge.net/project/mysql-python/mysql-python-test/1.2.3c1/MySQL-python-1.2.3c1.tar.gz?use_mirror=nchc">点击链接下载</a></p>

<!-- more -->


<p>解压：tar zxvf MySQL-python*</p>

<p>进入文件目录，运行以下命令：</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>python setup.py install </span></code></pre></td></tr></table></div></figure>


<p>安装完成，到你的python安装目录下的site-packages目录里检查以下文件是否存在，如果存在即代表安装成功了</p>

<p>Linux：MySQL_python-1.2.3c1-py2.6-linux-i686.egg
Mac OS X：MySQL_python-1.2.3c1-py2.6-macosx-10.4-x86_64.egg</p>

<h4>注：如果碰到mysql_config not found的问题，有两种方法解决：<em>可能两个方法要合一起</em></h4>

<p>1）ln -s /usr/local/mysql/bin/mysql_config /usr/local/bin/mysql_config
将mysql_confi从你的安装目录链接到/usr/local/bin目录下，这样就可以在任意目录下访问了（也可以放到/usr/bin）</p>

<p>2）编辑源码文件夹的site.cfg文件，去掉#mysql_config = /usr/local/bin/mysql_config前的注释＃，修改后面的路径为你的mysql_config真正的目录就可以了。（如果不知道mysql_config在哪里，运行命令：whereis mysql_config）</p>

<h4>注:如果碰到import error: libmysqlclient.so.18: cannot open shared object file: No such file or directory</h4>

<p>解决方法:</p>

<p>locate or find libmysqlclient.so.18
link path/libmysqlclient.so.18 /usr/lib/libmysqlclient.so.18
vi /etc/ld.so.conf    //加入libmysqlclient.so.18 所在的目录
插入: /usr/lib/</p>

<p>保存退出后执行/sbin/ldconfig生效</p>

<h4><em>后部安装：需要进行一个软连接链接不然会提示报错。</em></h4>

<p>问题如下：</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
<span class='line-number'>11</span>
<span class='line-number'>12</span>
<span class='line-number'>13</span>
<span class='line-number'>14</span>
<span class='line-number'>15</span>
<span class='line-number'>16</span>
<span class='line-number'>17</span>
<span class='line-number'>18</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>&gt;&gt;&gt; from django.db import connection
</span><span class='line'>&gt;&gt;&gt; cursor = connection.cursor()
</span><span class='line'>Traceback (most recent call last):
</span><span class='line'>  File "&lt;console&gt;", line 1, in &lt;module&gt;
</span><span class='line'>  File "/Library/Python/2.7/site-packages/django/db/__init__.py", line 39, in __getattr__
</span><span class='line'>    return getattr(connections[DEFAULT_DB_ALIAS], item)
</span><span class='line'>  File "/Library/Python/2.7/site-packages/django/db/utils.py", line 193, in __getitem__
</span><span class='line'>    backend = load_backend(db['ENGINE'])
</span><span class='line'>  File "/Library/Python/2.7/site-packages/django/db/utils.py", line 108, in load_backend
</span><span class='line'>    return import_module('%s.base' % backend_name)
</span><span class='line'>  File "/System/Library/Frameworks/Python.framework/Versions/2.7/lib/python2.7/importlib/__init__.py", line 37, in import_module
</span><span class='line'>    __import__(name)
</span><span class='line'>  File "/Library/Python/2.7/site-packages/django/db/backends/mysql/base.py", line 17, in &lt;module&gt;
</span><span class='line'>    raise ImproperlyConfigured("Error loading MySQLdb module: %s" % e)
</span><span class='line'>ImproperlyConfigured: Error loading MySQLdb module: dlopen(/Library/Python/2.7/site-packages/MySQL_python-1.2.4b4-py2.7-macosx-10.9-intel.egg/_mysql.so, 2): Library not loaded: libmysqlclient.18.dylib
</span><span class='line'>  Referenced from: /Library/Python/2.7/site-packages/MySQL_python-1.2.4b4-py2.7-macosx-10.9-intel.egg/_mysql.so
</span><span class='line'>  Reason: image not found
</span><span class='line'>&gt;&gt;&gt; </span></code></pre></td></tr></table></div></figure>


<p>解决方案：</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>sudo ln -s /usr/local/mysql/lib/libmysqlclient.18.dylib /usr/lib/libmysqlclient.18.dylib</span></code></pre></td></tr></table></div></figure>

]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Dash：程序员的的好帮手]]></title>
    <link href="http://saick.net/blog/2013/10/27/dashcheng-xu-yuan-de-de-hao-bang-shou/"/>
    <updated>2013-10-27T20:08:00+08:00</updated>
    <id>http://saick.net/blog/2013/10/27/dashcheng-xu-yuan-de-de-hao-bang-shou</id>
    <content type="html"><![CDATA[<p>现在最新版UI比以前好一些，不过总体差异不大。</p>

<p>转自：<a href="http://blog.csdn.net/meegomeego/article/details/8798665">http://blog.csdn.net/meegomeego/article/details/8798665</a></p>

<p>作为一Coder，每天最常见的动作就是查看各种API文档，你一定也有过同时打开N个窗口（HTML、PDF、CHM），不停的在编辑器与文档之间切换的感受吧？怎么说呢，其实我很讨厌这种枯燥无味的动作，那么如何才能提高效率，减少无用功呢？下面就给大家介绍一款非常好用的Mac小工具：<em>Dash</em>，相比这个英文名，我跟喜欢叫它“叮当猫”，嘿嘿。</p>

<p><a href="http://itunes.apple.com/cn/app/dash-docs-snippets/id458034879?mt=12">点我直达AppStore介绍页面</a></p>

<h3>功能简介</h3>

<p>官方用一句话就概括了它的用途：Dash是一个API文档浏览器（ API Documentation Browser），以及代码片段管理工具（Code Snippet Manager）。你没看错，它就只有这两个功能，但确实是程序员（至少对于我来说）最为关心的特性，自己之前也用过了不少类似的工具，可以毫不夸张地说，Dash是它们之中做的最好的一个！</p>

<!-- more -->


<h4>强悍的API文档浏览、搜索功能</h4>

<p>想必这个功能是大家最常用的了吧，每天要反复查看、搜索那么多的API细节，没有一个好工具，单靠自己的双手如何应付得来？窗口不停的切来切去，很烦啊！Dash采用集成单一窗口的方式，很好的解决了这个问题。看下面的截图：</p>

<p><a href="http://www.flickr.com/photos/105999540@N03/10511272486/" title="2013-10-27-1 by EricShj, on Flickr"><img src="http://farm4.staticflickr.com/3789/10511272486_dc57f954a1.jpg" width="500" height="300" alt="2013-10-27-1"></a></p>

<p>上图便是Dash的API浏览器主界面：左侧边栏是各种编程语言以及框架（取决于你下载安装了多少文档集合）的导航大纲，点击某个节点，右边的内容区域就是文档的详细信息啦，非常直观。也可以在左上方的搜索框内通过输入关键字，查找相关的API文档，非常类似全文检索的实现方式，Dash的响应速度非常快！关键是可以同时查询不同的语言、框架内容，实在是太方便了。看到这里你也许要问了，这跟我们平常切换到特定的文档窗口（比如一个PDF或者一个CHM文件），再ctrl + f查找有什么区别，不是多此一举吗？其实你错了，Dash可以通过快捷键来显示、隐藏文档窗口，它提供了配置界面以便用户自行设置（我比较习惯alt+space，因为其他软件很少用到这个组合键）：</p>

<p><a href="http://www.flickr.com/photos/105999540@N03/10511306334/" title="2013-10-27-2 by EricShj, on Flickr"><img src="http://farm8.staticflickr.com/7356/10511306334_106b3b2151.jpg" width="423" height="234" alt="2013-10-27-2"></a></p>

<h4>Dash自带了丰富的API文档，涉及各种主流的编程语言和框架，全列出来很吓人的：</h4>

<p>ActionScript, Android, C++, Cappuccino, Cocos2D, Cocos3D, Corona, CSS, Django, Groovy, HTML, Java, JavaFX, JavaScript, jQuery, Kobold2D, Lua, MySQL, Node.js, Man Pages, Perl, PHP, Python, Ruby, Ruby on Rails, Scala, Sparrow, SQLite, Unity 3D, WordPress, XSLT, XUL</p>

<p>而且它的文档库采用了docset格式，高级用户基于网站提供的教程，很容易就能自行添加其他的扩充文档，其实Dash在最初发布的时候，只支持很少的几个文档浏览，好像只有Java、HTML、CSS这些，是后来通过用户不断贡献，以及作者及时的反馈（Rails API就是我通过Email与作者联系，请求添加的，作者非常nice），逐步壮大，才具备了如此广泛的语言、框架支持。要添加API文档，打开软件配置界面，切换到Docset选项卡即可看到所有内置的文档列表，按需要自行下载即可（如果是自己制作的docset，双击即可导入Dash）：</p>

<p><a href="http://www.flickr.com/photos/105999540@N03/10511306294/" title="2013-10-27-3 by EricShj, on Flickr"><img src="http://farm3.staticflickr.com/2845/10511306294_444ab45252.jpg" width="448" height="413" alt="2013-10-27-3"></a></p>

<h3>牛逼、好用的代码片段管理功能</h3>

<p>前面说完了Dash的文档查询功能，下面再来看一看它带给我们的另一个惊喜：代码片段管理。说到这里，之前的版本其实有个很不好的地方，就是如果不仔细琢磨一下，或者去看官方的帮助文档的话，用户是很难一眼就知道怎么用这个功能，新手引导做得确实不怎么样，不过最新版已经改善了这个问题，在主界面的导航边栏明确地给出了分类提示，创建或者修改代码片段都方便了许多。来看下面这个例子：</p>

<p><a href="http://www.flickr.com/photos/105999540@N03/10511306354/" title="2013-10-27-4 by EricShj, on Flickr"><img src="http://farm3.staticflickr.com/2856/10511306354_5e64bc1f92.jpg" width="500" height="427" alt="2013-10-27-4"></a></p>

<p>利用Dash的代码片段管理功能，我们可以把日常使用频繁（也就是你经常需要复制粘贴）的代码保存起来，然后为其设置一个独一无二的缩写，这样一来原本需要一遍又一遍的敲击键盘重复录入的繁琐工作，就可以交给Dash来帮你搞定啦。比如上面截图中的例子，就是ExtJS中发起Ajax请求的代码片段，哪怕是copy &amp; paste，时间长了也会很烦的，我给它设置了一个缩写（ajax），以后在需要编写这段代码的时候，就只需要敲击这几个字母，它就会魔法般的出现在光标所在位置啦！很神奇吧？嘿嘿，其实这种扩展缩写的功能，还有很多软件都能做到，比如TextExpander（这个我也买了，半价14刀的时候，但是现在已经打入冷宫了，比较后悔），不过就用户体验和各种细节，诸如界面UI，特别是扩展占位符的处理上，目前还没有哪一个能比得过Dash的（Dash is the best!）。来看看使用代码片段的截图吧：</p>

<p><a href="http://www.flickr.com/photos/105999540@N03/10511306264/" title="2013-10-27-5 by EricShj, on Flickr"><img src="http://farm3.staticflickr.com/2885/10511306264_3e3709bce1.jpg" width="500" height="364" alt="2013-10-27-5"></a></p>

<p>Dash的缩写扩展功能很强大，比方说上面那个例子，在保存代码片段的时候，你可以使用双下划线标明占位符，在执行扩展的时候就可以通过tab键来在各个占位符之间切换，根据需要输入实际的值，最后回车即可把片段粘贴到光标所在之处。除了占位符，它还支持下面这些变量符号：</p>

<ul>
<li> @clipboard 自动插入当前剪贴板中的内容</li>
<li> @cursor 代码片段粘贴完毕之后，自动将光标定位到此处</li>
<li> @date 自动插入当前日期</li>
<li> @time 自动插入当前时间</li>
</ul>


<p>介绍到这里，各位看官，你应该已经深深滴爱上Dash了吧？每个苦逼的程序员，都应该有这么一只可爱贴心的叮当猫，您说是不是？其实个人不是很喜欢它的图标，实在是有点太诡异了，嘿嘿……</p>

<p>最后再说一句，Dash在Mac App Store里面免费提供下载，不过作者包含了一个IAP（应用程序内购买）插件，作者挺幽默的，看介绍是说的Dash的双胞胎伙伴Pinky比较调皮，会时不时的跳出来打扰你一下，囧……反正我运行了一晚上，还没见到这只传说中的猫呢。其实这只不过是给你提供了赞助作者的机会，毕竟这么好的软件，如果经济条件允许，支持一下也无可厚非，同是软件开发者，其中的辛酸你我都懂的。</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Emacs 30分钟基础教程]]></title>
    <link href="http://saick.net/blog/2013/10/26/emacs-30fen-zhong-ji-chu-jiao-cheng/"/>
    <updated>2013-10-26T23:36:00+08:00</updated>
    <id>http://saick.net/blog/2013/10/26/emacs-30fen-zhong-ji-chu-jiao-cheng</id>
    <content type="html"><![CDATA[<h3>简介</h3>

<p>没有听说过 Emacs 吗？没有关系，花上30分钟就能了解和熟悉这个古老而强大 的编辑器。他被很多人称作世界上最强大的编辑器。用户从无数高手到IT民工到 普通文本编辑器用户，可以符合几乎所有人的需求。甚至可以在 Emacs 里运行 音乐播放器、网页浏览器等等，Emacs 更像是一个操作平台。</p>

<p>使用 Emacs 可以完全抛弃鼠标，不必在打字的同时把手移开键盘找鼠标，不必在 一大堆深藏不露的菜单里寻找那些常用功能，也不必被一条条工具栏遮挡视线。 大多数的 Windows 编辑器都有一条菜单栏，n条工具栏。菜单里有无数选项，很 多选项都会弹出一个对话框，这个对话框又会带有层层叠叠的标签，每个标签里 又有很多输入框很多按钮。一个简单的把所有字母大写的命令就要在菜单里翻半 天，说不定还找不到，而他们的帮助信息又总是不知所云。而 Emacs 的大多数操 作都可以通过快捷键或直接输入命令完成，而且有着极好的帮助系统，可以通过 多种方式找到你想要的命令或按键。</p>

<p>不要被 Emacs 简单的外观和与众不同的操作方式迷惑，上手 Emacs 并不是什么 难事，看一遍 Tutorial 就可以了，Emacs23 已经带着多种语言版本的快速指南， 包括中文。仍然觉得 Tutor 太长？那可以继续看本文。</p>

<!-- more -->


<h3>按键说明</h3>

<p>首先说明一下，Emacs 的按键表示方法。最常用的是 Ctrl 和 Alt 的组合键， 分别用 C 和 M 表示，比如:</p>

<p>C-x 就是 Ctrl+x，
M-x 就是 Alt+x，
C-M-f 就是 Ctrl+Alt+f，
M-% 就是 Alt+%，实际上是 Alt+Shift+5
C-x C-f 就是 Ctrl+x 然后再按 Ctrl+f，中间可以一直按着 Ctrl 也可以松 开，无所谓间隔多长时间。
这样你就可以简单的用 C 和 M 表示 ctrl 和 alt 了。Shift 可以用 S 表示。</p>

<p>键盘上的特殊按键用&lt;>表示，比如回车，空 格，方向键上， 等等，一看就知道什么意思。</p>

<p>不必追究为什么把 alt 写为 M，因为你这次只有30分钟时间。</p>

<h3>下载及安装</h3>

<h4>Windows 用户</h4>

<p>Windows 用户可以去 <a href="http://ntemacs.sf.net">http://ntemacs.sf.net</a> 下载可执行文件或者源代码。建议 下载Emacs23.x 。这是一个 7zip 的自动解压缩包，解压到你喜欢的目录就可以 了。</p>

<p>到这里你大概用了5分钟，当然，下载和解压缩时间不算在内。:)</p>

<h4>Linux 用户 (windows 用户可以忽略)</h4>

<p>可以下载 CVS 的 Emacs 代码，编译一下就好了。下载 CVS Emacs23:</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>$ cvs -z3 -d:pserver:anonymous@cvs.savannah.gnu.org:/sources/emacs co -r emacs-unicode-2 emacs</span></code></pre></td></tr></table></div></figure>


<p>编译:</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>$ cd emacs $ ./configure —enable-font-backend —with-xft —with-freetype —with-gtk</span></code></pre></td></tr></table></div></figure>


<p>注意 configure 的输出，是否缺少什么东西，没有问题的话就可以 make:</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>$ make bootstrap</span></code></pre></td></tr></table></div></figure>


<p>运行一下 src/emacs 如果没有问题的话就可以安装到默认路径：</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>$ sudo make install</span></code></pre></td></tr></table></div></figure>


<h3>常用命令</h3>

<h4>启动和退出</h4>

<p>Windows 用户可以用 Emacs bin 目录下的 runemacs.exe 启动，Linux 用户键 入 emacs &amp; 就可以了。</p>

<p>启动 Emacs 后应该能看到界面<br/>
退出 Emacs 按 C-x C-c (就是 Ctrl+x 接着按 Ctrl+c)。</p>

<h3>打开和保存文件</h3>

<p>启动 Emacs 后，按 C-x C-f，minibuffer (就是 Emacs 最下面一条) 会提示路 径，你可以在这里输入路径名和文件名，或者回车看到这个目录列表。可以 用方向键移动光标到文件名上回车打开文件，或者在子目录上进入子 目录，在 .. 上进入上一层目录。</p>

<p>打开文件后像往常一样编辑，随便按字母键输入一些字符。按 C-x C-s 保存文件。按 C-x k 回车关闭这个 buffer。</p>

<p><strong>小结：按键说明</strong></p>

<p>这里可以看到很多 C-x 开头的组合键，这些通常都是 Emacs 预先定义，全局性 的命令。按了 C-x 不动，一秒钟后 minibuffer 提示 C-x- ，表示 Emacs 正在 等待用户按下一个键。如果你想取消这次按键，可以接下去按 C-g，minibuffer 提示 C-x C-g is undefined 也就是说 Emacs 什么都没有执行。C-g 一般都是取 消命令，取消按键。如果按了 C-x C-h 就会出现一个帮助 buffer，里面是以 C-x 开头的按键帮助。C-h 是一个帮助按键。如何获得更多的帮助，会在之后的 小节介绍。C-c 开头的按键通常是用户自定义的按键和扩展包或扩展模式定义的 按键，同样也可以获得帮助信息。</p>

<h3>选定区域，剪切、复制、粘贴</h3>

<p>好了，到现在为止你大概一共花了 10 分钟吧。</p>

<p>你可以用鼠标拖选一块区域。当然，最好用键盘。按 C-@，minibuffer 提示 Mark set，设定了一个 mark。然后移动光标，这时候你就选定了光标和 Mark 之 间的区域。什么都看不到？你可以按 C-w，这块区域就消失了，C-w 是剪切。按 C-x u 可以撤销上一次的剪切，C-x u 是取消。你肯定想看到你到底选中了哪块 区域，可以按M-x 然后输入 transient-mark-mode ，回车。这次你就可以看到你 选中了哪块区域了。M-x 是执行 Emacs 命令。</p>

<p>【插播广告】</p>

<p>如果是德语键盘，在 Windows 下很可能按不出 C-@, 而 C-又被输入法占去了。所以最好自己设定 set-mark 的按键。比如把 C-&ldquo; 设为 mark 命令。按 C-: (ctrl-冒号) 输入下面这句话，然后回车：</p>

<p>(global-set-key (kbd &ldquo;C-\&rdquo;&ldquo;) &lsquo;set-mark-command)
可以在你的.emacs文件里加入类似的语句</p>

<p>【广告结束】</p>

<p>Emacs 有一个很有用的功能，在你选定了区域之后按 C-x C-x 可以交换光标 (point) 和 Mark 的位置，这样你就可以修改调整你选定的区域了。</p>

<p>按 C-g 取消选定的区域。</p>

<p>重新用 C-@ 选定一块区域，按 M-w，这是复制，移动光标到别处，按 C-y，这是 粘贴。紧接着再按一次 M-y，这时可以看到粘贴的内容变成了上一次剪切的内容。 再按 M-y 又变成之前一次复制的内容。</p>

<p>C-k 可以剪切一行。连续的 C-k 会把剪切的内容放在一起，一次 C-y 就可以把 之前的 n 行一起贴上。</p>

<p>C-x u 可以撤销，不过这个撤销和常规 windows 程序的撤销不太一样。按了 C-x u 撤销后，如果移动一下光标，再按一次 C-x u，可以撤销之前的撤销命令。 这样相当于是 redu。</p>

<p>小结：</p>

<p>C-@ 选定区域
C-w 剪切
M-w 复制
C-y 粘贴
M-y 粘贴剪贴板之前的内容
C-k 剪切一行
C-x u 撤销</p>

<h3>查找</h3>

<p>其 他 windows 程序的查找通常会跳出一个对话框，这很讨厌，会遮住文本内容， 有时候我就会忘了我到底要找什么。Emacs 就不会这样。按 C-s 是查找， minibuffer 提示 I-search: 接下来你可以输入你要找的词，比如想找 windows， 输入 w，Emacs 开始找到 w，光标移动到 w 上，接着输入 i，Emacs 找到 wi， 并注意到Emacs 会同时高亮所有的 wi，接着输入 n，Emacs 找到 win，等等。这 就是 incremetal search，它的好处是，你想要找 windows，但实际上你只要输 入 win 就能定位到 windows 上了，不需要继续输入 dows 了。继续按 C-s 找下 一个匹配的。C-r 往回查找。按回车或者方向键结束本次查找，再按两次 C-s 重 复上次查找，按 C-g 取消查找，光标回到原处。</p>

<p>C-s 或 C-r 也可以用作光标定位，比如想要移到前面 Emacs 处，就可以 C-r Emacs，效率很高，可以说是指哪打哪。</p>

<p>如果查找输入的全是小写，那么这次查找是大小写不敏感的，如果输入字符中有 大写字母，那么这次查找就是大小写敏感的。很智能吧。</p>

<p>C-M-s 或 C-M-r 是正则表达式查找。或者在 C-s 之后按 M-r 也可以切换到正则 表达式查找。这里不仔细讲 Emacs 的正则表达式是怎么样的。那样会多花一个小 时。</p>

<p>替换</p>

<p>M-% 是 query-replace，输入查找内容和替换内容，然后 Emacs 会询问是否要 替换，y 替换，n 不替换，! 替换光标之后所有，q 结束，? 可以得到帮助。</p>

<p>Emacs 的替换有一个很好的特性，可以只在选定区域内进行替换。这样就可以放 心大胆地使用 ! 替换所用，而不用担心超出范围了。</p>

<p>C-M-% 是正则表达式的替换。</p>

<p>小结：</p>

<p>C-s 和 C-r 向前向后查找
C-% 替换
C-M-s 和 C-M-r 向前向后正则表达式查找
C-M-% 正则表达式替换</p>

<h3>寻求帮助</h3>

<p>到这里你用了大概20分钟，基本的文本编辑功能都有了。</p>

<p>接着你可以自己摸索了。</p>

<p>Emacs 提供了极其强大的帮助系统。</p>

<p>C-h t 是一个 tutorial，现在也有不同语言的 tutorial。按 M-x 输入 help-with-tutorial-spec-language 可以选择不同的语言。按 Emacs 可 以帮你补全命令。按两次 会有补全的提示。</p>

<p>C-h a 是 apropos command，你可以输入几个简单的单词，Emacs 可以帮你找到 相应的命令，这个帮助非常好用。比如你想把一个单词全部大写，但不知道该怎 么做，可以 C-h a 输入 upcase word 或者 up word，Emacs 就会找到几个命令， 其中一个是 upcase-word，并且对应的按键是 M-u，你只要把光标移动到单词前 按 M-u 就可以了。</p>

<p>C-h k 是描述某个按键会执行什么。例如你要看看 M-; 是干什么的，按 C-h k， 接着按 M-; 你就会看到 M-; 会运行 comment-dwim，dwim 是 do what i mean 的缩写，这个命令会注释或反注释你选定的区域，如果没有选定区域，会在这一 行后面加上注释。很聪明的命令吧。</p>

<p>C-h c 简单描述某个按键执行什么。</p>

<p>C-h f 描述某个函数</p>

<p>C-h v 描述某个变量</p>

<p>C-h 会提供很多很多帮助信息，C-h ? 会显示有哪些帮助信息。</p>

<h3>简单配置</h3>

<p>Emacs 有超强的可配置性，1000个人可以有1000种配置，可以有自己的键绑定， 有自定义的函数，有自己喜欢的扩展包。配置放在 home 目录下的 .emacs 里， Emacs 启动的时候会自动读取这个文件。启动 Emacs 后，C-x C-f ~/.emacs 会 打开 .emacs 文件，如果不存在的话就是新建这个文件。home 目录在哪里呢？ 可以 M-x getenv home 得 到 home 的位置。Linux 系统很好理解。 Windows 系统，会默认放在 C:\Documents and Settings\username\Application Data 下，有几种方法可以指定 home 的位置：</p>

<p>在 我的电脑->属性->高级->环境变量 里添加一个 HOME 环境变量，指定位 置。
在注册表 [HKEY_CURRENT_USER\SOFTWARE\GNU\Emacs] (如果没有 GNU 或 Emacs，添加一个即可) 添加 HOME 字符串变量，值为指定的 home 路径。
Emacs 配置使用的语言是 Elisp，Emacs 附带非常详细的 Elisp 手册，可以通 过 M-x info 得到。配置 .emacs 一般只需要几个简单语句，比如：</p>

<p>(setq variable-name value) 设置变量值，例如 (setq transient-mark-mode t) 设置选定区域范围高亮
(require &lsquo;extension) 安装一个扩展包。
(load &ldquo;file-name&rdquo;) 使用一个 .el 文件
(global-set-key (kbd &ldquo;C-c f&rdquo;) &#8216;function-name) 全局自定义键绑定
(define-key dired-mode (kbd &ldquo;j&rdquo;) &#8216;dired-next-line) 局部键绑定，只在 dired-mode 起作用
(if &hellip;) 一些简单的判断语句
这里提供一个简单的 .emacs 文件: quick.emacs.el</p>

<p>你可以把它复制到你的 home 目录下并改名为 .emacs 注意有个.</p>

<p>或者用 runemacs.exe -q -l quick.emacs.el 来指定 emacs 使用这个配置文件。</p>

<h3>总结</h3>

<p>到这里差不多就是30分钟吧，介绍一些文本编辑的基本操作。只是为了说明上手 Emacs 其实很简单，而且几乎每一样操作都有比普通 Windows 文本编辑器更好 的特性，比如可以任意调整已选定的区域，更好的复制粘贴机制，更好的撤销机 制，更好的 isearch 查找方式，可以在区域内替换，强大得多的帮助系统，没 有任何限制的扩展性。用了几天或几个星期后就会觉得其他的编辑是多么麻烦和 弱小。</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Emacs中打造强大的Python IDE]]></title>
    <link href="http://saick.net/blog/2013/10/26/emacszhong-da-zao-qiang-da-de-python-ide/"/>
    <updated>2013-10-26T22:26:00+08:00</updated>
    <id>http://saick.net/blog/2013/10/26/emacszhong-da-zao-qiang-da-de-python-ide</id>
    <content type="html"><![CDATA[<p>本文将介绍，在Emacs中，通过各种扩展，打造强大的Python IDE环境，包括Snippet工具，智能提示，自动补全，重构工具，调试以及GAE的调试，等等。以下各工具的安装前提是你对Emacs的配置文件有一定的了解，所有相关的el文件都必须放在load_path能够加载的地方。</p>

<h3>1. YASnippet</h3>

<p>snippet工具，可自定义一些模板，必不可少的好东西！看了下面这个很酷的演示动画就明白了：</p>

<p><a href="http://yasnippet.googlecode.com/files/yasnippet.avi">http://yasnippet.googlecode.com/files/yasnippet.avi</a></p>

<p>安装方法：
(Add by Eric 建议看GitHub上的安装说明：<a href="https://github.com/capitaomorte/yasnippet">https://github.com/capitaomorte/yasnippet</a>)</p>

<!-- more -->




<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>(require 'yasnippet)
</span><span class='line'>(yas/initialize)
</span><span class='line'>(yas/load-directory "~/.emacs.d/plugins/yasnippet-0.6.1c/snippets")</span></code></pre></td></tr></table></div></figure>


<h3>2. AutoComplete</h3>

<p>自动完成工具，会像VS里一样，弹出一个列表框让你去选择。
<a href="http://www.flickr.com/photos/105999540@N03/10493765485/" title="2013-10-26-1 by EricShj, on Flickr"><img src="http://farm4.staticflickr.com/3678/10493765485_ce80f8cd35.jpg" width="414" height="309" alt="2013-10-26-1"></a></p>

<p>安装方法：</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
<span class='line-number'>11</span>
<span class='line-number'>12</span>
<span class='line-number'>13</span>
<span class='line-number'>14</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>(require 'auto-complete)
</span><span class='line'>(require 'auto-complete-config)
</span><span class='line'>(global-auto-complete-mode t)
</span><span class='line'>(setq-default ac-sources '(ac-source-words-in-same-mode-buffers))
</span><span class='line'>(add-hook 'emacs-lisp-mode-hook (lambda () (add-to-list 'ac-sources 'ac-source-symbols)))
</span><span class='line'>(add-hook 'auto-complete-mode-hook (lambda () (add-to-list 'ac-sources 'ac-source-filename)))
</span><span class='line'>(set-face-background 'ac-candidate-face "lightgray")
</span><span class='line'>(set-face-underline 'ac-candidate-face "darkgray")
</span><span class='line'>(set-face-background 'ac-selection-face "steelblue") ;;; 设置比上面截图中更好看的背景颜色
</span><span class='line'>(define-key ac-completing-map "\M-n" 'ac-next)  ;;; 列表中通过按M-n来向下移动
</span><span class='line'>(define-key ac-completing-map "\M-p" 'ac-previous)
</span><span class='line'>(setq ac-auto-start 2)
</span><span class='line'>(setq ac-dwim t)
</span><span class='line'>(define-key ac-mode-map (kbd "M-TAB") 'auto-complete)</span></code></pre></td></tr></table></div></figure>


<h3>3. Rope and Ropemacs</h3>

<p>非常棒的重构工具，比如rename,move,extract method等等。还有非常好用的goto difinition(跳到定义)，show documents(显示文档)等等。安装Ropemacs前，必须先安装rope和pymacs 。</p>

<p>rope的安装方法：</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>python setup.py install</span></code></pre></td></tr></table></div></figure>


<p>pymacs的安装方法：</p>

<p>python setup.py install
.emacs中：</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>(autoload 'pymacs-apply "pymacs")
</span><span class='line'>(autoload 'pymacs-call "pymacs")
</span><span class='line'>(autoload 'pymacs-eval "pymacs" nil t)
</span><span class='line'>(autoload 'pymacs-exec "pymacs" nil t)
</span><span class='line'>(autoload 'pymacs-load "pymacs" nil t)</span></code></pre></td></tr></table></div></figure>


<p>Ropmacs的安装方法：</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>python setup.py install</span></code></pre></td></tr></table></div></figure>


<p>.emacs中：</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>(pymacs-load "ropemacs" "rope-")
</span><span class='line'>(setq ropemacs-enable-autoimport t)</span></code></pre></td></tr></table></div></figure>


<h3>4. pycomplete</h3>

<p>一个更加强大的智能提示工具，比如，输入time.cl 然后按TAB键，会列出time模块所有cl开头的函数名。在调用函数时，还会在mini buffer中提示函数的参数类型。这个东西需要先安装pymacs。</p>

<p>安装方法：</p>

<ol>
<li>拷贝 python-mode.el and pycomplete.el 到Emacs的load_path中</li>
<li>拷贝 pycomplete.py 到PYTHONPATH (比如： c:/python25/Lib/site-packages)</li>
<li>.emacs中添加：</li>
</ol>


<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>(require 'pycomplete)
</span><span class='line'>(setq auto-mode-alist (cons '("\\.py$" . python-mode) auto-mode-alist))
</span><span class='line'>(autoload 'python-mode "python-mode" "Python editing mode." t)
</span><span class='line'>(setq interpreter-mode-alist(cons '("python" . python-mode)
</span><span class='line'>                           interpreter-mode-alist))</span></code></pre></td></tr></table></div></figure>


<h3>5. pdb调试</h3>

<p>在Emacs中，通过M-x pdb可调出pdb对python代码进行调试。但是发现在Windows系统中，总进入不了调试模式。主要原因有：</p>

<h4>1. windows中，找不到pdb.py位置。需自己制定pdb的路径。可以通过下面的方法设置pdb的路径：</h4>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>;; pdb setup, note the python version
</span><span class='line'>(setq pdb-path 'c:/python25/Lib/pdb.py
</span><span class='line'>       gud-pdb-command-name (symbol-name pdb-path))
</span><span class='line'> (defadvice pdb (before gud-query-cmdline activate)
</span><span class='line'>   "Provide a better default command line when called interactively."
</span><span class='line'>   (interactive
</span><span class='line'>    (list (gud-query-cmdline pdb-path
</span><span class='line'>                 (file-name-nondirectory buffer-file-name)))))</span></code></pre></td></tr></table></div></figure>


<h4>2. windows中，调用pdb时，未使用python -i 参数。</h4>

<p>针对上面两个问题，我的解决办法是，不设置pdb具体路径，M-x pdb 回车后，出现下面命令:</p>

<p>Run pdb (like this): pdb
然后手动修改一下：</p>

<p>Run pdb (like this): python -i -m pdb test.py
这样就搞定了。</p>

<h3>6. 如何调试GAE程序</h3>

<p>GAE是一个Web应用，需要跨线程进行调试，而pdb本身对线程调试支持不好。使用pdb进行线程调试时，只有在需要调试的地方插入下面代码：</p>

<p>import pdb
pdb.set_trace()</p>

<p>然后直接运行被调试代码，而不是通过python pdb来执行，就可以多线程代码进行调试了。</p>

<p>但是Google App Engine这样的Web应用，使用这个方法还是不能调试，和stdin和stdout有关，最后找到一个很好的解决方法：</p>

<p>def set_trace():</p>

<pre><code>import pdb, sys
debugger = pdb.Pdb(stdin=sys.__stdin__,
    stdout=sys.__stdout__)
debugger.set_trace(sys._getframe().f_back)
</code></pre>

<p>在任何需要调试的地方，调用上面的set_trace()函数。</p>

<p>如果你还有更好玩的东西，一定要告诉我！</p>

<h3>参考文档：</h3>

<p><a href="http://www.emacswiki.org/emacs/PythonMode">http://www.emacswiki.org/emacs/PythonMode</a></p>

<p><a href="http://www.enigmacurry.com/2008/05/09/emacs-as-a-powerful-python-ide/">http://www.enigmacurry.com/2008/05/09/emacs-as-a-powerful-python-ide/</a></p>

<p><a href="http://jjinux.blogspot.com/2008/05/python-debugging-google-app-engine-apps.html">http://jjinux.blogspot.com/2008/05/python-debugging-google-app-engine-apps.html</a></p>

<p>作者：CoderZh（CoderZh的技术博客 &ndash; 博客园）
微博：<a href="http://t.sina.com.cn/coderzh">http://t.sina.com.cn/coderzh</a>
出处：<a href="http://coderzh.cnblogs.com">http://coderzh.cnblogs.com</a>
文章版权归本人所有，欢迎转载，但未经作者同意必须保留此段声明，且在文章页面明显位置给出原文连接，否则保留追究法律责任的权利。</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[IP地址，0.0.0.0 监听，所有地址]]></title>
    <link href="http://saick.net/blog/2013/10/25/ipdi-zhi-%2C0-dot-0-0-dot-0-jian-ting-%2Csuo-you-di-zhi/"/>
    <updated>2013-10-25T01:07:00+08:00</updated>
    <id>http://saick.net/blog/2013/10/25/ipdi-zhi-,0-dot-0-0-dot-0-jian-ting-,suo-you-di-zhi</id>
    <content type="html"><![CDATA[<p>曾经在使用PonyDebugger时出现，socket连接老是被拒绝的情况。
PD可以自动连接，使用Boujour进行发现，很是方便。但是解析到了IP地址后，因为Server的监听有问题，老是connection refused. 笨笨的我还是没想到用<strong>0.0.0.0</strong>这个来监听所有IP地址，解决这个问题。</p>

<p>不能再出现同样的问题了，不用怕被别人笑话，哈哈</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Mac OS X添加PATH环境变量]]></title>
    <link href="http://saick.net/blog/2013/10/24/mac-os-xtian-jia-pathhuan-jing-bian-liang/"/>
    <updated>2013-10-24T23:53:00+08:00</updated>
    <id>http://saick.net/blog/2013/10/24/mac-os-xtian-jia-pathhuan-jing-bian-liang</id>
    <content type="html"><![CDATA[<p>解决办法:
sudo vim /etc/paths</p>

<p>将路径添加到里面去， 一行一个路径</p>

<p>注意：即便添加成功，未必运行成功；在制定路径下得脚本必须具是executable, 否则就会被在搜索时被忽略。
sudo chmod +x XXX</p>

<p>而在Ubuntu下，则只需要修改/etc/.profile或者 ~/.profile或~/.bashrc等修改</p>

<p>如转载文章，请注明本文链接： <a href="http://www.32133.com/skills/575.html">http://www.32133.com/skills/575.html</a></p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Django学习资源以及相关备注]]></title>
    <link href="http://saick.net/blog/2013/10/24/djangoxue-xi-zi-yuan-yi-ji-xiang-guan-bei-zhu/"/>
    <updated>2013-10-24T23:01:00+08:00</updated>
    <id>http://saick.net/blog/2013/10/24/djangoxue-xi-zi-yuan-yi-ji-xiang-guan-bei-zhu</id>
    <content type="html"><![CDATA[<p>对于我这个python新手，还是用Django入门比较容易一些，以后熟悉了可以再考虑换别的</p>

<p>Django 相关教程：</p>

<p><a href="http://www.ibm.com/developerworks/cn/linux/l-django/">Python Web 框架，第 1 部分: 使用 Django 和 Python 开发 Web 站点</a><br/>
<a href="http://www.ibm.com/developerworks/cn/opensource/os-cn-django/index.html">基于 Django 框架的敏捷 Web 开发</a></p>

<p>上面这俩有点老，参考一下即可。</p>

<!-- more -->


<p><a href="http://haoluobo.com/trac/wiki/Django">http://haoluobo.com/trac/wiki/Django</a></p>

<p>这哥们跟Django好像关系不错，收集了很多东西，起来帮助很大。不过有些链接进去也是广告N多，那种一看就是垃圾站。那个2010年版的Django Step by Step就是那样。</p>

<p>Django book 2.0 的中文翻译<br/>
<a href="http://djangobook.py3k.cn/2.0/">http://djangobook.py3k.cn/2.0/</a></p>

<p>这本书是我先看的，效果过段时间写入评论吧。
有些比较重要的，还是写到博文里吧，方便搜索。</p>

<h2>Django book 2.0 的中文翻译 读书笔记</h2>

<h3>模板使用方法及注意事项</h3>

<p>你可以根据需要使用任意多的继承次数。 使用继承的一种常见方式是下面的三层法：</p>

<ul>
<li>1.创建 base.html 模板，在其中定义站点的主要外观感受。 这些都是不常修改甚至从不修改的部分。</li>
<li>2.为网站的每个区域创建 base_SECTION.html 模板(例如, base_photos.html 和 base_forum.html )。这些模板对 base.html 进行拓展，并包含区域特定的风格与设计。</li>
<li>3.为每种类型的页面创建独立的模板，例如论坛页面或者图片库。 这些模板拓展相应的区域模板。</li>
</ul>


<p>这个方法可最大限度地重用代码，并使得向公共区域（如区域级的导航）添加内容成为一件轻松的工作。</p>

<p>以下是使用模板继承的一些诀窍：</p>

<ul>
<li>如果在模板中使用 ｛% extends %｝ ，必须保证其为模板中的第一个模板标记。 否则，模板继承将不起作用。</li>
<li><p>一般来说，基础模板中的 ｛% block %｝ 标签越多越好。 记住，子模板不必定义父模板中所有的代码块，因此你可以用合理的缺省值对一些代码块进行填充，然后只对子模板所需的代码块进行（重）定义。 俗话说，钩子越多越好。</p></li>
<li><p>如果发觉自己在多个模板之间拷贝代码，你应该考虑将该代码段放置到父模板的某个 ｛% block %｝ 中。</p></li>
<li><p>如果你需要访问父模板中的块的内容，使用 ｛｛ block.super ｝｝这个标签吧，这一个魔法变量将会表现出父模板中的内容。 如果只想在上级代码块基础上添加内容，而不是全部重载，该变量就显得非常有用了。</p></li>
<li><p>不允许在同一个模板中定义多个同名的 ｛% block %｝ 。 存在这样的限制是因为block 标签的工作方式是双向的。 也就是说，block 标签不仅挖了一个要填的坑，也定义了在父模板中这个坑所填充的内容。如果模板中出现了两个相同名称的 ｛% block %｝ 标签，父模板将无从得知要使用哪个块的内容。</p></li>
<li><p>｛% extends %｝ 对所传入模板名称使用的加载方法和 get_template() 相同。 也就是说，会将模板名称被添加到 TEMPLATE_DIRS 设置之后。</p></li>
<li><p>多数情况下， ｛% extends %｝ 的参数应该是字符串，但是如果直到运行时方能确定父模板名，这个参数也可以是个变量。 这使得你能够实现一些很酷的动态功能。</p></li>
</ul>

]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Mac OS X: 停止响应的处理（包含强制重启机器）]]></title>
    <link href="http://saick.net/blog/2013/10/23/mac-os-x-ting-zhi-xiang-ying-de-chu-li-bao-han-qiang-zhi-zhong-qi-ji-qi/"/>
    <updated>2013-10-23T22:47:00+08:00</updated>
    <id>http://saick.net/blog/2013/10/23/mac-os-x-ting-zhi-xiang-ying-de-chu-li-bao-han-qiang-zhi-zhong-qi-ji-qi</id>
    <content type="html"><![CDATA[<p><em>Mac OS X: 如果您的计算机停止响应、“悬挂”或“冻结”</em></p>

<p>本文章已经归档，因此 Apple 将不再对其进行更新。</p>

<h4>症状</h4>

<p>了解如何消除计算机停止响应（“悬挂”或“冻结”）的情况。解决频发问题可能需要本文以外的解决方法。
重要：
所打开的应用程序中未保存的更改将会丢失。这些步骤适用于 Mac OS X 和 Mac OS X Server。“没有响应”通常是以一个旋转的指针和（或）输入响应时间缓慢（或者根本没有响应）来界定的。
解决方法</p>

<h4>1. 退出打开的应用程序</h4>

<!-- more -->


<p>如果您的计算机停止响应，那么您有时可以通过退出打开的应用程序来恢复。通过从“文件”菜单中选择“退出”或者按下 Command-Q 组合键，几乎可以退出所有的应用程序。</p>

<p>Classic 环境也可能是没有响应的根源。要确定是否运行了 Classic 环境，可以打开“系统预置”，然后从“显示”菜单中选择 Classic 。单击“启动/停止”选项卡，然后注意 Classic 环境的状态，它将会显示在“请为 Classic 选择系统文件夹”部分的上面。要停止 Classic 环境，请单击“停止”。</p>

<h4>2. 强制退出应用程序</h4>

<p>如果您不能以正常方式退出应用程序，那么请试着通过从 Apple 菜单中选择“强制退出”来强制退出程序。在出现的对话框中，选定没有响应的应用程序，然后单击“强制退出”按钮。</p>

<p>要强制退出 Classic 环境，请打开“系统预置”应用程序，然后从“显示”菜单中选择 Classic 。单击“启动/停止”选项卡，然后单击“强制退出”。</p>

<p>警告：当前文档中未保存的更改将会丢失。</p>

<h4>3. 重新启动计算机</h4>

<p>通常您可以通过重新启动计算机来解决问题，它将会清除它的内存。在重新启动之前，请确保保存所有打开的文档。通常试着采用正确的方式来重新启动：</p>

<ul>
<li> 从 Apple 菜单中选择“重新启动”，或者</li>
<li> 在有些计算机中，您可以按下键盘上的电源键，然后在出现的对话框中单击“重新启动”。如果您的计算机使用的是 Apple 专业键盘，那么请按下 Control-Eject 组合键，然后在出现的对话框中单击“重新启动”。</li>
</ul>


<h4>4. 关闭计算机</h4>

<p>正如在重新启动计算机时一样，您可以通过重新启动计算机来解决问题，这将会清除它的内存。在重新启动之前，请确保保存所有打开的文档。通常试着采用正确的方式来重新启动：</p>

<ul>
<li> 从 Apple 菜单中选择“关机”，或者</li>
<li> 在有些计算机中，您可以按下键盘上的电源键，然后在出现的对话框中单击“关机”。如果您的计算机使用的是 Apple 专业键盘，那么请按下 Control-Eject 组合键，然后在出现的对话框中单击“关机”。</li>
</ul>


<h4>5. 强制关闭计算机</h4>

<p>您应该只有在上述所有步骤（1 &ndash; 4）都失败的情况下才强制关闭您的计算机。
1. 按住计算机上的电源键保持 6 秒钟，以关闭计算机。</p>

<p>注意：请不要按下显示器上的电源键。</p>

<ol>
<li>等待 10 秒钟，然后再打开计算机。
注意：
这项技术不适用于某些早期的与 Mac OS X 兼容的计算机。在这些计算机中，可以在按下重置键（参阅下面的内容）后立即按下电源键来关闭计算机。</li>
</ol>


<h4>6. 强制重启计算机</h4>

<p>您应该在只有上述所有步骤（1 &ndash; 5）都失败的情况下才试着强制重启计算机。当您的计算机停止响应时，强制重启计算机并不是首选的解决方法。</p>

<p>如果您不能以正常方式重新启动您的计算机，那么请尝试下面的方法：</p>

<ul>
<li> 按下 Command-Control-Power 组合键。若您的计算机使用的是 Apple 专业键盘，那么不适用这种方法。</li>
</ul>


<p>如果这种方法无效，那么请执行下面的操作：</p>

<ul>
<li> 如果您的计算机有“重置”键孔，那么请小心地将伸直的曲别针插入孔中，并轻轻地按一下。取出曲别针。您的计算机就应该重新启动了。关于“重置”键孔的位置，请参阅计算机附带的技术资料。</li>
<li> 如果您的计算机有“重置”键，那么请按下它。重置键在计算机上，而不在键盘上，并且是用一个三角形标记的。关于“重置”键的位置，请参阅计算机附带的技术资料。</li>
</ul>


<p>注意：
有些 PowerBook 计算机没有“重置”键。在这种情况下，请按下 Shift-Function-Control-Power 组合键，直到计算机关闭。然后，等待至少 30 秒，然后通过按下电源键重新打开 PowerBook。</p>

<h4>7. 拔掉计算机的电源</h4>

<p>如果重置无效，并且您的计算机是插入到有开关的插座板上的，那么请关闭插座板上的开关。如果没有开关，那么请拔掉计算机的电源。等待至少 30 秒，然后重新打开计算机。可以通过按下键盘或计算机上的电源键来重新打开计算机。
上次修改时间： 2011-11-22</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[浅谈五大Python Web框架]]></title>
    <link href="http://saick.net/blog/2013/10/23/qian-tan-wu-da-python-webkuang-jia/"/>
    <updated>2013-10-23T00:14:00+08:00</updated>
    <id>http://saick.net/blog/2013/10/23/qian-tan-wu-da-python-webkuang-jia</id>
    <content type="html"><![CDATA[<p>摘要：作者飞龙写了一篇《浅谈Python Web框架》，文中他介绍了几个Python Web框架和自己对选择框架的分析。在他看来，用Django来快速开发一些Web运用是很不错的选择。</p>

<p>导读：作者飞龙写了一篇《浅谈Python Web框架》，文中他介绍了几个Python Web框架和自己对选择框架的分析。在他看来，用Django来快速开发一些Web运用是很不错的选择。以下是文章内容：</p>

<p>说到Web Framework，Ruby的世界Rails一统江湖，而Python则是一个百花齐放的世界，各种micro-framework、framework不可胜数，不完全列表见：</p>

<p><a href="http://wiki.python.org/moin/WebFrameworks%E3%80%82">http://wiki.python.org/moin/WebFrameworks%E3%80%82</a></p>

<!-- more -->


<p>虽然另一大脚本语言PHP也有不少框架，但远没有Python这么夸张，也正是因为Python Web Framework（Python Web开发框架，以下简称Python框架）太多，所以在Python社区总有关于Python框架孰优孰劣的话题，讨论的时间跨度甚至长达3-5年。</p>

<p>Python这么多框架，能挨个玩个遍的人不多，坦白的说我也只用过其中的三个开发过项目，另外一些稍微接触过，所以这里只能浅谈一下，欢迎懂行的朋友们补充。</p>

<h3>Django</h3>

<p>Python框架虽然说是百花齐放，但仍然有那么一家是最大的，它就是Django。要说Django是Python框架里最好的，有人同意也有人 坚决反对，但说Django的文档最完善、市场占有率最高、招聘职位最多估计大家都没什么意见。Django为人所称道的地方主要有：</p>

<p>完美的文档，Django的成功，我觉得很大一部分原因要归功于Django近乎完美的官方文档（包括Django book）。</p>

<p>全套的解决方案，Django象Rails一样，提供全套的解决方案（full-stack framework + batteries included），基本要什么有什么（比如：cache、session、feed、orm、geo、auth），而且全部Django自己造，开发网 站应手的工具Django基本都给你做好了，因此开发效率是不用说的，出了问题也算好找，不在你的代码里就在Django的源码里。</p>

<p>强大的URL路由配置，Django让你可以设计出非常优雅的URL，在Django里你基本可以跟丑陋的GET参数说拜拜。</p>

<p>自助管理后台，admin interface是Django里比较吸引眼球的一项contrib，让你几乎不用写一行代码就拥有一个完整的后台管理界面。</p>

<p>而Django的缺点主要源自Django坚持自己造所有的轮子，整个系统相对封闭，Django最为人诟病的地方有：</p>

<p>系统紧耦合，如果你觉得Django内置的某项功能不是很好，想用喜欢的第三方库来代替是很难的，比如下面将要说的ORM、Template。要在Django里用SQLAlchemy或Mako几乎是不可能，即使打了一些补丁用上了也会让你觉得非常非常别扭。</p>

<p>Django自带的ORM远不如SQLAlchemy强大，除了在Django这一亩三分地，SQLAlchemy是Python世界里事实上的ORM标准，其它框架都支持SQLAlchemy了，唯独Django仍然坚持自己的那一套。Django的开发人员对SQLAlchemy的支持也是有 过讨论和尝试的，不过最终还是放弃了，估计是代价太高且跟Django其它的模块很难合到一块。</p>

<p>Template功能比较弱，不能插入Python代码，要写复杂一点的逻辑需要另外用Python实现Tag或Filter。关于模板这一点，一直以来争论比较多，最近有两篇关于Python模板的比较有意思的文章可供参考：</p>

<p><a href="http://pydanny.blogspot.com/2010/12/stupid-template-languages.html%EF%BC%88%E9%9C%80%E7%BF%BB%E5%A2%99%EF%BC%89">http://pydanny.blogspot.com/2010/12/stupid-template-languages.html%EF%BC%88%E9%9C%80%E7%BF%BB%E5%A2%99%EF%BC%89</a>
<a href="http://techspot.zzzeek.org/2010/12/04/in-response-to-stupid-template-languages/">http://techspot.zzzeek.org/2010/12/04/in-response-to-stupid-template-languages/</a>
URL配置虽然强大，但全部要手写，这一点跟Rails的Convention over configuration的理念完全相左，高手和初识Django的人配出来的URL会有很大差异。</p>

<p>让人纠结的auth模块，Django的auth跟其它模块结合紧密，功能也挺强的，就是做的有点过了，用户的数据库schema都给你定好了，这样问题就来了，比如很多网站要求email地址唯一，可schema里这个字段的值不是唯一的，纠结是必须的了。</p>

<p>Python文件做配置文件，而不是更常见的ini、xml或yaml等形式。这本身不是什么问题，可是因为理论上来说settings的值是能够动态的改变的（虽然大家不会这么干），但这不是最佳实践的体现。</p>

<p>总的来说，Django大包大揽，用它来快速开发一些Web运用是很不错的。如果你顺着Django的设计哲学来，你会觉得Django很好用，越用越顺手；相反，你如果不能融入或接受Django的设计哲学，你用Django一定会很痛苦，趁早放弃的好。所以说在有些人眼里Django无异于仙丹， 但对有一些人来说它又是毒药且剧毒。</p>

<h3>Pylons &amp; TurboGears &amp; repoze.bfg</h3>

<p>除了Django另一个大头就是Pylons了，因为TurboGears2.x是基于Pylons来做的，而repoze.bfg也已经并入Pylons project里这个大的项目里，后面不再单独讨论TurboGears和repoze.bfg了。</p>

<p>Pylons和Django的设计理念完全不同，Pylons本身只有两千行左右的Python代码，不过它还附带有一些几乎就是Pylons御用 的第三方模块。Pylons只提供一个架子和可选方案，你可以根据自己的喜好自由的选择Template、ORM、form、auth等组件，系统高度可 定制。我们常说Python是一个胶水语言(glue language)，那么我们完全可以说Pylons就是一个用胶水语言设计的胶水框架。</p>

<p>选择Pylons多是选择了它的自由，选择了自由的同时也预示着你选择了噩梦：</p>

<p>学习噩梦，Pylons依赖于许多第三方库，它们并不是Pylons造，你学Pylons的同时还得学这些库怎么使用，关键有些时候你都不知道你 要学什么。Pylons的学习曲线相对比Django要高的多，而之前Pylons的官方文档也一直是人批评的对象，好在后来出了The Definitive Guide to Pylons这本书，这一局面有所改观。因为这个原因，Pylons一度被誉为只适合高手使用的Python框架。</p>

<p>调试噩梦，因为牵涉到的模块多，一旦有错误发生就比较难定位问题处在哪里。可能是你写的程序的错、也可能是Pylons出错了、再或是SQLAlchemy出错了、搞不好是formencode有bug，反正很凌乱了。这个只有用的很熟了才能解决这个问题。</p>

<p>升级噩梦，安装Pylons大大小小共要安装近20个Python模块，各有各自的版本号，要升级Pylons的版本，哪个模块出了不兼容的问题都有可能，升级基本上很难很难。至今reddit的Pylons还停留在古董的0.9.6上，SQLAlchemy也还是0.5.3的版本，应该跟这条有关系。</p>

<p>Pylons和repoze.bfg的融合可能会催生下一个能挑战Django地位的框架。</p>

<h3>Tornado &amp; web.py</h3>

<p>Tornado即是一个Web server（对此本文不作详述），同时又是一个类web.py的micro-framework，作为框架Tornado的思想主要来源于Web.py，大家在Web.py的网站首页也可以看到Tornado的大佬Bret Taylor的这么一段话（他这里说的FriendFeed用的框架跟Tornado可以看作是一个东西）：</p>

<p>“[web.py inspired the] Web framework we use at FriendFeed [and] the webapp framework that ships with App Engine…”</p>

<p>因为有这层关系，后面不再单独讨论Tornado。</p>

<p>Web.py的设计理念力求精简（Keep it simple and powerful），总共就没多少行代码，也不像Pylons那样依赖大量的第三方模块，而是只提供的一个框架所必须的一些东西，如：URL路由、 Template、数据库访问，其它的就交给用户自己去做好了。</p>

<p>一个框架精简的好处在于你可以聚焦在业务逻辑上，而不用太多的去关心框架本身或受框架的干扰，同时缺点也很明显，许多事情你得自己操刀上。</p>

<p>我个人比较偏好这种精简的框架，因为你很容易通过阅读源码弄明白整个框架的工作机制，如果框架那一块不是很合意的话，我完全可以Monkey patch一下按自己的要求来。</p>

<h3>Bottle &amp; Flask</h3>

<p>Bottle和Flask作为新生一代Python框架的代表，挺有意思的是都采用了decorator的方式配置URL路由，如：</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>from bottle import route, run
</span><span class='line'> 
</span><span class='line'>@route('/:name')
</span><span class='line'>def index(name='World'):
</span><span class='line'>    return '&lt;b&gt;Hello %s!&lt;/b&gt;' % name
</span><span class='line'> 
</span><span class='line'>run(host='localhost', port=8080)</span></code></pre></td></tr></table></div></figure>


<p>Bottle、Flask跟web.py一样，都非常精简，Bottle甚至所有的代码都在那一个两千来行的.py文件里。另外Flask和Pylons一样，可以跟Jinja2、SQLAlchemy之类结合的很好。</p>

<p>不过目前不管是Bottle还是Flask成功案例都还很少。</p>

<h3>Quixote</h3>

<p>之所以要特别说一下Quixote，是因为国内的最大的用Python开发的网站“豆瓣网”是用Quixote开发的。我只简单翻了一下源代码，没有做过研究，不发表评论，有经验的来补充下。我只是在想，如果豆瓣网交到现在来开发，应该会有更多的选择。</p>

<p>其它（web2py、uliweb、Karrigell、Werkzeug …）</p>

<h3>最后关于框架选择的误区</h3>

<p>在框架的选择问题上，许多人很容易就陷入了下面两个误区中而不自知：</p>

<ol>
<li><p>哪个框架最好——世上没有最好的框架，只有最适合你自己、最适合你的团队的框架。编程语言选择也是一个道理，你的团队Python最熟就用Python好了，如果最熟悉的是Ruby那就用Ruby好了，编程语言、框架都只是工具，能多、快、好、省的干完活就是好东西。</p></li>
<li><p>过分关注性能——其实大部分人是没必要太关心框架的性能的，因为你开发的网站根本就是个小站，能上1万的IP的网站已经不多了，上10万的更是很少很少。在没有一定的访问量前谈性能其实是没有多大意义的，因为你的CPU和内存一直就闲着呢。而且语言和框架一般也不会是性能瓶颈，性能问题最常出现在数据库访问和文件读写上。 PHP的Zend Framework是出了名的慢，但是Zend Framework一样有大站，如：digg.com；常被人说有性能问题的Ruby和Rails，不是照样可以开发出twitter吗？再者现在的硬 件、带宽成本其实是很低的，特别有了云计算平台后，人力成本才是最贵的，没有上万的IP根本就不用太在意性能问题，流量上去了花点钱买点服务器空间好了， 简单快速的解决性能问题。</p></li>
</ol>


<p>注：前面有网友质疑我“Quora是用Pylons开发的”这样的说法不客观，特说明一下，这里所说的某个网站A是用B开发的，只是指A主要或部分是由B开发的，大家就不要再去纠结A还用C了。</p>

<p>原文链接：<a href="http://feilong.me/2011/01/talk-about-python-web-framework">http://feilong.me/2011/01/talk-about-python-web-framework</a></p>

<h3>个人实践</h3>

<p>对于我这个python新手，还是用Django吧，可能容易一些，以后熟悉了可以再考虑换别的</p>

<p>Django 相关教程：</p>

<p><a href="http://www.ibm.com/developerworks/cn/linux/l-django/">Python Web 框架，第 1 部分: 使用 Django 和 Python 开发 Web 站点</a><br/>
<a href="http://www.ibm.com/developerworks/cn/opensource/os-cn-django/index.html">基于 Django 框架的敏捷 Web 开发</a></p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[对比iOS网络组件：AFNetworking VS ASIHTTPRequest]]></title>
    <link href="http://saick.net/blog/2013/10/20/dui-bi-ioswang-luo-zu-jian-%3Aafnetworking-vs-asihttprequest/"/>
    <updated>2013-10-20T22:55:00+08:00</updated>
    <id>http://saick.net/blog/2013/10/20/dui-bi-ioswang-luo-zu-jian-:afnetworking-vs-asihttprequest</id>
    <content type="html"><![CDATA[<p>在开发iOS应用过程中，如何高效的与服务端API进行数据交换，是一个常见问题。一般开发者都会选择一个第三方的网络组件作为服务，以提高开发效率和稳定性。这些组件把复杂的网络底层操作封装成友好的类和方法，并且加入异常处理等。</p>

<p>那么，大家最常用的组件是什么？这些组件是如何提升开发效率和稳定性的？哪一款组件适合自己，是 AFNetworking（AFN）还是 ASIHTTPRequest（ASI）？几乎每一个iOS互联网应用开发者都会面对这样的选择题，要从这两个最常用的组件里选出一个好的还真不是那么容易。</p>

<p>单单从两个控件版本提交的时间节点来看，AFN的第一个提交是2011年的1月1日，那个时候ASI早已是1.8+的版本了；而当AFN发布1.0版，2012年10月份的时候，ASI早早的已经停止更新了。这样看起来，AFN是ASI的继任者，似乎不存在之前提到的选择困难的问题，而事实并非如此。本文将从用法、功能、性能和原理几个方面对二者进行简单对比，看看二者之间到底存在着怎样的区别，到底应该如何选择。</p>

<!-- more -->


<ul>
<li>首先，从推荐用法上就可以看出二者设计理念上大有不同。</li>
</ul>


<h3>1、用法对比</h3>

<p><a href="http://www.flickr.com/photos/105999540@N03/10382705763/" title="2013-10-20-5 by EricShj, on Flickr"><img src="http://farm3.staticflickr.com/2867/10382705763_25114b14ed.jpg" width="464" height="309" alt="2013-10-20-5"></a></p>

<p>图1，AFN的示例代码，发起请求（出自：Posts.m）</p>

<p>AFN官方推荐的使用方法是，为一系列相关的请求定义一个HTTPClient，共用一个BaseURL。每次请求把URL中除BaseURL的Path部分做为参数传给HTTPClient的静态方法，并注册一个Block用于回调。</p>

<p><a href="http://www.flickr.com/photos/105999540@N03/10382705703/" title="2013-10-20-6 by EricShj, on Flickr"><img src="http://farm4.staticflickr.com/3724/10382705703_90269d2bbe.jpg" width="464" height="143" alt="2013-10-20-6"></a></p>

<p>图2，ASI示例代码，发起异步请求（出自：ASIHTTPRequestTests.m）</p>

<p>ASI推荐使用方法就非常传统，每一个请求都由构造方法初始化一个（共享）实例，通过这个实例配置参数并发起请求。ASI最初使用delegate模式回调，在iOS SDK支持Block之后也提供了注册Block的实例方法。</p>

<p>以上引用的两段代码都出自各自项目的示例工程。对比两段代码可以很清楚的看出，同样是发起一个最普通的异步请求，使用AFN只需要调用一个静态方法，但代码可读性较差；而ASI的示例看起来更清晰，但需要调用多个实例方法才能完成一次请求。AFN的设计更加工程化，或者说对使用者更友好，而ASI的设计更经典，典型的OOP。
除了初级用法上的区别，二者的高级功能和对扩展的支持也颇有不同。</p>

<h3>2、高级功能</h3>

<p>AFN只封装了一些常用功能，满足基本需求，而直接忽略了很多扩展功能。例如：AFN默认没有封装同步请求，如果开发者需要使用同步请求，则需要重写getPath:parameters:success:failure方法，对AFHTTPRequestOperation进行同步处理；而ASI则是直接通过调用一个startSynchronous方法。
此外AFN针对JSON、XML、PList和Image四种数据结构封装了各自处理器，开发者可以把处理器注册到操作队列中，直接在回调方法中获得格式化以后的数据。在示例工程中就使用了JSON处理器：把AFJSONRequestOperation注册到操作队列里。</p>

<p><a href="http://www.flickr.com/photos/105999540@N03/10382500994/" title="2013-10-20-7 by EricShj, on Flickr"><img src="http://farm8.staticflickr.com/7419/10382500994_16a83e90d4.jpg" width="464" height="192" alt="2013-10-20-7"></a></p>

<p>图3，AFN示例代码，初始化自定义的HTTPClient（出自：AFAppDotNetAPIClient.m）</p>

<p>而ASI在这方面显得更原始，没有针对任何数据类型做特别封装，只是预留了各种接口和工具供开发者自行扩展。ASI比AFN提供更多扩展功能还有一个原因，它把许多内部用到的功能也抽象成类和方法。例如：
ASIHTTPRequestDataCompressor和ASIHTTPRequestDataDecompressor两个类，只用于压缩本地文件，构造POST Body和解压缩返回数据，但这两个类仍然被设计为独立功能，提供了对多种数据结构进行压缩和解压缩的方法。</p>

<p>对比二者的高级功能和对扩展的支持后，可以看出AFN把初级功能（或者叫常用功能）做到了90分。调用方式够简单，处理器够丰富，使用者用起来可以算是轻松加愉快。但它放弃了对高级功能的支持，要满足较复杂的需求，就要大费周折了，在这方面最多只有40分。而ASI显然不满足于做好初级功能，但为了提供更丰富的可扩展接口，导致初级功能用起来也要花上一些力气。虽然ASI单独提供了支持Amazon S3和Rackspace Cloud Files的控件，但对于生在红旗下的我朝开发者来说基本没用，所以在初级功能的支持上ASI能得个70分，牺牲了初级功能的易用性，换来的是良好的扩展性，在高级功能的使用上远远好于AFN，也能得个70分。</p>

<p>从使用角度对比过后，基本上对这两个项目有一个整体上的认识，再深入下去看看二者的性能如何。</p>

<h3>3、性能对比</h3>

<p>我分别用AFN和ASI进行了测试，测试环境如下：iPhone5，联通3G信号全满，室内静止状态，请求国内双线机房独立服务器的静态文件，1~20K共20个文件，每个文件请求20次，记录从创建请求到完全下载文件的耗时，结果如下：</p>

<p><a href="http://www.flickr.com/photos/105999540@N03/10382705653/" title="2013-10-20-8 by EricShj, on Flickr"><img src="http://farm4.staticflickr.com/3715/10382705653_fa58c22d18.jpg" width="464" height="146" alt="2013-10-20-8"></a></p>

<p>图4，AFN连续访问1 ~ 20K文件耗时</p>

<p><a href="http://www.flickr.com/photos/105999540@N03/10382545196/" title="2013-10-20-9 by EricShj, on Flickr"><img src="http://farm8.staticflickr.com/7296/10382545196_4c6f799013.jpg" width="464" height="146" alt="2013-10-20-9"></a></p>

<p>图5，ASI连续访问1 ~ 20K文件耗时</p>

<p>图4是AFN的记录图，绿色为20次请求中耗时最久的一次，蓝色为耗时最短的一次，黄色为去除最大值和最小值的18次平均值。从这个图可以看出，AFN最开始创建对象耗时近2.5秒，随后稳定下来，在3K、7K、15K和20K时出现了抖动。图5是ASI做相同测试的结果，首次创建对象近2.25秒，略优于AFN，同样在5K、11K、13K、14K和16K发生了一些抖动，但抖动幅度似乎小于AFN，可见稳定性更好一些。
下边是把二者的测试结果放在一起的对比图，可以更直观的比较二者的区别。</p>

<p><a href="http://www.flickr.com/photos/105999540@N03/10382500714/" title="2013-10-20-10 by EricShj, on Flickr"><img src="http://farm8.staticflickr.com/7317/10382500714_0725ae4480.jpg" width="464" height="147" alt="2013-10-20-10"></a></p>

<p>图6，ASI和AFN耗时最大值对比</p>

<p>图6的最大值对比可以更明显的看出二者的抖动对比，ASI略好一些。</p>

<p><a href="http://www.flickr.com/photos/105999540@N03/10382525995/" title="2013-10-20-11 by EricShj, on Flickr"><img src="http://farm6.staticflickr.com/5476/10382525995_1a6cd98274.jpg" width="464" height="146" alt="2013-10-20-11"></a></p>

<p>图7，ASI和AFN耗时最小值对比</p>

<p>图7的最小值对比可以看出，在每一个大小的测试中ASI的最佳性能似乎都要优于AFN。</p>

<p><a href="http://www.flickr.com/photos/105999540@N03/10382705193/" title="2013-10-20-12 by EricShj, on Flickr"><img src="http://farm3.staticflickr.com/2880/10382705193_25f55ba5b3.jpg" width="464" height="147" alt="2013-10-20-12"></a></p>

<p>图8，ASI和AFN耗时平均值对比</p>

<p>图8是耗时平均值的对比，更能够说明问题。文件小于12K的测试中ASI的性能优势并没有非常明显，超过12K以后，ASI优势开始明显起来，每一次请求都要比AFN节约20% ~ 30%，近0.1秒。同时从这张图上还可以看出，随着下载文件变大，请求耗时并不是线形增长的，这是由于一次请求大部分时间都消耗在建立连接上，而真正接收数据只占用了极少时间，这个问题不在本篇文章的讨论范围，所以不多说，有兴趣的读者可以<a href="http://segmentfault.com/t/ios">移步</a>进一步讨论。</p>

<h3>4、原理分析</h3>

<p>ASI的性能似乎全面优于AFN，那下边从二者的实现原理上看一下到底是什么原因造成这种差距。ASI基于CFNetwork框架开发，而AFN基于NSURL，底层的区别是导致二者性能差距的重要原因之一。</p>

<p><a href="http://www.flickr.com/photos/105999540@N03/10382544986/" title="2013-10-20-13 by EricShj, on Flickr"><img src="http://farm8.staticflickr.com/7325/10382544986_92a3d7bf99.jpg" width="464" height="289" alt="2013-10-20-13"></a></p>

<p>图9，ASI和AFN以及底层框架的关系</p>

<p>我们知道所有网络通信的基础是Socket，一个Socket与另一个连接并传送数据。BSD Socket是一类最常见的Socket抽象接口。</p>

<p>Core Foundation框架中的CFSocket就是基于BSD Socket开发的。它几乎涵盖了BSD Socket的全部功能，更重要的是把Socket整合到事件的处理循环中。Core Founda-tion中较高层的CFStream是基于CFSocket开发的读写流支持。</p>

<p>CFNetwork是基于Core Foundation中CFStream的一个底层高性能网络框架，它由提供基础服务的CFSocketStream，支持HTTP协议的CFHTTP，基于CFHTTP用于身份认证的CFHTTPAuthentication和支持FTP协议的CFFTP组成。</p>

<p>正如图9所示，ASI是基于CFHTTP开发的一个组件；而AFN的基础——NSURL，也是基于CFNetwork开发的。也就是说ASI相比AFN更加底层，这就从一定程度上造成二者的性能差距。
另一个方面，虽然二者都使用NSOperation和NSOperationQueue实现但底层的区别也导致实现方式上有非常大的差别。</p>

<p>ASI的直接操作对象ASIHTTPRequest是NSOperation的子类，实现了NSCopying协议。在initialize和initWithURL:方法中初始化相关属性并配置一系列请求相关参数默认值。此外，ASIHTTPRequest还提供了一系列的实例方法用来配置请求对象。在异步请求的处理上，ASIHTTPRequest对象初始化结束后，在startAsynchronous方法中把对象加入共享操作队列。此后，包括创建CFHTTPMessageRef，也就是处理网络请求的主要对象（事实上是一个指向__CFHTTPMessage结构的指针），在内的所有操作都在ASIHTTPRequest对象所属的子线程中完成。</p>

<p>AFN的直接操作对象AFHTTPClient不同于ASI，是一个实现了NSCoding和NSCopying协议的NSObject子类。AFHTTPClient是一个封装了一系列操作方法的“工具类”，处理请求的操作类是一系列单独的，基于NSOperation封装的，AFURLConnectionOperation的子类。AFN的示例代码中通过一个静态方法，使用dispatch_once()的方式创建AFHTTPClient的共享实例，这也是官方建议的使用方法。在创建AFHTTPClient的初始化方法中，创建了OperationQueue并设置一系列参数默认值。在getPath:parameters:success:failure方法中创建NSURLRequest，以NSURLRequest对象实例作为参数，创建一个NSOperation，并加入在初始化发方中创建的NSOperationQueue。以上操作都是在主线程中完成的。在NSOperation的start方法中，以此前创建的NSURLRequest对象为参数创建NSURLConnection并开启连结。</p>

<p>在异步回调的处理上二者也有区别，ASI采取的是CFHTTP请求完成，直接回调ASIHTTPRequest的实例方法，通过储存的实例对象记录的信息完成Delegate模式或Block模式的回调。而AFN则直接使用了NSOperation的completionBlock属性。</p>

<p>这些实现方式也可以看出，ASI显得更加底层，并没有过多使用Cocoa框架中已经封装的API，而AFN则更加实用主义，逻辑简单清晰，大量使用了框架API。这一点也是造成二者性能差别的原因之一。</p>

<h3>总结</h3>

<p>通过以上的对比，基本可以这样评价：AFN适合逻辑简单的应用，或者更适合开发资源尚不丰富的团队，因为AFN的易用性要比ASI好很多，而这样的应用（或团队）对底层网络控件的定制化要求也非常低。ASI更适合已经发展了一段时间的应用，或者开发资源相对丰富的团队，因为往往这些团队（或他们的应用）已经积累了一定的经验，无论是产品上还是技术上的。需求复杂度就是在这种时候高起来，而且底层订制的需求也越来越多，此时AFN就很难满足需求，需要牺牲一定的易用性，使用ASI作为网络底层控件。SegmentFault开源客户端现在被设计为一款简单的阅读客户端，几乎没有定制要求，因此，目前我选择了AFN作为网络控件。
以上对ASI和AFN两款最常用的iOS底层网络控件做了初步的介绍，要更深入的了解两款控件，还需要大家继续研究各自的源码。大家遇到任何关于iOS的技术问题都可以在<a href="http://segmentfault.com/t/ios">这里</a>进行讨论。另外大家也可以持续关注SegmentFault的开源客户端，与更多的开发者共同探讨iOS开发技术。</p>

<p>作者简介</p>

<p>高嘉峻（微博：@gaosboy），SegmentFault.com联合创始人，杭州iOS开发者沙龙发起人，资深iOS开发者。</p>

<p><a href="http://www.infoq.com/cn/articles/afn_vs_asi">http://www.infoq.com/cn/articles/afn_vs_asi</a></p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Objective-C的新特性(Object Literals等)]]></title>
    <link href="http://saick.net/blog/2013/10/20/objective-cde-xin-te-xing-object-literals/"/>
    <updated>2013-10-20T22:28:00+08:00</updated>
    <id>http://saick.net/blog/2013/10/20/objective-cde-xin-te-xing-object-literals</id>
    <content type="html"><![CDATA[<p>转自：<a href="http://blog.devtang.com/blog/2012/08/05/use-modern-objective-c/">http://blog.devtang.com/blog/2012/08/05/use-modern-objective-c/</a> (Posted by 唐巧 Aug 5th, 2012  iOS)</p>

<p>苹果在今年的WWDC2012大会上介绍了大量Objective-C的新特性，能够帮助iOS程序员更加高效地编写代码。在不久前更新的XCode4.4版本中，这些新特性已经可以使用了。让我们看看这些新特性有哪些：</p>

<h3>Object Literals</h3>

<p>这个是我认为最赞的一个改进。Object Literals允许你方便地定义数字、数组和字典对象。这个功能类似于java5提供的auto boxing功能。这虽然是一个语法糖，但我认为对提高写代码效率帮助很大。让我们先来看看以前定义数字、数组和字典对象的方法：</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>123NSNumber * number = [NSNumber numberWithInt:1];
</span><span class='line'>NSArray * array = [NSArray arrayWithObjects:@"one", @"two", nil];
</span><span class='line'>NSDictionary * dict = [NSDictionary dictionaryWithObjectsAndKeys:@"value1", @"key1", @"value2", @"key2", nil];</span></code></pre></td></tr></table></div></figure>


<p>是不是很恶心？现在以上代码可以简化成以下形式，注意到没有，不用再在参数的最后加恶心的nil了，字典的key和value也不再是倒着先写value,再写key了：</p>

<!-- more -->




<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>NSNumber * number = @1;
</span><span class='line'>NSArray * array = @[@"one", @"two"];
</span><span class='line'>NSDictionary * dict = @{@"key1":@"value1", @"key2":@"value2"};</span></code></pre></td></tr></table></div></figure>


<p>更多的示例如下：</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
<span class='line-number'>11</span>
<span class='line-number'>12</span>
<span class='line-number'>13</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>// 整数  
</span><span class='line'>NSNumber *fortyTwo = @42;             // 等价于 [NSNumber numberWithInt:42]  NSNumber *fortyTwoUnsigned = @42U;    // 等价于 [NSNumber numberWithUnsignedInt:42U]  NSNumber *fortyTwoLong = @42L;        // 等价于 [NSNumber numberWithLong:42L]  NSNumber *fortyTwoLongLong = @42LL;   // 等价于 [NSNumber numberWithLongLong:42LL]  
</span><span class='line'>
</span><span class='line'>// 浮点数  
</span><span class='line'>NSNumber *piFloat = @3.141592654F;    // 等价于 [NSNumber numberWithFloat:3.141592654F]  
</span><span class='line'>NSNumber *piDouble = @3.1415926535;   // 等价于 [NSNumber numberWithDouble:3.1415926535]  
</span><span class='line'>
</span><span class='line'>// 布尔值  
</span><span class='line'>NSNumber *yesNumber = @YES;           // 等价于 [NSNumber numberWithBool:YES]  NSNumber *noNumber = @NO;             // 等价于 [NSNumber numberWithBool:NO]  
</span><span class='line'>
</span><span class='line'>// 空数组  
</span><span class='line'>
</span><span class='line'>NSArray * array = @[];                // 等价于 [NSArray array]  // 空的字典  NSDictionary * dict = @{};            // 等价于 [NSDictionary dictionary]</span></code></pre></td></tr></table></div></figure>


<p>怎么样？是不是简单多了？而且，为了方便你的旧代码迁移到新的写法，xcode专门还提供了转换工具，在xcode4.4中，选择 Edit &ndash;> Refactor &ndash;> Convert to Modern Objective-C Syntax即可。</p>

<h3>局部的函数调用不用前向申明</h3>

<p>这虽然是一个挺小的改进，但是很贴心。假如我们在一个源文件中有2个函数：分别名为foo 和 bar，其中foo的定义在bar前面。那如果在foo函数内部直接调用bar，编译器会报警告说找不到函数bar。
而现在，我们可以随意地在源文件中放置函数bar的位置。编译器在找不到bar时，会再源码后面找，如果找到了bar，就不会报错了。</p>

<h3>带有类型的enum</h3>

<p>现在我们可以定义enum是无符号整数还是整数，这样编译器会更加智能的做类型检查。如下所示：</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>typedef enum TableViewCellType : NSInteger {    
</span><span class='line'>TableViewCellTypeQueue,    
</span><span class='line'>TableViewCellTypeNewFans,    
</span><span class='line'>TableViewCellTypeUserInfo,    
</span><span class='line'>TableViewCellTypeOrganization,    
</span><span class='line'>TableViewCellTypeFeedback,    
</span><span class='line'>TableViewCellTypeRateApp,    
</span><span class='line'>TableViewCellTypeRecommendation,    
</span><span class='line'>TableViewCellTypeLogout}TableViewCellType;</span></code></pre></td></tr></table></div></figure>


<h3>默认生成@synthesize代码</h3>

<p>以前写完一个诸如 @property (nonatomic, strong) NSString * username; 变量定义后，马上得转到 .m文件中去增加相应的 @synthesize username = _username; 代码。</p>

<p>现在，编辑器发现你没有写 @synthesize时，会自动帮你加上这一行。这同时在另一方面，起到了鼓励大家使用以下划线开头的变量名作为成员变量名的作用。</p>

<p>当然，为了向下兼容，如果你的程序里面已经有了 @property 变量对应的 @synthesize 代码时，编辑器就不会自动帮你增加这个代码了。
另外有2种特殊情况下，即使你没有写 @synthesize ，编辑器也不会自动帮你加上，这2种情况是：</p>

<ul>
<li>你同时提供了该property的setter 和 getter方法。</li>
<li>你的这个property是 readonly 的。</li>
</ul>


<h3>遍历元素</h3>

<p>你是如何遍历数组的元素的？通常我们有2种做法，一种是用 for in，另一种是用一个变量来循环数组下标。如下：</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>// 12345678    NSArray * lines = ...    
</span><span class='line'>for (NSString * line in lines) {
</span><span class='line'>       // ...    
</span><span class='line'>}
</span><span class='line'>for (int i = 0; i &lt; lines.count; ++i) {        
</span><span class='line'>  NSString * s = [lines objectAtIndex:i];        
</span><span class='line'>  ...    
</span><span class='line'>}</span></code></pre></td></tr></table></div></figure>


<p>如果是字典，遍历的代码就要稍微复杂一点了：</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>NSDictionary * dict = …    NSArray * keys = [dict allKeys];
</span><span class='line'>for (NSString * key in keys) {        
</span><span class='line'>    NSString * value = [dict objectForKey:key];    
</span><span class='line'>}</span></code></pre></td></tr></table></div></figure>


<p>现在，xcode对于iOS4.0以上的系统，支持用block来遍历元素了。用block来遍历字典可以简化代码的编写，建议大家都使用上这个新特性。</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>[lines enumerateObjectsUsingBlock:^(NSString * obj, NSUInteger idx, BOOL *stop) {}];[_urlArguments enumerateKeysAndObjectsUsingBlock:^(id key, id obj, BOOL *stop) {}];</span></code></pre></td></tr></table></div></figure>


<h3>Subscripting Methods</h3>

<p>这个新特性在WWDC2012的视频中提到了，但是在XCode4.4中没有实现（在XCode4.5中实现了）。也是一个很体贴的语法糖，它允许你用中括号来代替原本的方法来获取和设置数组元素。</p>

<p>简单来说，以前的 [array objectAtIndex:idx] 和 [array replaceObjectAtIndex:idx withObject:obj]，可以直接写作 array[idx] 和 array[idx] = obj了。其实这个特性在很多高级语言中都实现了，只是Objective-C生于80年代，一直没改进这个。</p>

<p>以下是一些示例代码：</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
<span class='line-number'>11</span>
<span class='line-number'>12</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>NSArray * array = @[ @"111", @"222", @"333"];
</span><span class='line'>for (int i = 0; i &lt; 3; ++i) {
</span><span class='line'>    NSLog(@"array[i] = %@", array[i]);
</span><span class='line'>}
</span><span class='line'>NSMutableDictionary * dict =[@{  @1: @"value1", @2: @"value2",                                 @3: @"value3" } mutableCopy];
</span><span class='line'>for (int i = 0; i &lt; 3; ++i) {
</span><span class='line'>    NSLog(@"dict[%d] = %@", i, dict[@(i+1)]);
</span><span class='line'>    dict[@(i+1)] = [NSString stringWithFormat:@"new %@", dict[@(i+1)]];}
</span><span class='line'>    [dict enumerateKeysAndObjectsUsingBlock:^(id key, id obj, BOOL *stop{
</span><span class='line'>          NSLog(@"dict[%@] = %@", key, dict[key]);
</span><span class='line'>    }];
</span><span class='line'>}</span></code></pre></td></tr></table></div></figure>


<p>这个改进同样对NSDictionary有效。甚至，你也可以给你自己的类提供中括号操作符对应的方法。具体做法是实现如下两个方法：</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>- (id)objectAtIndexedSubscript:(NSUInterger)idx;- (void)setObject:(id)value atIndexedSubscript:(NSUInteger)idx;</span></code></pre></td></tr></table></div></figure>


<h3>Tips</h3>

<p>上面提到了不用写 @synthesize 了，那原本写的那么多 @synthesize 怎么办呢？作为有代码洁癖的我很想把它们删掉，但怎么删呢？一个文件一个文件打开，然后行一行删掉吗？放心，苹果已经帮我们想了解决方案。在WWDC2012 Session 400 Developer Tools Kickoff 中，苹果介绍了具体做法。步骤如下：</p>

<ul>
<li>首先使用区域查找，因为一般项目都会依赖第三方的开源库，我们可不想更改别人的库，所以我们只查找我们库中的文件，如下图所示：</li>
</ul>


<p><a href="http://www.flickr.com/photos/105999540@N03/10382148323/" title="2013-10-20-1 by EricShj, on Flickr"><img src="http://farm4.staticflickr.com/3803/10382148323_3e5d2aabbc.jpg" width="317" height="449" alt="2013-10-20-1"></a></p>

<ul>
<li>接着我们用正则匹配，找到以 @synthesize开头，后面接着是 var = _var; 格式的行。插入正则表达式很简单，直接点击查找输入框左边的放大镜，选择“insert pattern”，苹果就会把常见的正则表达式都列出来，你直接选择就可以了，非常方便。如下图所示：</li>
</ul>


<p><a href="http://www.flickr.com/photos/105999540@N03/10382148463/" title="2013-10-20-2 by EricShj, on Flickr"><img src="http://farm8.staticflickr.com/7415/10382148463_a1fe6d797a.jpg" width="441" height="181" alt="2013-10-20-2"></a></p>

<p>在插入好合适的正则表达式后，我们按回车，就可以搜索到结果。
<a href="http://www.flickr.com/photos/105999540@N03/10382148643/" title="2013-10-20-3 by EricShj, on Flickr"><img src="http://farm4.staticflickr.com/3724/10382148643_1604c7809b.jpg" width="296" height="315" alt="2013-10-20-3"></a></p>

<ul>
<li>我们点击搜索界面的preview按钮，查看替换效果，可以看到，对于我们测试代码，XCode生成的预览图已经正确地当对应代码删掉了。然后我们就可以点击替换，去掉所有的 @synthesize 代码了。</li>
</ul>


<p><a href="http://www.flickr.com/photos/105999540@N03/10382148923/" title="2013-10-20-4 by EricShj, on Flickr"><img src="http://farm4.staticflickr.com/3769/10382148923_5836e42c21.jpg" width="500" height="97" alt="2013-10-20-4"></a></p>

<p>在下载完XCode4.4后，我就把我们的工程代码都转换成了新特性的语法。在转换后，我发现原本25000行的代码少了将近1000行。心里还是很开心的，因为又可以少写一些体力活类型的代码了。
还是那句话，希望这些新特性能够让大家玩得开心。
参考资料</p>

<ul>
<li> LLVM官方网站比较全面地介绍了 Object Literal： <a href="http://clang.llvm.org/docs/ObjectiveCLiterals.html">http://clang.llvm.org/docs/ObjectiveCLiterals.html</a></li>
<li> WWDC2012 Session 400 Developer Tools Kickoff</li>
<li> WWDC2012 Session 405 Modern Objective-C</li>
<li> WWDC2012 Session 413 Migrating to Modern Objective-C</li>
</ul>

]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[iOS ARC 兼容处理]]></title>
    <link href="http://saick.net/blog/2013/10/19/ios-arc-jian-rong-chu-li/"/>
    <updated>2013-10-19T01:56:00+08:00</updated>
    <id>http://saick.net/blog/2013/10/19/ios-arc-jian-rong-chu-li</id>
    <content type="html"><![CDATA[<p>From:宋红日（转自：<a href="http://blog.sina.com.cn/s/blog_9792a85b01018v83.html%EF%BC%89">http://blog.sina.com.cn/s/blog_9792a85b01018v83.html%EF%BC%89</a></p>

<p>我们经常在引用第三方控件或者阅读一个开源的代码的时候，与自己的xcode 的开发环境不一样，导致编译不过的问题，还得改代码，带来了一定的工作量。其实有一下方法做到兼容处理。统一用下面定义的宏就可以。
尤其当你决定做一个通用的控件 或 模块的时候。</p>

<!-- more -->




<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>// ARC conditions
</span><span class='line'>#if !__has_feature(objc_arc)
</span><span class='line'>#define Release(obj) [obj release]
</span><span class='line'>#define Retain(obj) [obj retain]
</span><span class='line'>#else 
</span><span class='line'>#define Release(obj)
</span><span class='line'>#define Retain(obj) obj
</span><span class='line'>#endif</span></code></pre></td></tr></table></div></figure>


<p>另外，如果是ARC工程，某些文件不支持ARC的话，可以在Target->Build Phases->Complie sources 中对某个文件加入Complier Flags “-fno-objc-arc”</p>

<p>如下图：</p>

<p><a href="http://www.flickr.com/photos/105999540@N03/10374769035/" title="2013-10-19-1 by EricShj, on Flickr"><img src="http://farm8.staticflickr.com/7294/10374769035_c11c167c38_z.jpg" width="640" height="237" alt="2013-10-19-1"></a></p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Git fetch和git pull的区别]]></title>
    <link href="http://saick.net/blog/2013/10/19/git-fetchhe-git-pullde-qu-bie/"/>
    <updated>2013-10-19T01:47:00+08:00</updated>
    <id>http://saick.net/blog/2013/10/19/git-fetchhe-git-pullde-qu-bie</id>
    <content type="html"><![CDATA[<p>原文： <a href="http://www.tech126.com/git-fetch-pull/">http://www.tech126.com/git-fetch-pull/</a></p>

<h3>Git中从远程的分支获取最新的版本到本地有这样2个命令：</h3>

<h4>1. git fetch：相当于是从远程获取最新版本到本地，不会自动merge</h4>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>git fetch origin master
</span><span class='line'>git log -p master..origin/master
</span><span class='line'>git merge origin/master</span></code></pre></td></tr></table></div></figure>




<!-- more -->


<p>以上命令的含义：<br/>
首先从远程的origin的master主分支下载最新的版本到origin/master分支上,然后比较本地的master分支和origin/master分支的差别,最后进行合并.</p>

<p>上述过程其实可以用以下更清晰的方式来进行：</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>git fetch origin master:tmp
</span><span class='line'>git diff tmp 
</span><span class='line'>git merge tmp</span></code></pre></td></tr></table></div></figure>


<p>从远程获取最新的版本到本地的test分支上,之后再进行比较合并</p>

<h4>2. git pull：相当于是从远程获取最新版本并merge到本地</h4>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>git pull origin master</span></code></pre></td></tr></table></div></figure>


<p>上述命令其实相当于git fetch 和 git merge</p>

<p>在实际使用中，git fetch更安全一些</p>

<p>因为在merge前，我们可以查看更新情况，然后再决定是否合并</p>

<p>EOF</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[MAC 系统的启动过程和系统启动时运行shell 脚本]]></title>
    <link href="http://saick.net/blog/2013/10/19/mac-xi-tong-de-qi-dong-guo-cheng-he-xi-tong-qi-dong-shi-yun-xing-shell-jiao-ben/"/>
    <updated>2013-10-19T01:34:00+08:00</updated>
    <id>http://saick.net/blog/2013/10/19/mac-xi-tong-de-qi-dong-guo-cheng-he-xi-tong-qi-dong-shi-yun-xing-shell-jiao-ben</id>
    <content type="html"><![CDATA[<h4>1 Mac 开机启动脚本或应用（系统启动时运行shell 脚本）</h4>

<p>1）如果想启动的是一个Mac 的应用程序（即xxx.app）则可以通过图形化界面来设置：</p>

<pre><code>system prefernce--&gt;Accounts--&gt;LogItems--&gt;add
</code></pre>

<p>2）把想要启动的shell 或应用放到/Labrary/Startupitems/ 目录中。</p>

<p>3）<em>创建/etc/rc.local 文件，把脚本写在文件中</em>。</p>

<!-- more -->


<p>4）如果只启动shell 程序，还有一种方式，大体流程是这样的。</p>

<pre><code>A) 把Terminate 设置为开机启动。这样当系统启动时，可以自动运行shell。
B) 在用户目录下创建或修改".profile"。当shell 启动时，先运行".profile" 文件
C) 在".profile" 中调用想要执行的shell 脚本
</code></pre>

<p>5)  应用Mac 的launchd，可以参见：<a href="http://cb.esast.com/cb/wiki/10020">http://cb.esast.com/cb/wiki/10020</a></p>

<p>苹果的安全检查：用上面说过的2，3 方法时，必须设置文件的用户id 和组id，还有文件的运行权限。具体方法，下文有述。</p>

<p>当设置完成后，可以在终端上用SystemStarter 来调试配置的信息
命令为：<code>SystemStarter -n -D</code>
根据提示的信息可以查看配置的问题。</p>

<h4>2 解决“Insecure Startup Item disabled.错误”</h4>

<p>可以把想要启动的shell 放到/Labrary/Startupitems/ 目录中。
必须改变文件的用户id 和组id 才可以，并且权限为755</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>sudo chown -R root:wheel /Library/StartupItems/xxx
</span><span class='line'>sudo chmod -R 755 /Library/StartupItems/xxx</span></code></pre></td></tr></table></div></figure>


<p>(如果运行的是shell 文件，则命令中不用加 -R 选项)</p>

<p>注意：环境变量问题。</p>

<p>当然一定要参考苹果的开发者文档：
[Introduction to System Startup Programming Topics]
(<a href="http://developer.apple.com/mac/library/documentation/MacOSX/Conceptual/BPSystemStartup/BPSystemStartup.html#//apple_ref/doc/uid/10000172-SW1">http://developer.apple.com/mac/library/documentation/MacOSX/Conceptual/BPSystemStartup/BPSystemStartup.html#//apple_ref/doc/uid/10000172-SW1</a>)</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[iOS Cookie使用]]></title>
    <link href="http://saick.net/blog/2013/10/19/ios-cookieshi-yong/"/>
    <updated>2013-10-19T01:08:00+08:00</updated>
    <id>http://saick.net/blog/2013/10/19/ios-cookieshi-yong</id>
    <content type="html"><![CDATA[<p>转自：<a href="http://geeklu.com/2013/04/ios-cookie/">http://geeklu.com/2013/04/ios-cookie/</a></p>

<p>关于Cookie的标准和原理这里就不细说了，这里只说说在iOS平台下如何进行Cookie相关的编程。
和Mac上不同，在iOS平台上各个App都有自己的Cookie，App之间不共享Cookie。
一个Cookie对应一个NSHTTPCookie实体，并通过NSHTTPCookieStorage进行管理。
那些需要持久化的Cookie是存放在 ~/Library/Cookies/Cookies.binarycookies 文件中的，二进制格式。</p>

<p>Cookie生成的有两个途径，一个是访问一个网页，这个网页返回的HTTP Header中有Set-Cookie指令进行Cookie的设置，这里Cookie的本地处理其实是由WebKit进行的；还有一种途径就是客户端通过代码手动设置Cookie。</p>

<!-- more -->




<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>NSMutableDictionary *cookieProperties = [NSMutableDictionary dictionary];[cookieProperties setObject:@"name" forKey:NSHTTPCookieName];
</span><span class='line'>[cookieProperties setObject:@"value" forKey:NSHTTPCookieValue];
</span><span class='line'>[cookieProperties setObject:@"www.taobao.com" forKey:NSHTTPCookieDomain];[cookieProperties setObject:@"/" forKey:NSHTTPCookiePath];
</span><span class='line'>[cookieProperties setObject:@"0" forKey:NSHTTPCookieVersion];
</span><span class='line'>[cookieProperties setObject:@"30000" forKey:NSHTTPCookieMaximumAge];
</span><span class='line'>NSHTTPCookie *cookie = [NSHTTPCookie cookieWithProperties:cookieProperties];
</span><span class='line'>[[NSHTTPCookieStorage sharedHTTPCookieStorage] setCookie:cookie];
</span><span class='line'>//删除cookie的方法为deleteCookie:</span></code></pre></td></tr></table></div></figure>


<p>在通过setCookie:进行设置cookie的时候，会覆盖name,domain,path都相同的cookie的。
至于cookie会不会持久化到cookie文件中主要看这个cookie的生命周期，和Max-Age或者Expires有关。</p>

<p>不过NSHTTPCookieStorage存在一个问题，setCookie或者deleteCookie后并不会立即进行持久化，而是有几秒的延迟。如果在持久化之前App接收到SIGKILL信号，App退出，那么会导致cookie相关操作的丢失。在模拟器调试的过程中，XCode重启App的时发给App的就是SIGKILL，不过真正的生产环境中很少有这种情况。
但是有时候为了可靠性，我们还是会将cookie信息保存一份到User Defaults，需要用的时候load进来。关于cookie操作丢失的详情可以查看这里<a href="http://openradar.appspot.com/radar?id=2776403">NSHTTPCookieStorage looses cookies on SIGKILL</a></p>

<p>卢克 / 2013-04-02</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[iOS库添加CocoaPods支持]]></title>
    <link href="http://saick.net/blog/2013/10/17/iosku-tian-jia-cocoapodszhi-chi/"/>
    <updated>2013-10-17T15:30:00+08:00</updated>
    <id>http://saick.net/blog/2013/10/17/iosku-tian-jia-cocoapodszhi-chi</id>
    <content type="html"><![CDATA[<p>现在CocoaPods如此方便（虽然可能也有它的缺点），但是很多开源库，自己写的库并没有对它进行支持，特研究了一下，分享给大家。</p>

<h3>准备好库代码（GitHub上）</h3>

<p>将代码Checkout下来，打开命令行，cd到代码根目录</p>

<h3>创建XXXX.podspec</h3>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>pod spec create XXXX</span></code></pre></td></tr></table></div></figure>




<!-- more -->


<h3>编辑XXXX.podspec</h3>

<p>创建好的文件里有很多指引，这步很简单。 实在不明白，再看看GitHub上别的库的spec文件怎么写的。</p>

<h3>验证合法性</h3>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>pod spec lint XXXX.podspec</span></code></pre></td></tr></table></div></figure>


<p>完成后即可把这个文件提交到<a href="https://github.com/CocoaPods/Specs">CocoaPods specs</a>中。</p>

<p>When you&rsquo;re done you can also fork the <a href="https://github.com/CocoaPods/Specs">CocoaPods specs</a>  GitHub repository and send a pull request. We really love contributions and will help ensure it&rsquo;s perfect!</p>

<h3>详细提交步骤</h3>

<p>From：<a href="http://docs.cocoapods.org/guides/contributing_to_the_master_repo.html">http://docs.cocoapods.org/guides/contributing_to_the_master_repo.html</a></p>

<h3>Contributing to the master repo</h3>

<p>The master repo contains specifications of open-source Objective-C libraries.</p>

<h4>Details</h4>

<ul>
<li> installation path: ~/.cocoapods/master</li>
<li> home: <a href="https://github.com/CocoaPods/Specs">https://github.com/CocoaPods/Specs</a></li>
</ul>


<h4>Contributing</h4>

<p>To ensure a high quality, reliable collection of Pods, the master repo is strict about the acceptable specifications. The CocoaPods linter (see the pod spec lint command) is used to validate specifications, and no errors or warnings are accepted.
The highest priority of the master repo is to guarantee the integrity of existing CocoaPods installations.
In general this means that:</p>

<ul>
<li> A specification cannot be deleted.</li>
<li> Specifications can be updated only if they don’t affect existing installations.</li>
<li><ul>
<li>Broken specifications can be updated.</li>
<li>Subspecs can be added as they are included by the parent specification by default.</li>
</ul>
</li>
<li> Only authoritative version numbers are accepted.</li>
</ul>


<p>CocoaPods uses a versioning scheme known as Semantic Versioning, necessary for cross resolution of dependencies.</p>

<h4>Unversioned libraries</h4>

<p>One of the CocoaPods goals is to promote the discovery of open-source software, for this reason new Pods for libraries which are not versioned are accepted in the master repo. The specifications of those pods should carry the version 0.0.1 under the assumption that, if the author starts versioning, she/he is unlikely to pick 0.0.1. This is the only exception for authoritative version numbers.
If you add an unversioned Pod it is your responsibility to ask the author of the library to tag versions, luckily we have a template for this.
To prevent collisions with possible future versions, unversioned libraries can’t be updated until the author starts to tag them.
If you need to update an unversioned library you can:</p>

<ul>
<li> Ask the author to version the library.</li>
<li> Maintain a fork which is versioned. This fork should be clearly namespaced from the original library according the NAME@USERconvention (e.g. Reachability@irrationalfab). It should also mention in the summary that it is a versioned fork.</li>
<li> Create a podspec and use it in a private repo.</li>
</ul>


<h4>Creating podspecs</h4>

<p>Creating a podspec is very easy as we provide templates full of examples.
You can use the following command:</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>$ pod spec create Bananas</span></code></pre></td></tr></table></div></figure>


<p>If the library is hosted on GitHub you can pass the url so CocoaPods can precompile the template:</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>$ pod spec create https://github.com/Bananas/Bananas</span></code></pre></td></tr></table></div></figure>


<p>A this point you need edit compile the template (a pod specification is a Ruby source file):</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>$ pod spec lint Bananas.podspec --verboseSharing podspecs</span></code></pre></td></tr></table></div></figure>


<h4>Sharing podspecs</h4>

<p>When a podspec lints you can submit it to the master repo.</p>

<h4>Without push access</h4>

<p>You need to fork the master repo on github, then you need to:</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>$ cd ~/.cocoapods/master
</span><span class='line'>$ git checkout -b fork
</span><span class='line'>$ git remote add myfork https://github.com/YOUR_USER_NAME/Specs.git
</span><span class='line'>$ cp ~/Bananas.podspec ~/.cocoapods/master/Bananas/VERSION/
</span><span class='line'>$ git push myfork
</span><span class='line'>$ git checkout master</span></code></pre></td></tr></table></div></figure>


<p>Once you push your changes, you can make a pull request on CocoaPods/Specs.
With push access</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>$ pod push Bananas.podspec</span></code></pre></td></tr></table></div></figure>

]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[iOS应用处理崩溃的几种方法]]></title>
    <link href="http://saick.net/blog/2013/10/16/iosying-yong-chu-li-beng-kui-de-ji-chong-fang-fa/"/>
    <updated>2013-10-16T23:31:00+08:00</updated>
    <id>http://saick.net/blog/2013/10/16/iosying-yong-chu-li-beng-kui-de-ji-chong-fang-fa</id>
    <content type="html"><![CDATA[<p>在开发IOS app的过程中,XCode在遇到程序崩溃时打印的信息一般时比较少的。
在iOS7时，这个情况好像有些一些变化，但不太明确，也不太稳定。</p>

<h3>1.在XCode中使用一个通用断点</h3>

<p>在XCode中打开工程，在左边的工程导航栏中选中断点,点击下放的＋号,选择“Add Exception BreakPoint”。点done即可。</p>

<h3>2.开启NSZombieEnabled等调试选项</h3>

<p>XCode->Product->Scheme->Edit Scheme->Run XXX.app->Arguments
在Environment Variables中增加下面属性并都配置为YES。</p>

<!-- more -->




<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>MallocStackLogging
</span><span class='line'>MallocStackLoggingNoCompact
</span><span class='line'>NSAutoreleaseFreedObjectCheckEnabled
</span><span class='line'>NSDebugEnabled
</span><span class='line'>NSZombieEnabled</span></code></pre></td></tr></table></div></figure>


<p>在实际使用中发现，使用了上述配置之后，如果能在模拟器上运行效果更佳。比如,真机调试时遇到过如下错误：</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>-[CALayer retain]: message sent to deallocated instance 0x1d418a30</span></code></pre></td></tr></table></div></figure>


<p>使用网上很多地方都提到的方法：</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>info malloc-history 0x1d418a30
</span><span class='line'>XCode提示:Undefined info command: "malloc-history".  Try "help info".</span></code></pre></td></tr></table></div></figure>


<p>针对这种情况可以参考:<a href="http://stackoverflow.com/questions/3851565/using-gdb-info-malloc-command-within-xcode-iphone-dev,%E9%87%8C%E9%9D%A2%E5%B0%B1%E8%AF%B4%E6%88%91%E4%BB%AC%E5%BA%94%E8%AF%A5%E5%9C%A8%E6%A8%A1%E6%8B%9F%E5%99%A8%E4%B8%AD%E4%BD%BF%E7%94%A8%E7%B1%BB%E4%BC%BCmalloc-history%E7%9A%84gdb%E8%B0%83%E8%AF%95%E5%8A%9F%E8%83%BD%E3%80%82">http://stackoverflow.com/questions/3851565/using-gdb-info-malloc-command-within-xcode-iphone-dev,%E9%87%8C%E9%9D%A2%E5%B0%B1%E8%AF%B4%E6%88%91%E4%BB%AC%E5%BA%94%E8%AF%A5%E5%9C%A8%E6%A8%A1%E6%8B%9F%E5%99%A8%E4%B8%AD%E4%BD%BF%E7%94%A8%E7%B1%BB%E4%BC%BCmalloc-history%E7%9A%84gdb%E8%B0%83%E8%AF%95%E5%8A%9F%E8%83%BD%E3%80%82</a></p>

<p><strong>其中最主要的还是</strong> <em>NSZombieEnabled</em>, 这个解决EXC_BAD_ACCESS还是很有用的。
具体参考这个：<a href="http://www.cocoachina.com/macdev/objc/2011/0219/2661.html">http://www.cocoachina.com/macdev/objc/2011/0219/2661.html</a></p>

<h3>3.增加异常处理[理论上和&#8221;在XCode中使用一个通用断点&#8221;效果类似]</h3>

<p>写iOS代码的时候,经常会遇到程序崩溃在main函数的入口处并出现类似&#8221;First throw call stack&#8221;这样的错误。为了更好的知道崩溃的原因,我们可以在AppDelegate中定义一个方法, 用于处理异常:</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>void caughtException(NSException *exception) 
</span><span class='line'>{  
</span><span class='line'>  NSLog(@"CRASH: %@", exception);  
</span><span class='line'>  NSLog(@"Stack Trace: %@", [exception callStackSymbols]);  
</span><span class='line'>  // Internal error reporting 
</span><span class='line'>} </span></code></pre></td></tr></table></div></figure>


<p>另外，在打印时，也可以使用GTM，GTMStackTraceFromException(exception)，跟系统的类似。</p>

<p>然后在应用启动时，设置这个方法作为自己的自定义异常回调：</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>- (BOOL)application:(UIApplication *)application didFinishLaunchingWithOptions:(NSDictionary *)launchOptions 
</span><span class='line'>{  
</span><span class='line'>  NSSetUncaughtExceptionHandler(& caughtException); 
</span><span class='line'>} </span></code></pre></td></tr></table></div></figure>


<p>在定义了这个回调之后，崩溃是的控制台信息一般都会一目了然，我们甚至可以看出是那个类的哪一行出问题了。</p>

<h3>4.signal处理，并提示。</h3>

<p>启动信号处理</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>signal(SIGABRT, signalHandler);
</span><span class='line'>signal(SIGILL, signalHandler);
</span><span class='line'>signal(SIGSEGV, signalHandler);
</span><span class='line'>signal(SIGFPE, signalHandler);
</span><span class='line'>signal(SIGBUS, signalHandler);
</span><span class='line'>signal(SIGPIPE, signalHandler);</span></code></pre></td></tr></table></div></figure>


<p>其它相关代码</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
<span class='line-number'>11</span>
<span class='line-number'>12</span>
<span class='line-number'>13</span>
<span class='line-number'>14</span>
<span class='line-number'>15</span>
<span class='line-number'>16</span>
<span class='line-number'>17</span>
<span class='line-number'>18</span>
<span class='line-number'>19</span>
<span class='line-number'>20</span>
<span class='line-number'>21</span>
<span class='line-number'>22</span>
<span class='line-number'>23</span>
<span class='line-number'>24</span>
<span class='line-number'>25</span>
<span class='line-number'>26</span>
<span class='line-number'>27</span>
<span class='line-number'>28</span>
<span class='line-number'>29</span>
<span class='line-number'>30</span>
<span class='line-number'>31</span>
<span class='line-number'>32</span>
<span class='line-number'>33</span>
<span class='line-number'>34</span>
<span class='line-number'>35</span>
<span class='line-number'>36</span>
<span class='line-number'>37</span>
<span class='line-number'>38</span>
<span class='line-number'>39</span>
<span class='line-number'>40</span>
<span class='line-number'>41</span>
<span class='line-number'>42</span>
<span class='line-number'>43</span>
<span class='line-number'>44</span>
<span class='line-number'>45</span>
<span class='line-number'>46</span>
<span class='line-number'>47</span>
<span class='line-number'>48</span>
<span class='line-number'>49</span>
<span class='line-number'>50</span>
<span class='line-number'>51</span>
<span class='line-number'>52</span>
<span class='line-number'>53</span>
<span class='line-number'>54</span>
<span class='line-number'>55</span>
<span class='line-number'>56</span>
<span class='line-number'>57</span>
<span class='line-number'>58</span>
<span class='line-number'>59</span>
<span class='line-number'>60</span>
<span class='line-number'>61</span>
<span class='line-number'>62</span>
<span class='line-number'>63</span>
<span class='line-number'>64</span>
<span class='line-number'>65</span>
<span class='line-number'>66</span>
<span class='line-number'>67</span>
<span class='line-number'>68</span>
<span class='line-number'>69</span>
<span class='line-number'>70</span>
<span class='line-number'>71</span>
<span class='line-number'>72</span>
<span class='line-number'>73</span>
<span class='line-number'>74</span>
<span class='line-number'>75</span>
<span class='line-number'>76</span>
<span class='line-number'>77</span>
<span class='line-number'>78</span>
<span class='line-number'>79</span>
<span class='line-number'>80</span>
<span class='line-number'>81</span>
<span class='line-number'>82</span>
<span class='line-number'>83</span>
<span class='line-number'>84</span>
<span class='line-number'>85</span>
<span class='line-number'>86</span>
<span class='line-number'>87</span>
<span class='line-number'>88</span>
<span class='line-number'>89</span>
<span class='line-number'>90</span>
<span class='line-number'>91</span>
<span class='line-number'>92</span>
<span class='line-number'>93</span>
<span class='line-number'>94</span>
<span class='line-number'>95</span>
<span class='line-number'>96</span>
<span class='line-number'>97</span>
<span class='line-number'>98</span>
<span class='line-number'>99</span>
<span class='line-number'>100</span>
<span class='line-number'>101</span>
<span class='line-number'>102</span>
<span class='line-number'>103</span>
<span class='line-number'>104</span>
<span class='line-number'>105</span>
<span class='line-number'>106</span>
<span class='line-number'>107</span>
<span class='line-number'>108</span>
<span class='line-number'>109</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>#include &lt;libkern/OSAtomic.h>
</span><span class='line'>#include &lt;execinfo.h>
</span><span class='line'>
</span><span class='line'>NSString * const UncaughtExceptionHandlerSignalExceptionName = @"UncaughtExceptionHandlerSignalExceptionName";
</span><span class='line'>NSString * const UncaughtExceptionHandlerSignalKey = @"UncaughtExceptionHandlerSignalKey";
</span><span class='line'>NSString * const UncaughtExceptionHandlerAddressesKey = @"UncaughtExceptionHandlerAddressesKey";
</span><span class='line'>
</span><span class='line'>volatile int32_t UncaughtExceptionCount = 0;
</span><span class='line'>const int32_t UncaughtExceptionMaximum = 10;
</span><span class='line'>const NSInteger UncaughtExceptionHandlerSkipAddressCount = 0;
</span><span class='line'>const NSInteger UncaughtExceptionHandlerReportAddressCount = 100;
</span><span class='line'>
</span><span class='line'>+ (NSArray *)backTrace
</span><span class='line'>{
</span><span class='line'>  void* callstack[1024];
</span><span class='line'>  int frames = backtrace(callstack, 1024);
</span><span class='line'>  char **strs = backtrace_symbols(callstack, frames);
</span><span class='line'>  
</span><span class='line'>  int i;
</span><span class='line'>  NSMutableArray *backtrace = [NSMutableArray arrayWithCapacity:frames];
</span><span class='line'>  for (i = UncaughtExceptionHandlerSkipAddressCount;
</span><span class='line'>       i &lt; UncaughtExceptionHandlerSkipAddressCount + UncaughtExceptionHandlerReportAddressCount;
</span><span class='line'>       i++)
</span><span class='line'>  {
</span><span class='line'>    if (frames &lt;= i)
</span><span class='line'>      break;
</span><span class='line'>    [backtrace addObject:[NSString stringWithUTF8String:strs[i]]];
</span><span class='line'>  }
</span><span class='line'>  
</span><span class='line'>  free(strs);
</span><span class='line'>  
</span><span class='line'>  return backtrace;
</span><span class='line'>}
</span><span class='line'>
</span><span class='line'>- (void)alertView:(UIAlertView *)anAlertView clickedButtonAtIndex:(NSInteger)anIndex
</span><span class='line'>{
</span><span class='line'>  if (anIndex == 0) {
</span><span class='line'>    _dismissed = YES;
</span><span class='line'>  }
</span><span class='line'>}
</span><span class='line'>
</span><span class='line'>- (void)handleException:(NSException *)exception
</span><span class='line'>{
</span><span class='line'>  UIAlertView *alert = [[UIAlertView alloc] initWithTitle:NSLocalizedString(@"Unhandled exception", nil)
</span><span class='line'>                                                  message:[NSString stringWithFormat:NSLocalizedString(@"You can try to continue but the application may be unstable.\n" @"%@\n%@", nil), [exception reason], [[exception userInfo] objectForKey:UncaughtExceptionHandlerAddressesKey]]
</span><span class='line'>                                                 delegate:self
</span><span class='line'>                                        cancelButtonTitle:NSLocalizedString(@"Quit", nil)
</span><span class='line'>                                        otherButtonTitles:NSLocalizedString(@"Continue", nil), nil];
</span><span class='line'>  
</span><span class='line'>  [alert show];
</span><span class='line'>  
</span><span class='line'>  CFRunLoopRef runLoop = CFRunLoopGetCurrent();
</span><span class='line'>  CFArrayRef allModes = CFRunLoopCopyAllModes(runLoop);
</span><span class='line'>  
</span><span class='line'>  while (!_dismissed) {
</span><span class='line'>    for (NSString *mode in (NSArray *)CFBridgingRelease(allModes)) {
</span><span class='line'>      CFRunLoopRunInMode((CFStringRef)CFBridgingRetain(mode), 0.001, false);
</span><span class='line'>    }
</span><span class='line'>  }
</span><span class='line'>  
</span><span class='line'>  CFRelease(allModes);
</span><span class='line'>  
</span><span class='line'>  NSString *log = [NSString stringWithFormat:@"%@\n\n info:\n%@", exception, exception.userInfo];
</span><span class='line'>  [[DebugUtil sharedDebug] LogException:log];
</span><span class='line'>  
</span><span class='line'>  NSSetUncaughtExceptionHandler(NULL);
</span><span class='line'>  signal(SIGABRT, SIG_DFL);
</span><span class='line'>  signal(SIGILL, SIG_DFL);
</span><span class='line'>  signal(SIGSEGV, SIG_DFL);
</span><span class='line'>  signal(SIGFPE, SIG_DFL);
</span><span class='line'>  signal(SIGBUS, SIG_DFL);
</span><span class='line'>  signal(SIGPIPE, SIG_DFL);
</span><span class='line'>  
</span><span class='line'>  if ([[exception name] isEqual:UncaughtExceptionHandlerSignalExceptionName]) {
</span><span class='line'>    kill(getpid(), [[[exception userInfo] objectForKey:UncaughtExceptionHandlerSignalKey] intValue]);
</span><span class='line'>  } else {
</span><span class='line'>    [exception raise];
</span><span class='line'>  }
</span><span class='line'>}
</span><span class='line'>
</span><span class='line'>NSString * getAppInfo()
</span><span class='line'>{
</span><span class='line'>  NSString *appInfo = [NSString stringWithFormat:@"App : %@ %@(%@)\nDevice : %@\nOS Version : %@ %@\nUDID : %@\n",
</span><span class='line'>                       [[NSBundle mainBundle] objectForInfoDictionaryKey:@"CFBundleDisplayName"],
</span><span class='line'>                       [[NSBundle mainBundle] objectForInfoDictionaryKey:@"CFBundleShortVersionString"],
</span><span class='line'>                       [[NSBundle mainBundle] objectForInfoDictionaryKey:@"CFBundleVersion"],
</span><span class='line'>                       [UIDevice currentDevice].model,
</span><span class='line'>                       [UIDevice currentDevice].systemName,
</span><span class='line'>                       [UIDevice currentDevice].systemVersion,
</span><span class='line'>                       /*[UIDevice currentDevice].uniqueIdentifier*/@""];
</span><span class='line'>  return appInfo;
</span><span class='line'>}
</span><span class='line'>
</span><span class='line'>void signalHandler(int signal)
</span><span class='line'>{
</span><span class='line'>  int32_t exceptionCount = OSAtomicIncrement32(&UncaughtExceptionCount);
</span><span class='line'>  
</span><span class='line'>  if (exceptionCount > UncaughtExceptionMaximum) {
</span><span class='line'>    return;
</span><span class='line'>  }
</span><span class='line'>  
</span><span class='line'>  NSMutableDictionary *userInfo = [NSMutableDictionary dictionaryWithObject:[NSNumber numberWithInt:signal] forKey:UncaughtExceptionHandlerSignalKey];
</span><span class='line'>  
</span><span class='line'>  NSArray *callStack = [DebugUtil backTrace];
</span><span class='line'>  
</span><span class='line'>  [userInfo setObject:callStack forKey:UncaughtExceptionHandlerAddressesKey];
</span><span class='line'>  
</span><span class='line'>  [[[DebugUtil alloc] init] performSelectorOnMainThread:@selector(handleException:) withObject: [NSException exceptionWithName:UncaughtExceptionHandlerSignalExceptionName reason:[NSString stringWithFormat: NSLocalizedString(@"Signal %d was raised.\n" @"%@", nil), signal, getAppInfo()] userInfo:userInfo] waitUntilDone:YES];
</span><span class='line'>}</span></code></pre></td></tr></table></div></figure>


<p>第4部分 原文：<a href="http://www.cocoachina.com/newbie/tutorial/2012/0829/4672.html">http://www.cocoachina.com/newbie/tutorial/2012/0829/4672.html</a></p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[在应用中从竖屏模式强制转换为横屏模式 & 状态栏白边问题]]></title>
    <link href="http://saick.net/blog/2013/10/14/zai-ying-yong-zhong-cong-shu-ping-mo-shi-qiang-zhi-zhuan-huan-wei-heng-ping-mo-shi/"/>
    <updated>2013-10-14T16:28:00+08:00</updated>
    <id>http://saick.net/blog/2013/10/14/zai-ying-yong-zhong-cong-shu-ping-mo-shi-qiang-zhi-zhuan-huan-wei-heng-ping-mo-shi</id>
    <content type="html"><![CDATA[<h4>序：状态栏白边问题解决</h4>

<p>在旋转前，先隐藏掉状态栏，再设置相关的Frame。（别犯低级错误即可）</p>

<p>在 iPhone 应用里，有时我们想强行把显示模式从纵屏改为横屏（反之亦然），CocoaChina 会员 “alienblue” 为我们提供了两种思路</p>

<h3>第一种：通过人为的办法改变view.transform的属性。</h3>

<p>具体办法：</p>

<p><code>view.transform</code>一般是View的旋转，拉伸移动等属性，类似<code>view.layer.transform</code>，区别在于<code>view.transform</code>是二维的，也就是使用仿射的办法通常就是带有前缀CGAffineTransform的类（可以到API文档里面搜索这个前缀的所有类），而<code>view.layer.transform</code>可以在3D模式下面的变化，通常使用的都是前缀为CATransform3D的类。</p>

<!-- more -->


<p>   这里要记住一点，当你改变过一个<code>view.transform</code>属性或者<code>view.layer.transform</code>的时候需要恢复默认状态的话，记得先把他们重置可以使用<code>view.transform = CGAffineTransformIdentity</code>，或者<code>view.layer.transform = CATransform3DIdentity</code>，假设你一直不断的改变一个<code>view.transform</code>的属性，而每次改变之前没有重置的话，你会发现后来的改变和你想要的发生变化了，不是你真正想要的结果。</p>

<p>   好了，上面介绍了旋转的属性，接下来就是关键了。官方提供了一个办法就是查看当前电池条的状态<code>UIInterfaceOrientation orientation = [UIApplication sharedApplication].statusBarOrientation;</code>通过这个办法，你可以知道当前屏幕的电池条的显示方向，而且你还可以强制设置他的显示方向，通过设置这个属性就OK了，可以选择是否动画改变电池条方向。有了这两个那我们就可以任意的改变我们想要的显示方式了。</p>

<ul>
<li>1.获取当前电池条的方向</li>
</ul>


<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>UIInterfaceOrientation orientation = [UIApplication sharedApplication].statusBarOrientation</span></code></pre></td></tr></table></div></figure>


<ul>
<li>2.获取当前屏幕的大小</li>
</ul>


<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>CGRect frame = [UIScreen mainScreen].applicationFrame;</span></code></pre></td></tr></table></div></figure>


<ul>
<li>3.设置我们的View的中心点</li>
</ul>


<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>CGPoint center = CGPointMake(frame.origin.x + ceil(frame.size.width/2), frame.origin.y + ceil(frame.size.height/2));</span></code></pre></td></tr></table></div></figure>


<ul>
<li>4.根据当前电池条的方向，获取需要旋转的角度的大小。通常</li>
</ul>


<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>if (orientation == UIInterfaceOrientationLandscapeLeft) {
</span><span class='line'>    return CGAffineTransformMakeRotation(M_PI*1.5);
</span><span class='line'>} else if (orientation == UIInterfaceOrientationLandscapeRight) {
</span><span class='line'>    return CGAffineTransformMakeRotation(M_PI/2);
</span><span class='line'>} else if (orientation == UIInterfaceOrientationPortraitUpsideDown) {
</span><span class='line'>    return CGAffineTransformMakeRotation(-M_PI);
</span><span class='line'>} else {
</span><span class='line'>    return CGAffineTransformIdentity;
</span><span class='line'>}</span></code></pre></td></tr></table></div></figure>


<ul>
<li>5.可以动画的改变我们view的显示方式了</li>
</ul>


<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>[[UIApplication sharedApplication] setStatusBarOrientation:UIDeviceOrientationLandscapeRight animated:YES];
</span><span class='line'>
</span><span class='line'>CGFloat duration = [UIApplication sharedApplication].statusBarOrientationAnimationDuration;（获取当前电池条动画改变的时间）
</span><span class='line'>[UIView beginAnimations:nil context:nil];
</span><span class='line'>[UIView setAnimationDuration:duration];
</span><span class='line'>
</span><span class='line'>//在这里设置view.transform需要匹配的旋转角度的大小就可以了。
</span><span class='line'>[UIView commitAnimations];</span></code></pre></td></tr></table></div></figure>


<h3>第二种：通过setOrientation:的办法强制性的旋转到一个特定的方向。</h3>

<p>   注意：Apple在3.0以后都不支持这个办法了，这个办法已经成为了私有的了，但是要跳过App Stroe的审核，需要一点巧妙的办法。</p>

<p>   不要直接调用<code>[[UIDevice currentDevice] setOrientation: UIInterfaceOrientationLandscapeRight]</code>这样的办法来强制性的横屏，这样导致你的程序是很难通过App Store审核的。但是你可以选择使用performSelector的办法来调用它。具体就几行代码如下：</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
<span class='line-number'>11</span>
<span class='line-number'>12</span>
<span class='line-number'>13</span>
<span class='line-number'>14</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>//强制横屏
</span><span class='line'>    if ([[UIDevice currentDevice] respondsToSelector:@selector(setOrientation:)]) {
</span><span class='line'>        [[UIDevice currentDevice] performSelector:@selector(setOrientation:)
</span><span class='line'>                                       withObject:(id)UIInterfaceOrientationLandscapeRight];
</span><span class='line'>    }
</span><span class='line'>    
</span><span class='line'>    // 更保险的写法 add by Eric
</span><span class='line'>    + (void)changeOrientation:(UIInterfaceOrientation)toOrientation
</span><span class='line'>    {
</span><span class='line'>      if ([[UIDevice currentDevice] respondsToSelector:NSSelectorFromString(@"setOrientation:")]) {
</span><span class='line'>      [[UIDevice currentDevice] performSelector:NSSelectorFromString(@"setOrientation:")
</span><span class='line'>                                   withObject:(id)toOrientation];
</span><span class='line'>      }
</span><span class='line'>}</span></code></pre></td></tr></table></div></figure>


<p>   总结:如果第一种办法可以满足你需要的话，最好使用第一种办法，因为那个上 App Store肯定没问问题，但是第二种的话是需要冒风险的，但是如果你的结构太复杂了，导致使用第一种办法人为很难控制的话，可以尝试简单的使用第二种办法。</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[怎么查看在mac上连接过的wifi密码]]></title>
    <link href="http://saick.net/blog/2013/10/14/zen-yao-cha-kan-zai-macshang-lian-jie-guo-de-wifimi-ma/"/>
    <updated>2013-10-14T16:16:00+08:00</updated>
    <id>http://saick.net/blog/2013/10/14/zen-yao-cha-kan-zai-macshang-lian-jie-guo-de-wifimi-ma</id>
    <content type="html"><![CDATA[<p>Mac上连接过的wifi密码忘记了怎么办？通过本文的几步可以查看在mac上连接过的wifi密码
<strong>其它密码也可使用同样方法获得</strong></p>

<p>方法/步骤</p>

<ul>
<li>1.打开“钥匙串访问”</li>
</ul>


<p><a href="http://www.flickr.com/photos/105999540@N03/10374784546/" title="2013-10-14-10 by EricShj, on Flickr"><img src="http://farm6.staticflickr.com/5505/10374784546_ac4b66a9e5.jpg" width="483" height="83" alt="2013-10-14-10"></a></p>

<!-- more -->


<ul>
<li>2.选中左侧“登陆”、“密码”</li>
</ul>


<p><a href="http://www.flickr.com/photos/105999540@N03/10374769125/" title="2013-10-14-11 by EricShj, on Flickr"><img src="http://farm4.staticflickr.com/3791/10374769125_fb2339510e.jpg" width="500" height="183" alt="2013-10-14-11"></a></p>

<ul>
<li>3.找到要查看密码的wifi</li>
</ul>


<p><a href="http://www.flickr.com/photos/105999540@N03/10374968363/" title="2013-10-14-12 by EricShj, on Flickr"><img src="http://farm4.staticflickr.com/3790/10374968363_675b5904c4.jpg" width="500" height="111" alt="2013-10-14-12"></a></p>

<ul>
<li>4.点击键，选中“显示简介”，或者双击</li>
</ul>


<p><a href="http://www.flickr.com/photos/105999540@N03/10374968173/" title="2013-10-14-13 by EricShj, on Flickr"><img src="http://farm8.staticflickr.com/7431/10374968173_9c2b4957c3.jpg" width="500" height="113" alt="2013-10-14-13"></a></p>

<ul>
<li>5.在弹出的对话框选择“显示密码”，系统会让你输入电脑帐号的密码，然后密码就显示出来了。</li>
</ul>


<p><a href="http://www.flickr.com/photos/105999540@N03/10374784386/" title="2013-10-14-14 by EricShj, on Flickr"><img src="http://farm8.staticflickr.com/7305/10374784386_8757b04a56.jpg" width="500" height="333" alt="2013-10-14-14"></a></p>

<p>参考资料
<a href="http://www.xnwai.com/2012/12/how-to-view-the-connection-on-the-mac-wifi-password.html">http://www.xnwai.com/2012/12/how-to-view-the-connection-on-the-mac-wifi-password.html</a></p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[多参数selector]]></title>
    <link href="http://saick.net/blog/2013/10/14/duo-can-shu-selector/"/>
    <updated>2013-10-14T16:09:00+08:00</updated>
    <id>http://saick.net/blog/2013/10/14/duo-can-shu-selector</id>
    <content type="html"><![CDATA[<p>Selector是Objective-C一个非常强大的特性，合理使用Selector可以大大简化实现并避免重复代码。但NSObject提供 的performSelector最多只支持两个参数，对于两个以上的参数就无能为力了。一番调查后针对NSObject增加了如下扩展，使得 performSelector可以支持传入参数数组。多个参数就不再是问题了。</p>

<!-- more -->




<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
<span class='line-number'>11</span>
<span class='line-number'>12</span>
<span class='line-number'>13</span>
<span class='line-number'>14</span>
<span class='line-number'>15</span>
<span class='line-number'>16</span>
<span class='line-number'>17</span>
<span class='line-number'>18</span>
<span class='line-number'>19</span>
<span class='line-number'>20</span>
<span class='line-number'>21</span>
<span class='line-number'>22</span>
<span class='line-number'>23</span>
<span class='line-number'>24</span>
<span class='line-number'>25</span>
<span class='line-number'>26</span>
<span class='line-number'>27</span>
<span class='line-number'>28</span>
<span class='line-number'>29</span>
<span class='line-number'>30</span>
<span class='line-number'>31</span>
<span class='line-number'>32</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>@interface NSObject (Addition)
</span><span class='line'>- (id)performSelector:(SEL)selector withObjects:(NSArray *)objects;
</span><span class='line'>@end
</span><span class='line'>
</span><span class='line'>@implementation NSObject (Addition)
</span><span class='line'>- (id)performSelector:(SEL)selector withObjects:(NSArray *)objects { 
</span><span class='line'>    NSMethodSignature *signature = [self methodSignatureForSelector:selector]; 
</span><span class='line'>    if (signature) { 
</span><span class='line'>        NSInvocation* invocation = [NSInvocation invocationWithMethodSignature:signature]; 
</span><span class='line'>        [invocation setTarget:self]; 
</span><span class='line'>        [invocation setSelector:selector]; 
</span><span class='line'>        
</span><span class='line'>        for(int i = 0; i &lt; [objects count]; i++){ 
</span><span class='line'>            id object = [objects objectAtIndex:i]; 
</span><span class='line'>            [invocation setArgument:&object atIndex: (i + 2)];        
</span><span class='line'>        } 
</span><span class='line'>
</span><span class='line'>        [invocation invoke]; 
</span><span class='line'>
</span><span class='line'>        if (signature.methodReturnLength) { 
</span><span class='line'>            id anObject; 
</span><span class='line'>            [invocation getReturnValue:&anObject]; 
</span><span class='line'>            return anObject; 
</span><span class='line'>        } else { 
</span><span class='line'>            return nil; 
</span><span class='line'>        } 
</span><span class='line'>    } else { 
</span><span class='line'>        return nil; 
</span><span class='line'>    } 
</span><span class='line'>} 
</span><span class='line'>
</span><span class='line'>@end</span></code></pre></td></tr></table></div></figure>


<p>本文出自 “林家男孩” 博客，请务必保留此出处<a href="http://bj007.blog.51cto.com/1701577/538995">http://bj007.blog.51cto.com/1701577/538995</a></p>
]]></content>
  </entry>
  
</feed>
