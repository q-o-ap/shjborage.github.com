<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">

  <title><![CDATA[Category: iOS | Saick Blog - 专注技术，乐在其中]]></title>
  <link href="http://saick.net/blog/categories/ios/atom.xml" rel="self"/>
  <link href="http://saick.net/"/>
  <updated>2013-10-23T22:53:55+08:00</updated>
  <id>http://saick.net/</id>
  <author>
    <name><![CDATA[Eric Shi]]></name>
    
  </author>
  <generator uri="http://octopress.org/">Octopress</generator>

  
  <entry>
    <title type="html"><![CDATA[对比iOS网络组件：AFNetworking VS ASIHTTPRequest]]></title>
    <link href="http://saick.net/blog/2013/10/20/dui-bi-ioswang-luo-zu-jian-%3Aafnetworking-vs-asihttprequest/"/>
    <updated>2013-10-20T22:55:00+08:00</updated>
    <id>http://saick.net/blog/2013/10/20/dui-bi-ioswang-luo-zu-jian-:afnetworking-vs-asihttprequest</id>
    <content type="html"><![CDATA[<p>在开发iOS应用过程中，如何高效的与服务端API进行数据交换，是一个常见问题。一般开发者都会选择一个第三方的网络组件作为服务，以提高开发效率和稳定性。这些组件把复杂的网络底层操作封装成友好的类和方法，并且加入异常处理等。</p>

<p>那么，大家最常用的组件是什么？这些组件是如何提升开发效率和稳定性的？哪一款组件适合自己，是 AFNetworking（AFN）还是 ASIHTTPRequest（ASI）？几乎每一个iOS互联网应用开发者都会面对这样的选择题，要从这两个最常用的组件里选出一个好的还真不是那么容易。</p>

<p>单单从两个控件版本提交的时间节点来看，AFN的第一个提交是2011年的1月1日，那个时候ASI早已是1.8+的版本了；而当AFN发布1.0版，2012年10月份的时候，ASI早早的已经停止更新了。这样看起来，AFN是ASI的继任者，似乎不存在之前提到的选择困难的问题，而事实并非如此。本文将从用法、功能、性能和原理几个方面对二者进行简单对比，看看二者之间到底存在着怎样的区别，到底应该如何选择。</p>

<!-- more -->


<ul>
<li>首先，从推荐用法上就可以看出二者设计理念上大有不同。</li>
</ul>


<h3>1、用法对比</h3>

<p><a href="http://www.flickr.com/photos/105999540@N03/10382705763/" title="2013-10-20-5 by EricShj, on Flickr"><img src="http://farm3.staticflickr.com/2867/10382705763_25114b14ed.jpg" width="464" height="309" alt="2013-10-20-5"></a></p>

<p>图1，AFN的示例代码，发起请求（出自：Posts.m）</p>

<p>AFN官方推荐的使用方法是，为一系列相关的请求定义一个HTTPClient，共用一个BaseURL。每次请求把URL中除BaseURL的Path部分做为参数传给HTTPClient的静态方法，并注册一个Block用于回调。</p>

<p><a href="http://www.flickr.com/photos/105999540@N03/10382705703/" title="2013-10-20-6 by EricShj, on Flickr"><img src="http://farm4.staticflickr.com/3724/10382705703_90269d2bbe.jpg" width="464" height="143" alt="2013-10-20-6"></a></p>

<p>图2，ASI示例代码，发起异步请求（出自：ASIHTTPRequestTests.m）</p>

<p>ASI推荐使用方法就非常传统，每一个请求都由构造方法初始化一个（共享）实例，通过这个实例配置参数并发起请求。ASI最初使用delegate模式回调，在iOS SDK支持Block之后也提供了注册Block的实例方法。</p>

<p>以上引用的两段代码都出自各自项目的示例工程。对比两段代码可以很清楚的看出，同样是发起一个最普通的异步请求，使用AFN只需要调用一个静态方法，但代码可读性较差；而ASI的示例看起来更清晰，但需要调用多个实例方法才能完成一次请求。AFN的设计更加工程化，或者说对使用者更友好，而ASI的设计更经典，典型的OOP。
除了初级用法上的区别，二者的高级功能和对扩展的支持也颇有不同。</p>

<h3>2、高级功能</h3>

<p>AFN只封装了一些常用功能，满足基本需求，而直接忽略了很多扩展功能。例如：AFN默认没有封装同步请求，如果开发者需要使用同步请求，则需要重写getPath:parameters:success:failure方法，对AFHTTPRequestOperation进行同步处理；而ASI则是直接通过调用一个startSynchronous方法。
此外AFN针对JSON、XML、PList和Image四种数据结构封装了各自处理器，开发者可以把处理器注册到操作队列中，直接在回调方法中获得格式化以后的数据。在示例工程中就使用了JSON处理器：把AFJSONRequestOperation注册到操作队列里。</p>

<p><a href="http://www.flickr.com/photos/105999540@N03/10382500994/" title="2013-10-20-7 by EricShj, on Flickr"><img src="http://farm8.staticflickr.com/7419/10382500994_16a83e90d4.jpg" width="464" height="192" alt="2013-10-20-7"></a></p>

<p>图3，AFN示例代码，初始化自定义的HTTPClient（出自：AFAppDotNetAPIClient.m）</p>

<p>而ASI在这方面显得更原始，没有针对任何数据类型做特别封装，只是预留了各种接口和工具供开发者自行扩展。ASI比AFN提供更多扩展功能还有一个原因，它把许多内部用到的功能也抽象成类和方法。例如：
ASIHTTPRequestDataCompressor和ASIHTTPRequestDataDecompressor两个类，只用于压缩本地文件，构造POST Body和解压缩返回数据，但这两个类仍然被设计为独立功能，提供了对多种数据结构进行压缩和解压缩的方法。</p>

<p>对比二者的高级功能和对扩展的支持后，可以看出AFN把初级功能（或者叫常用功能）做到了90分。调用方式够简单，处理器够丰富，使用者用起来可以算是轻松加愉快。但它放弃了对高级功能的支持，要满足较复杂的需求，就要大费周折了，在这方面最多只有40分。而ASI显然不满足于做好初级功能，但为了提供更丰富的可扩展接口，导致初级功能用起来也要花上一些力气。虽然ASI单独提供了支持Amazon S3和Rackspace Cloud Files的控件，但对于生在红旗下的我朝开发者来说基本没用，所以在初级功能的支持上ASI能得个70分，牺牲了初级功能的易用性，换来的是良好的扩展性，在高级功能的使用上远远好于AFN，也能得个70分。</p>

<p>从使用角度对比过后，基本上对这两个项目有一个整体上的认识，再深入下去看看二者的性能如何。</p>

<h3>3、性能对比</h3>

<p>我分别用AFN和ASI进行了测试，测试环境如下：iPhone5，联通3G信号全满，室内静止状态，请求国内双线机房独立服务器的静态文件，1~20K共20个文件，每个文件请求20次，记录从创建请求到完全下载文件的耗时，结果如下：</p>

<p><a href="http://www.flickr.com/photos/105999540@N03/10382705653/" title="2013-10-20-8 by EricShj, on Flickr"><img src="http://farm4.staticflickr.com/3715/10382705653_fa58c22d18.jpg" width="464" height="146" alt="2013-10-20-8"></a></p>

<p>图4，AFN连续访问1 ~ 20K文件耗时</p>

<p><a href="http://www.flickr.com/photos/105999540@N03/10382545196/" title="2013-10-20-9 by EricShj, on Flickr"><img src="http://farm8.staticflickr.com/7296/10382545196_4c6f799013.jpg" width="464" height="146" alt="2013-10-20-9"></a></p>

<p>图5，ASI连续访问1 ~ 20K文件耗时</p>

<p>图4是AFN的记录图，绿色为20次请求中耗时最久的一次，蓝色为耗时最短的一次，黄色为去除最大值和最小值的18次平均值。从这个图可以看出，AFN最开始创建对象耗时近2.5秒，随后稳定下来，在3K、7K、15K和20K时出现了抖动。图5是ASI做相同测试的结果，首次创建对象近2.25秒，略优于AFN，同样在5K、11K、13K、14K和16K发生了一些抖动，但抖动幅度似乎小于AFN，可见稳定性更好一些。
下边是把二者的测试结果放在一起的对比图，可以更直观的比较二者的区别。</p>

<p><a href="http://www.flickr.com/photos/105999540@N03/10382500714/" title="2013-10-20-10 by EricShj, on Flickr"><img src="http://farm8.staticflickr.com/7317/10382500714_0725ae4480.jpg" width="464" height="147" alt="2013-10-20-10"></a></p>

<p>图6，ASI和AFN耗时最大值对比</p>

<p>图6的最大值对比可以更明显的看出二者的抖动对比，ASI略好一些。</p>

<p><a href="http://www.flickr.com/photos/105999540@N03/10382525995/" title="2013-10-20-11 by EricShj, on Flickr"><img src="http://farm6.staticflickr.com/5476/10382525995_1a6cd98274.jpg" width="464" height="146" alt="2013-10-20-11"></a></p>

<p>图7，ASI和AFN耗时最小值对比</p>

<p>图7的最小值对比可以看出，在每一个大小的测试中ASI的最佳性能似乎都要优于AFN。</p>

<p><a href="http://www.flickr.com/photos/105999540@N03/10382705193/" title="2013-10-20-12 by EricShj, on Flickr"><img src="http://farm3.staticflickr.com/2880/10382705193_25f55ba5b3.jpg" width="464" height="147" alt="2013-10-20-12"></a></p>

<p>图8，ASI和AFN耗时平均值对比</p>

<p>图8是耗时平均值的对比，更能够说明问题。文件小于12K的测试中ASI的性能优势并没有非常明显，超过12K以后，ASI优势开始明显起来，每一次请求都要比AFN节约20% ~ 30%，近0.1秒。同时从这张图上还可以看出，随着下载文件变大，请求耗时并不是线形增长的，这是由于一次请求大部分时间都消耗在建立连接上，而真正接收数据只占用了极少时间，这个问题不在本篇文章的讨论范围，所以不多说，有兴趣的读者可以<a href="http://segmentfault.com/t/ios">移步</a>进一步讨论。</p>

<h3>4、原理分析</h3>

<p>ASI的性能似乎全面优于AFN，那下边从二者的实现原理上看一下到底是什么原因造成这种差距。ASI基于CFNetwork框架开发，而AFN基于NSURL，底层的区别是导致二者性能差距的重要原因之一。</p>

<p><a href="http://www.flickr.com/photos/105999540@N03/10382544986/" title="2013-10-20-13 by EricShj, on Flickr"><img src="http://farm8.staticflickr.com/7325/10382544986_92a3d7bf99.jpg" width="464" height="289" alt="2013-10-20-13"></a></p>

<p>图9，ASI和AFN以及底层框架的关系</p>

<p>我们知道所有网络通信的基础是Socket，一个Socket与另一个连接并传送数据。BSD Socket是一类最常见的Socket抽象接口。</p>

<p>Core Foundation框架中的CFSocket就是基于BSD Socket开发的。它几乎涵盖了BSD Socket的全部功能，更重要的是把Socket整合到事件的处理循环中。Core Founda-tion中较高层的CFStream是基于CFSocket开发的读写流支持。</p>

<p>CFNetwork是基于Core Foundation中CFStream的一个底层高性能网络框架，它由提供基础服务的CFSocketStream，支持HTTP协议的CFHTTP，基于CFHTTP用于身份认证的CFHTTPAuthentication和支持FTP协议的CFFTP组成。</p>

<p>正如图9所示，ASI是基于CFHTTP开发的一个组件；而AFN的基础——NSURL，也是基于CFNetwork开发的。也就是说ASI相比AFN更加底层，这就从一定程度上造成二者的性能差距。
另一个方面，虽然二者都使用NSOperation和NSOperationQueue实现但底层的区别也导致实现方式上有非常大的差别。</p>

<p>ASI的直接操作对象ASIHTTPRequest是NSOperation的子类，实现了NSCopying协议。在initialize和initWithURL:方法中初始化相关属性并配置一系列请求相关参数默认值。此外，ASIHTTPRequest还提供了一系列的实例方法用来配置请求对象。在异步请求的处理上，ASIHTTPRequest对象初始化结束后，在startAsynchronous方法中把对象加入共享操作队列。此后，包括创建CFHTTPMessageRef，也就是处理网络请求的主要对象（事实上是一个指向__CFHTTPMessage结构的指针），在内的所有操作都在ASIHTTPRequest对象所属的子线程中完成。</p>

<p>AFN的直接操作对象AFHTTPClient不同于ASI，是一个实现了NSCoding和NSCopying协议的NSObject子类。AFHTTPClient是一个封装了一系列操作方法的“工具类”，处理请求的操作类是一系列单独的，基于NSOperation封装的，AFURLConnectionOperation的子类。AFN的示例代码中通过一个静态方法，使用dispatch_once()的方式创建AFHTTPClient的共享实例，这也是官方建议的使用方法。在创建AFHTTPClient的初始化方法中，创建了OperationQueue并设置一系列参数默认值。在getPath:parameters:success:failure方法中创建NSURLRequest，以NSURLRequest对象实例作为参数，创建一个NSOperation，并加入在初始化发方中创建的NSOperationQueue。以上操作都是在主线程中完成的。在NSOperation的start方法中，以此前创建的NSURLRequest对象为参数创建NSURLConnection并开启连结。</p>

<p>在异步回调的处理上二者也有区别，ASI采取的是CFHTTP请求完成，直接回调ASIHTTPRequest的实例方法，通过储存的实例对象记录的信息完成Delegate模式或Block模式的回调。而AFN则直接使用了NSOperation的completionBlock属性。</p>

<p>这些实现方式也可以看出，ASI显得更加底层，并没有过多使用Cocoa框架中已经封装的API，而AFN则更加实用主义，逻辑简单清晰，大量使用了框架API。这一点也是造成二者性能差别的原因之一。</p>

<h3>总结</h3>

<p>通过以上的对比，基本可以这样评价：AFN适合逻辑简单的应用，或者更适合开发资源尚不丰富的团队，因为AFN的易用性要比ASI好很多，而这样的应用（或团队）对底层网络控件的定制化要求也非常低。ASI更适合已经发展了一段时间的应用，或者开发资源相对丰富的团队，因为往往这些团队（或他们的应用）已经积累了一定的经验，无论是产品上还是技术上的。需求复杂度就是在这种时候高起来，而且底层订制的需求也越来越多，此时AFN就很难满足需求，需要牺牲一定的易用性，使用ASI作为网络底层控件。SegmentFault开源客户端现在被设计为一款简单的阅读客户端，几乎没有定制要求，因此，目前我选择了AFN作为网络控件。
以上对ASI和AFN两款最常用的iOS底层网络控件做了初步的介绍，要更深入的了解两款控件，还需要大家继续研究各自的源码。大家遇到任何关于iOS的技术问题都可以在<a href="http://segmentfault.com/t/ios">这里</a>进行讨论。另外大家也可以持续关注SegmentFault的开源客户端，与更多的开发者共同探讨iOS开发技术。</p>

<p>作者简介</p>

<p>高嘉峻（微博：@gaosboy），SegmentFault.com联合创始人，杭州iOS开发者沙龙发起人，资深iOS开发者。</p>

<p><a href="http://www.infoq.com/cn/articles/afn_vs_asi">http://www.infoq.com/cn/articles/afn_vs_asi</a></p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Objective-C的新特性(Object Literals等)]]></title>
    <link href="http://saick.net/blog/2013/10/20/objective-cde-xin-te-xing-object-literals/"/>
    <updated>2013-10-20T22:28:00+08:00</updated>
    <id>http://saick.net/blog/2013/10/20/objective-cde-xin-te-xing-object-literals</id>
    <content type="html"><![CDATA[<p>转自：<a href="http://blog.devtang.com/blog/2012/08/05/use-modern-objective-c/">http://blog.devtang.com/blog/2012/08/05/use-modern-objective-c/</a> (Posted by 唐巧 Aug 5th, 2012  iOS)</p>

<p>苹果在今年的WWDC2012大会上介绍了大量Objective-C的新特性，能够帮助iOS程序员更加高效地编写代码。在不久前更新的XCode4.4版本中，这些新特性已经可以使用了。让我们看看这些新特性有哪些：</p>

<h3>Object Literals</h3>

<p>这个是我认为最赞的一个改进。Object Literals允许你方便地定义数字、数组和字典对象。这个功能类似于java5提供的auto boxing功能。这虽然是一个语法糖，但我认为对提高写代码效率帮助很大。让我们先来看看以前定义数字、数组和字典对象的方法：</p>

<p><code>
123NSNumber * number = [NSNumber numberWithInt:1];
NSArray * array = [NSArray arrayWithObjects:@"one", @"two", nil];
NSDictionary * dict = [NSDictionary dictionaryWithObjectsAndKeys:@"value1", @"key1", @"value2", @"key2", nil];
</code></p>

<p>是不是很恶心？现在以上代码可以简化成以下形式，注意到没有，不用再在参数的最后加恶心的nil了，字典的key和value也不再是倒着先写value,再写key了：</p>

<!-- more -->


<p><code>
NSNumber * number = @1;
NSArray * array = @[@"one", @"two"];
NSDictionary * dict = @{@"key1":@"value1", @"key2":@"value2"};
</code></p>

<p>更多的示例如下：</p>

<p><div class='bogus-wrapper'><notextile><figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
<span class='line-number'>11</span>
<span class='line-number'>12</span>
<span class='line-number'>13</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>// 整数&lt;br/>
</span><span class='line'>NSNumber &lt;em>fortyTwo = @42;             // 等价于 [NSNumber numberWithInt:42]  NSNumber &lt;/em>fortyTwoUnsigned = @42U;    // 等价于 [NSNumber numberWithUnsignedInt:42U]  NSNumber &lt;em>fortyTwoLong = @42L;        // 等价于 [NSNumber numberWithLong:42L]  NSNumber &lt;/em>fortyTwoLongLong = @42LL;   // 等价于 [NSNumber numberWithLongLong:42LL]&lt;/p>
</span><span class='line'>
</span><span class='line'>&lt;p>// 浮点数&lt;br/>
</span><span class='line'>NSNumber &lt;em>piFloat = @3.141592654F;    // 等价于 [NSNumber numberWithFloat:3.141592654F]&lt;br/>
</span><span class='line'>NSNumber &lt;/em>piDouble = @3.1415926535;   // 等价于 [NSNumber numberWithDouble:3.1415926535]&lt;/p>
</span><span class='line'>
</span><span class='line'>&lt;p>// 布尔值&lt;br/>
</span><span class='line'>NSNumber &lt;em>yesNumber = @YES;           // 等价于 [NSNumber numberWithBool:YES]  NSNumber &lt;/em>noNumber = @NO;             // 等价于 [NSNumber numberWithBool:NO]&lt;/p>
</span><span class='line'>
</span><span class='line'>&lt;p>// 空数组&lt;/p>
</span><span class='line'>
</span><span class='line'>&lt;p>NSArray * array = @[];                // 等价于 [NSArray array]  // 空的字典  NSDictionary * dict = @{};            // 等价于 [NSDictionary dictionary]</span></code></pre></td></tr></table></div></figure></notextile></div></p>

<p>怎么样？是不是简单多了？而且，为了方便你的旧代码迁移到新的写法，xcode专门还提供了转换工具，在xcode4.4中，选择 Edit &ndash;> Refactor &ndash;> Convert to Modern Objective-C Syntax即可。</p>

<h3>局部的函数调用不用前向申明</h3>

<p>这虽然是一个挺小的改进，但是很贴心。假如我们在一个源文件中有2个函数：分别名为foo 和 bar，其中foo的定义在bar前面。那如果在foo函数内部直接调用bar，编译器会报警告说找不到函数bar。
而现在，我们可以随意地在源文件中放置函数bar的位置。编译器在找不到bar时，会再源码后面找，如果找到了bar，就不会报错了。</p>

<h3>带有类型的enum</h3>

<p>现在我们可以定义enum是无符号整数还是整数，这样编译器会更加智能的做类型检查。如下所示：</p>

<p><code>
typedef enum TableViewCellType : NSInteger {    
TableViewCellTypeQueue,    
TableViewCellTypeNewFans,    
TableViewCellTypeUserInfo,    
TableViewCellTypeOrganization,    
TableViewCellTypeFeedback,    
TableViewCellTypeRateApp,    
TableViewCellTypeRecommendation,    
TableViewCellTypeLogout}TableViewCellType;
</code></p>

<h3>默认生成@synthesize代码</h3>

<p>以前写完一个诸如 @property (nonatomic, strong) NSString * username; 变量定义后，马上得转到 .m文件中去增加相应的 @synthesize username = _username; 代码。</p>

<p>现在，编辑器发现你没有写 @synthesize时，会自动帮你加上这一行。这同时在另一方面，起到了鼓励大家使用以下划线开头的变量名作为成员变量名的作用。</p>

<p>当然，为了向下兼容，如果你的程序里面已经有了 @property 变量对应的 @synthesize 代码时，编辑器就不会自动帮你增加这个代码了。
另外有2种特殊情况下，即使你没有写 @synthesize ，编辑器也不会自动帮你加上，这2种情况是：</p>

<ul>
<li>你同时提供了该property的setter 和 getter方法。</li>
<li>你的这个property是 readonly 的。</li>
</ul>


<h3>遍历元素</h3>

<p>你是如何遍历数组的元素的？通常我们有2种做法，一种是用 for in，另一种是用一个变量来循环数组下标。如下：</p>

<p>```
// 12345678    NSArray * lines = &hellip;  <br/>
for (NSString * line in lines) {</p>

<pre><code>   // ...    
</code></pre>

<p>}
for (int i = 0; i &lt; lines.count; ++i) {</p>

<pre><code>NSString * s = [lines objectAtIndex:i];        
...    
</code></pre>

<p>}
```</p>

<p>如果是字典，遍历的代码就要稍微复杂一点了：</p>

<p>```
NSDictionary * dict = …    NSArray * keys = [dict allKeys];
for (NSString * key in keys) {</p>

<pre><code>NSString * value = [dict objectForKey:key];    
</code></pre>

<p>}
```</p>

<p>现在，xcode对于iOS4.0以上的系统，支持用block来遍历元素了。用block来遍历字典可以简化代码的编写，建议大家都使用上这个新特性。</p>

<p><code>
[lines enumerateObjectsUsingBlock:^(NSString * obj, NSUInteger idx, BOOL *stop) {}];[_urlArguments enumerateKeysAndObjectsUsingBlock:^(id key, id obj, BOOL *stop) {}];
</code></p>

<h3>Subscripting Methods</h3>

<p>这个新特性在WWDC2012的视频中提到了，但是在XCode4.4中没有实现（在XCode4.5中实现了）。也是一个很体贴的语法糖，它允许你用中括号来代替原本的方法来获取和设置数组元素。</p>

<p>简单来说，以前的 [array objectAtIndex:idx] 和 [array replaceObjectAtIndex:idx withObject:obj]，可以直接写作 array[idx] 和 array[idx] = obj了。其实这个特性在很多高级语言中都实现了，只是Objective-C生于80年代，一直没改进这个。</p>

<p>以下是一些示例代码：</p>

<p>```
NSArray * array = @[ @&ldquo;111&rdquo;, @&ldquo;222&rdquo;, @&ldquo;333&rdquo;];
for (int i = 0; i &lt; 3; ++i) {</p>

<pre><code>NSLog(@"array[i] = %@", array[i]);
</code></pre>

<p>}
NSMutableDictionary * dict =[@{  @1: @&ldquo;value1&rdquo;, @2: @&ldquo;value2&rdquo;,                                 @3: @&ldquo;value3&rdquo; } mutableCopy];
for (int i = 0; i &lt; 3; ++i) {</p>

<pre><code>NSLog(@"dict[%d] = %@", i, dict[@(i+1)]);
dict[@(i+1)] = [NSString stringWithFormat:@"new %@", dict[@(i+1)]];}
[dict enumerateKeysAndObjectsUsingBlock:^(id key, id obj, BOOL *stop{
    NSLog(@"dict[%@] = %@", key, dict[key]);
}];
</code></pre>

<p>}
```</p>

<p>这个改进同样对NSDictionary有效。甚至，你也可以给你自己的类提供中括号操作符对应的方法。具体做法是实现如下两个方法：</p>

<p><code>
- (id)objectAtIndexedSubscript:(NSUInterger)idx;- (void)setObject:(id)value atIndexedSubscript:(NSUInteger)idx;
</code></p>

<h3>Tips</h3>

<p>上面提到了不用写 @synthesize 了，那原本写的那么多 @synthesize 怎么办呢？作为有代码洁癖的我很想把它们删掉，但怎么删呢？一个文件一个文件打开，然后行一行删掉吗？放心，苹果已经帮我们想了解决方案。在WWDC2012 Session 400 Developer Tools Kickoff 中，苹果介绍了具体做法。步骤如下：</p>

<ul>
<li>首先使用区域查找，因为一般项目都会依赖第三方的开源库，我们可不想更改别人的库，所以我们只查找我们库中的文件，如下图所示：</li>
</ul>


<p><a href="http://www.flickr.com/photos/105999540@N03/10382148323/" title="2013-10-20-1 by EricShj, on Flickr"><img src="http://farm4.staticflickr.com/3803/10382148323_3e5d2aabbc.jpg" width="317" height="449" alt="2013-10-20-1"></a></p>

<ul>
<li>接着我们用正则匹配，找到以 @synthesize开头，后面接着是 var = _var; 格式的行。插入正则表达式很简单，直接点击查找输入框左边的放大镜，选择“insert pattern”，苹果就会把常见的正则表达式都列出来，你直接选择就可以了，非常方便。如下图所示：</li>
</ul>


<p><a href="http://www.flickr.com/photos/105999540@N03/10382148463/" title="2013-10-20-2 by EricShj, on Flickr"><img src="http://farm8.staticflickr.com/7415/10382148463_a1fe6d797a.jpg" width="441" height="181" alt="2013-10-20-2"></a></p>

<p>在插入好合适的正则表达式后，我们按回车，就可以搜索到结果。
<a href="http://www.flickr.com/photos/105999540@N03/10382148643/" title="2013-10-20-3 by EricShj, on Flickr"><img src="http://farm4.staticflickr.com/3724/10382148643_1604c7809b.jpg" width="296" height="315" alt="2013-10-20-3"></a></p>

<ul>
<li>我们点击搜索界面的preview按钮，查看替换效果，可以看到，对于我们测试代码，XCode生成的预览图已经正确地当对应代码删掉了。然后我们就可以点击替换，去掉所有的 @synthesize 代码了。</li>
</ul>


<p><a href="http://www.flickr.com/photos/105999540@N03/10382148923/" title="2013-10-20-4 by EricShj, on Flickr"><img src="http://farm4.staticflickr.com/3769/10382148923_5836e42c21.jpg" width="500" height="97" alt="2013-10-20-4"></a></p>

<p>在下载完XCode4.4后，我就把我们的工程代码都转换成了新特性的语法。在转换后，我发现原本25000行的代码少了将近1000行。心里还是很开心的，因为又可以少写一些体力活类型的代码了。
还是那句话，希望这些新特性能够让大家玩得开心。
参考资料</p>

<ul>
<li> LLVM官方网站比较全面地介绍了 Object Literal： <a href="http://clang.llvm.org/docs/ObjectiveCLiterals.html">http://clang.llvm.org/docs/ObjectiveCLiterals.html</a></li>
<li> WWDC2012 Session 400 Developer Tools Kickoff</li>
<li> WWDC2012 Session 405 Modern Objective-C</li>
<li> WWDC2012 Session 413 Migrating to Modern Objective-C</li>
</ul>

]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[iOS ARC 兼容处理]]></title>
    <link href="http://saick.net/blog/2013/10/19/ios-arc-jian-rong-chu-li/"/>
    <updated>2013-10-19T01:56:00+08:00</updated>
    <id>http://saick.net/blog/2013/10/19/ios-arc-jian-rong-chu-li</id>
    <content type="html"><![CDATA[<p>From:宋红日（转自：<a href="http://blog.sina.com.cn/s/blog_9792a85b01018v83.html%EF%BC%89">http://blog.sina.com.cn/s/blog_9792a85b01018v83.html%EF%BC%89</a></p>

<p>我们经常在引用第三方控件或者阅读一个开源的代码的时候，与自己的xcode 的开发环境不一样，导致编译不过的问题，还得改代码，带来了一定的工作量。其实有一下方法做到兼容处理。统一用下面定义的宏就可以。
尤其当你决定做一个通用的控件 或 模块的时候。</p>

<!-- more -->


<p>```
// ARC conditions</p>

<h1>if !__has_feature(objc_arc)</h1>

<h1>define Release(obj) [obj release]</h1>

<h1>define Retain(obj) [obj retain]</h1>

<h1>else</h1>

<h1>define Release(obj)</h1>

<h1>define Retain(obj) obj</h1>

<h1>endif</h1>

<p>```</p>

<p>另外，如果是ARC工程，某些文件不支持ARC的话，可以在Target->Build Phases->Complie sources 中对某个文件加入Complier Flags “-fno-objc-arc”</p>

<p>如下图：</p>

<p><a href="http://www.flickr.com/photos/105999540@N03/10374769035/" title="2013-10-19-1 by EricShj, on Flickr"><img src="http://farm8.staticflickr.com/7294/10374769035_c11c167c38_z.jpg" width="640" height="237" alt="2013-10-19-1"></a></p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[iOS Cookie使用]]></title>
    <link href="http://saick.net/blog/2013/10/19/ios-cookieshi-yong/"/>
    <updated>2013-10-19T01:08:00+08:00</updated>
    <id>http://saick.net/blog/2013/10/19/ios-cookieshi-yong</id>
    <content type="html"><![CDATA[<p>转自：<a href="http://geeklu.com/2013/04/ios-cookie/">http://geeklu.com/2013/04/ios-cookie/</a></p>

<p>关于Cookie的标准和原理这里就不细说了，这里只说说在iOS平台下如何进行Cookie相关的编程。
和Mac上不同，在iOS平台上各个App都有自己的Cookie，App之间不共享Cookie。
一个Cookie对应一个NSHTTPCookie实体，并通过NSHTTPCookieStorage进行管理。
那些需要持久化的Cookie是存放在 ~/Library/Cookies/Cookies.binarycookies 文件中的，二进制格式。</p>

<p>Cookie生成的有两个途径，一个是访问一个网页，这个网页返回的HTTP Header中有Set-Cookie指令进行Cookie的设置，这里Cookie的本地处理其实是由WebKit进行的；还有一种途径就是客户端通过代码手动设置Cookie。</p>

<!-- more -->


<p><code>
NSMutableDictionary *cookieProperties = [NSMutableDictionary dictionary];[cookieProperties setObject:@"name" forKey:NSHTTPCookieName];
[cookieProperties setObject:@"value" forKey:NSHTTPCookieValue];
[cookieProperties setObject:@"www.taobao.com" forKey:NSHTTPCookieDomain];[cookieProperties setObject:@"/" forKey:NSHTTPCookiePath];
[cookieProperties setObject:@"0" forKey:NSHTTPCookieVersion];
[cookieProperties setObject:@"30000" forKey:NSHTTPCookieMaximumAge];
NSHTTPCookie *cookie = [NSHTTPCookie cookieWithProperties:cookieProperties];
[[NSHTTPCookieStorage sharedHTTPCookieStorage] setCookie:cookie];
//删除cookie的方法为deleteCookie:
</code></p>

<p>在通过setCookie:进行设置cookie的时候，会覆盖name,domain,path都相同的cookie的。
至于cookie会不会持久化到cookie文件中主要看这个cookie的生命周期，和Max-Age或者Expires有关。</p>

<p>不过NSHTTPCookieStorage存在一个问题，setCookie或者deleteCookie后并不会立即进行持久化，而是有几秒的延迟。如果在持久化之前App接收到SIGKILL信号，App退出，那么会导致cookie相关操作的丢失。在模拟器调试的过程中，XCode重启App的时发给App的就是SIGKILL，不过真正的生产环境中很少有这种情况。
但是有时候为了可靠性，我们还是会将cookie信息保存一份到User Defaults，需要用的时候load进来。关于cookie操作丢失的详情可以查看这里<a href="http://openradar.appspot.com/radar?id=2776403">NSHTTPCookieStorage looses cookies on SIGKILL</a></p>

<p>卢克 / 2013-04-02</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[iOS库添加CocoaPods支持]]></title>
    <link href="http://saick.net/blog/2013/10/17/iosku-tian-jia-cocoapodszhi-chi/"/>
    <updated>2013-10-17T15:30:00+08:00</updated>
    <id>http://saick.net/blog/2013/10/17/iosku-tian-jia-cocoapodszhi-chi</id>
    <content type="html"><![CDATA[<p>现在CocoaPods如此方便（虽然可能也有它的缺点），但是很多开源库，自己写的库并没有对它进行支持，特研究了一下，分享给大家。</p>

<h3>准备好库代码（GitHub上）</h3>

<p>将代码Checkout下来，打开命令行，cd到代码根目录</p>

<h3>创建XXXX.podspec</h3>

<p><code>
pod spec create XXXX
</code></p>

<!-- more -->


<h3>编辑XXXX.podspec</h3>

<p>创建好的文件里有很多指引，这步很简单。 实在不明白，再看看GitHub上别的库的spec文件怎么写的。</p>

<h3>验证合法性</h3>

<p><code>
pod spec lint XXXX.podspec
</code></p>

<p>完成后即可把这个文件提交到<a href="https://github.com/CocoaPods/Specs">CocoaPods specs</a>中。</p>

<p>When you&rsquo;re done you can also fork the <a href="https://github.com/CocoaPods/Specs">CocoaPods specs</a>  GitHub repository and send a pull request. We really love contributions and will help ensure it&rsquo;s perfect!</p>

<h3>详细提交步骤</h3>

<p>From：<a href="http://docs.cocoapods.org/guides/contributing_to_the_master_repo.html">http://docs.cocoapods.org/guides/contributing_to_the_master_repo.html</a></p>

<h3>Contributing to the master repo</h3>

<p>The master repo contains specifications of open-source Objective-C libraries.</p>

<h4>Details</h4>

<ul>
<li> installation path: ~/.cocoapods/master</li>
<li> home: <a href="https://github.com/CocoaPods/Specs">https://github.com/CocoaPods/Specs</a></li>
</ul>


<h4>Contributing</h4>

<p>To ensure a high quality, reliable collection of Pods, the master repo is strict about the acceptable specifications. The CocoaPods linter (see the pod spec lint command) is used to validate specifications, and no errors or warnings are accepted.
The highest priority of the master repo is to guarantee the integrity of existing CocoaPods installations.
In general this means that:</p>

<ul>
<li> A specification cannot be deleted.</li>
<li> Specifications can be updated only if they don’t affect existing installations.</li>
<li><ul>
<li>Broken specifications can be updated.</li>
<li>Subspecs can be added as they are included by the parent specification by default.</li>
</ul>
</li>
<li> Only authoritative version numbers are accepted.</li>
</ul>


<p>CocoaPods uses a versioning scheme known as Semantic Versioning, necessary for cross resolution of dependencies.</p>

<h4>Unversioned libraries</h4>

<p>One of the CocoaPods goals is to promote the discovery of open-source software, for this reason new Pods for libraries which are not versioned are accepted in the master repo. The specifications of those pods should carry the version 0.0.1 under the assumption that, if the author starts versioning, she/he is unlikely to pick 0.0.1. This is the only exception for authoritative version numbers.
If you add an unversioned Pod it is your responsibility to ask the author of the library to tag versions, luckily we have a template for this.
To prevent collisions with possible future versions, unversioned libraries can’t be updated until the author starts to tag them.
If you need to update an unversioned library you can:</p>

<ul>
<li> Ask the author to version the library.</li>
<li> Maintain a fork which is versioned. This fork should be clearly namespaced from the original library according the NAME@USERconvention (e.g. Reachability@irrationalfab). It should also mention in the summary that it is a versioned fork.</li>
<li> Create a podspec and use it in a private repo.</li>
</ul>


<h4>Creating podspecs</h4>

<p>Creating a podspec is very easy as we provide templates full of examples.
You can use the following command:</p>

<p><code>
$ pod spec create Bananas
</code></p>

<p>If the library is hosted on GitHub you can pass the url so CocoaPods can precompile the template:</p>

<p><code>
$ pod spec create https://github.com/Bananas/Bananas
</code></p>

<p>A this point you need edit compile the template (a pod specification is a Ruby source file):</p>

<p><code>
$ pod spec lint Bananas.podspec --verboseSharing podspecs
</code></p>

<h4>Sharing podspecs</h4>

<p>When a podspec lints you can submit it to the master repo.</p>

<h4>Without push access</h4>

<p>You need to fork the master repo on github, then you need to:</p>

<p><code>
$ cd ~/.cocoapods/master
$ git checkout -b fork
$ git remote add myfork https://github.com/YOUR_USER_NAME/Specs.git
$ cp ~/Bananas.podspec ~/.cocoapods/master/Bananas/VERSION/
$ git push myfork
$ git checkout master
</code></p>

<p>Once you push your changes, you can make a pull request on CocoaPods/Specs.
With push access</p>

<p><code>
$ pod push Bananas.podspec
</code></p>
]]></content>
  </entry>
  
</feed>
