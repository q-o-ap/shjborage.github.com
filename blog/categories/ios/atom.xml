<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">

  <title><![CDATA[Category: iOS | Saick Blog]]></title>
  <link href="http://saick.net/blog/categories/ios/atom.xml" rel="self"/>
  <link href="http://saick.net/"/>
  <updated>2013-12-08T13:18:50+08:00</updated>
  <id>http://saick.net/</id>
  <author>
    <name><![CDATA[Eric Shi]]></name>
    
  </author>
  <generator uri="http://octopress.org/">Octopress</generator>

  
  <entry>
    <title type="html"><![CDATA[定制iOS 7中的导航栏和状态栏]]></title>
    <link href="http://saick.net/blog/2013/12/08/ding-zhi-ios-7zhong-de-dao-hang-lan-he-zhuang-tai-lan/"/>
    <updated>2013-12-08T02:30:00+08:00</updated>
    <id>http://saick.net/blog/2013/12/08/ding-zhi-ios-7zhong-de-dao-hang-lan-he-zhuang-tai-lan</id>
    <content type="html"><![CDATA[<p>近期，跟大多数开发者一样，我也正忙于对程序进行升级以适配iOS 7。最新的iOS 7外观上有大量的改动。从开发者的角度来看，导航栏和状态栏就发生了明显的变化。状态栏现在是半透明的了，这也就意味着导航栏会显示在状态栏后面。有些情况下，导航栏的背景图片可以延伸显示到状态栏后面。</p>

<p>之前我曾经写过一篇关于如何定制导航栏的文章。
不过现在是时候对其进行更新了。下面就是本文将要介绍的内容：</p>

<ul>
<li>iOS 7中默认的导航栏</li>
<li>设置导航栏的背景颜色</li>
<li>在导航栏中使用背景图片</li>
<li>定制返回按钮的颜色</li>
<li>修改导航栏标题的字体</li>
<li>修改导航栏标题为图片</li>
<li>添加多个按钮</li>
<li>修改状态栏的风格</li>
<li>隐藏状态栏</li>
<li>总结</li>
</ul>


<!-- more -->


<p><a href="http://www.flickr.com/photos/shjborage/11263366886/" title="2013-12-08-1 by EricShj, on Flickr"><img src="http://farm6.staticflickr.com/5537/11263366886_50b10421ff.jpg" width="500" height="473" alt="2013-12-08-1"></a></p>

<p>本文提供的代码需要用Xcode 5来执行。如果你还在使用老版本的Xcode，那么在运行示例之前请将Xcode升级到Xcode 5。</p>

<h3>iOS 7中默认的导航栏</h3>

<p>在开始定制之前，我们先来看看iOS 7中默认导航栏的外观。通过Xcode用Single View Controller模板创建一个工程。然后将view controller嵌入到一个navigation controller中。如果你不想从头开始，那么也可以在这里下载到这个<a href="https://dl.dropboxusercontent.com/u/2857188/NavigationBarDemo.zip">示例工程</a>。Xcode 5包含有iOS 6和iOS 7模拟器，我们可以在这两个不同的模拟器版本中运行示例程序，进行对比，如下图所示：</p>

<p><a href="http://www.flickr.com/photos/shjborage/11263379574/" title="2013-12-08-2 by EricShj, on Flickr"><img src="http://farm6.staticflickr.com/5478/11263379574_391625e690.jpg" width="500" height="144" alt="2013-12-08-2"></a></p>

<p>如上图所示，在iOS 7中的导航栏默认情况下跟状态栏是交织在一起的，并且它的颜色也被修改为亮灰色。</p>

<h3>设置导航栏的背景颜色</h3>

<p>在iOS 7中，不再使用tintColor属性来设置导航栏的颜色，而是使用barTintColor属性来修改背景色。我们可以在AppDelegate.m文件中的方法didFinishLaunchingWithOptions:里面添加如下代码来修改颜色：</p>

<p><code>
[[UINavigationBar appearance] setBarTintColor:[UIColor yellowColor]];
</code></p>

<p>效果如下图所示：</p>

<p><a href="http://www.flickr.com/photos/shjborage/11263420823/" title="2013-12-08-3 by EricShj, on Flickr"><img src="http://farm4.staticflickr.com/3775/11263420823_9eb0bab4f9.jpg" width="500" height="242" alt="2013-12-08-3"></a></p>

<p>一般情况，我们都会使用自己的颜色，下面这个宏用来设置RGB颜色非常方便：</p>

<p>```</p>

<h1>define UIColorFromRGB(rgbValue) [UIColor colorWithRed:((float)((rgbValue &amp; 0xFF0000) >> 16))/255.0 green:((float)((rgbValue &amp; 0xFF00) >> 8))/255.0 blue:((float)(rgbValue &amp; 0xFF))/255.0 alpha:1.0]</h1>

<p>```</p>

<p>将上面这个宏放到AppDelegate.m文件中，然后通过这个宏来创建一个UIColor对象(根据指定的RGB)。如下示例：</p>

<p><code>
[[UINavigationBar appearance] setBarTintColor:UIColorFromRGB(0x067AB5)];
</code></p>

<p>默认情况下，导航栏的translucent属性为YES。另外，系统还会对所有的导航栏做模糊处理，这样可以让iOS 7中导航栏的颜色更加饱和。如下图，是translucent值为NO和YES的对比效果：</p>

<p><a href="http://www.flickr.com/photos/shjborage/11263366646/" title="2013-12-08-4 by EricShj, on Flickr"><img src="http://farm4.staticflickr.com/3749/11263366646_9f55687f4e.jpg" width="500" height="109" alt="2013-12-08-4"></a></p>

<p>要想禁用translucent属性，可以在Storyboard中选中导航栏，然后在Attribute Inspectors中，取消translucent的勾选。</p>

<h3>在导航栏中使用背景图片</h3>

<p>如果希望在导航栏中使用一个图片当做背景，那么你需要提供一个稍微高一点的图片(这样可以延伸到导航栏背后)。导航栏的高度从44 points(88 pixels)变为了64 points(128 pixels)。我们依然可以使用setBackgroundImage:方法为导航栏设置自定义图片。如下代码所示：</p>

<p><code>
[[UINavigationBar appearance] setBackgroundImage:[UIImage imageNamed:@"nav_bg.png"] forBarMetrics:UIBarMetricsDefault];
</code></p>

<p>示例工程中提供了两个背景图片：nav_bg.png 和 nav_bg_ios7.png。运行一下试试看吧，如下效果：</p>

<p><a href="http://www.flickr.com/photos/shjborage/11263366636/" title="2013-12-08-5 by EricShj, on Flickr"><img src="http://farm4.staticflickr.com/3822/11263366636_79a3394899.jpg" width="500" height="155" alt="2013-12-08-5"></a></p>

<h3>定制返回按钮的颜色</h3>

<p>在iOS 7中，所有的按钮都是无边框的。其中返回按钮会有一个V型箭头，以及上一个屏幕中的标题(如果上一屏幕的标题是空，那么就显示”返回”)。要想给返回按钮着色，可以使用tintColor属性。如下代码所示：</p>

<p><code>
[[UINavigationBar appearance] setTintColor:[UIColor whiteColor]];
</code></p>

<p>除了返回按钮，tintColor属性会影响到所有按钮标题和图片。</p>

<p><a href="http://www.flickr.com/photos/shjborage/11263366586/" title="2013-12-08-6 by EricShj, on Flickr"><img src="http://farm3.staticflickr.com/2824/11263366586_d932478c3e.jpg" width="500" height="102" alt="2013-12-08-6"></a></p>

<p>如果想要用自己的图片替换V型，可以设置图片的backIndicatorImage和backIndicatorTransitionMaskImage。如下代码所示：</p>

<p><code>
[[UINavigationBar appearance] setBackIndicatorImage:[UIImage imageNamed:@"back_btn.png"]];
[[UINavigationBar appearance] setBackIndicatorTransitionMaskImage:[UIImage imageNamed:@"back_btn.png"]];
</code></p>

<p>图片的颜色是由tintColor属性控制的。</p>

<p><a href="http://www.flickr.com/photos/shjborage/11263366576/" title="2013-12-08-7 by EricShj, on Flickr"><img src="http://farm4.staticflickr.com/3679/11263366576_708e24cb31.jpg" width="500" height="102" alt="2013-12-08-7"></a></p>

<h3>修改导航栏标题的字体</h3>

<p>跟iOS 6一样，我们可以使用导航栏的titleTextAttributes属性来定制导航栏的文字风格。在text attributes字典中使用如下一些key，可以指定字体、文字颜色、文字阴影色以及文字阴影偏移量：
UITextAttributeFont – 字体key
UITextAttributeTextColor – 文字颜色key
UITextAttributeTextShadowColor – 文字阴影色key
UITextAttributeTextShadowOffset – 文字阴影偏移量key</p>

<p>如下代码所示，对导航栏的标题风格做了修改：</p>

<p>```
NSShadow *shadow = [[NSShadow alloc] init];</p>

<pre><code>shadow.shadowColor = [UIColor colorWithRed:0.0 green:0.0 blue:0.0 alpha:0.8]; 
shadow.shadowOffset = CGSizeMake(0, 1); 
[[UINavigationBar appearance] setTitleTextAttributes: [NSDictionary dictionaryWithObjectsAndKeys: 
                                                       [UIColor colorWithRed:245.0/255.0 green:245.0/255.0 blue:245.0/255.0 alpha:1.0], NSForegroundColorAttributeName, 
                                                       shadow, NSShadowAttributeName, 
                                                       [UIFont fontWithName:@"HelveticaNeue-CondensedBlack" size:21.0], NSFontAttributeName, nil]]; 
</code></pre>

<p>```</p>

<p>运行效果如下图所示：</p>

<p><a href="http://www.flickr.com/photos/shjborage/11263330475/" title="2013-12-08-8 by EricShj, on Flickr"><img src="http://farm6.staticflickr.com/5491/11263330475_6a2fa2d7a0.jpg" width="500" height="199" alt="2013-12-08-8"></a></p>

<h3>修改导航栏标题为图片</h3>

<p>如果要想将导航栏标题修改为一个图片或者logo，那么只需要使用下面这行代码即可：</p>

<p><code>
self.navigationItem.titleView = [[UIImageView alloc] initWithImage:[UIImage imageNamed:@"appcoda-logo.png"]];
</code></p>

<p>上面的代码简单的修改了titleView属性，将一个图片赋值给它。 注意：这不是iOS 7中的新功能，之前的iOS版本就可以已经有了。具体效果如下图所示：</p>

<p><a href="http://www.flickr.com/photos/shjborage/11263420343/" title="2013-12-08-9 by EricShj, on Flickr"><img src="http://farm6.staticflickr.com/5536/11263420343_e744b52709.jpg" width="500" height="194" alt="2013-12-08-9"></a></p>

<h3>添加多个按钮</h3>

<p>同样，这个技巧也不是iOS 7的，开发者经常会在导航栏中添加多个按钮，所以我决定在这里进行介绍。我们可以在导航栏左边或者右边添加多个按钮。例如，我们希望在导航栏右边添加一个照相机和分享按钮，那只需要使用下面的代码即可：</p>

<p><code>
UIBarButtonItem *shareItem = [[UIBarButtonItem alloc] initWithBarButtonSystemItem:UIBarButtonSystemItemAction target:self action:nil];
UIBarButtonItem *cameraItem = [[UIBarButtonItem alloc] initWithBarButtonSystemItem:UIBarButtonSystemItemCamera target:self action:nil];  
NSArray *actionButtonItems = @[shareItem, cameraItem];
self.navigationItem.rightBarButtonItems = actionButtonItems;
</code></p>

<p>如下效果：</p>

<p><a href="http://www.flickr.com/photos/shjborage/11263379424/" title="2013-12-08-10 by EricShj, on Flickr"><img src="http://farm3.staticflickr.com/2810/11263379424_d57a82b2a7.jpg" width="500" height="171" alt="2013-12-08-10"></a></p>

<h3>修改状态栏的风格</h3>

<p>在老版本的iOS中，状态栏永远都是白色风格。而在iOS 7中，我们可以修改每个view controller中状态栏的外观。通过UIStatusBarStyle常量可以指定状态栏的内容是暗色或亮色。默认情况下，状态栏的显示是暗色。也就是说，状态栏上的时间、电池指示器和Wi-Fi信号显示为暗色。如果导航栏中使用暗色为背景，那么看起来的效果如下图所示：</p>

<p><a href="http://www.flickr.com/photos/shjborage/11263366266/" title="2013-12-08-11 by EricShj, on Flickr"><img src="http://farm8.staticflickr.com/7447/11263366266_e0161eb7bf.jpg" width="500" height="174" alt="2013-12-08-11"></a></p>

<p>如上图这种情况下，我们可能希望将导航栏的风格修改为亮色。这里有两个方法可以实现。在iOS 7中，我们可以在每个view controller中overridingpreferredStatusBarStyle:方法，如下所示：</p>

<p>```
&ndash;(UIStatusBarStyle)preferredStatusBarStyle
{</p>

<pre><code>return UIStatusBarStyleLightContent; 
</code></pre>

<p>}
```</p>

<p>上面代码的效果如下图所示：</p>

<p><a href="http://www.flickr.com/photos/shjborage/11263330045/" title="2013-12-08-12 by EricShj, on Flickr"><img src="http://farm4.staticflickr.com/3745/11263330045_77ed88449d.jpg" width="500" height="173" alt="2013-12-08-12"></a></p>

<p>在iOS 7中，通过上面的方法来修改状态栏风格非常的棒。另外，我们也可以使用UIApplication的statusBarStyle方法来设置状态栏，不过，首先需要停止使用View controller-based status bar appearance。在project target的Info tab中，插入一个新的key，名字为View controller-based status bar appearance，并将其值设置为NO。</p>

<p>然后就可以使用下面的代码来设置状态栏风格了：</p>

<p><code>
[[UIApplication sharedApplication] setStatusBarStyle:UIStatusBarStyleLightContent];
</code></p>

<h3>隐藏状态栏</h3>

<p>有时候我们需要隐藏状态栏，那么此时我们在view controller中override方法prefersStatusBarHidden:即可，如下代码所示：</p>

<p>```
&ndash; (BOOL)prefersStatusBarHidden
{</p>

<pre><code>return YES; 
</code></pre>

<p>}
```</p>

<h3>总结</h3>

<p>iOS 7给开发者提供了一些新的自由度来定制导航栏和状态栏的外观。希望上面的这些技巧能对你有用。这里可以下载到<a href="https://dl.dropboxusercontent.com/u/2857188/NavigationBarDemo.zip">示例工程源码</a>。只需要取消相关代码注释即可进行测试。</p>

<p>来源：破船的博客
原文：<a href="http://www.appcoda.com/customize-navigation-status-bar-ios-7/">Customizing Navigation Bar and Status Bar in iOS 7</a></p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Does ARC support dispatch queues?]]></title>
    <link href="http://saick.net/blog/2013/12/01/does-arc-support-dispatch-queues/"/>
    <updated>2013-12-01T01:48:00+08:00</updated>
    <id>http://saick.net/blog/2013/12/01/does-arc-support-dispatch-queues</id>
    <content type="html"><![CDATA[<p><strong>If your deployment target is lower than iOS 6.0 or Mac OS X 10.8</strong></p>

<p>You need to use dispatch_retain and dispatch_release on your queue. ARC does not manage them.</p>

<p><strong>If your deployment target is iOS 6.0 or Mac OS X 10.8 or later</strong></p>

<p>ARC will manage your queue for you. You do not need to (and cannot) use dispatch_retain or dispatch_release if ARC is enabled.</p>

<!-- more -->


<p>Details</p>

<p>Starting in the iOS 6.0 SDK and the Mac OS X 10.8 SDK, every dispatch object (including a dispatch_queue_t) is also an Objective-C object. This is documented in the &lt;os/object.h> header file:</p>

<p><code>
 * By default, libSystem objects such as GCD and XPC objects are declared as
 * Objective-C types when building with an Objective-C compiler. This allows
 * them to participate in ARC, in RR management by the Blocks runtime and in
 * leaks checking by the static analyzer, and enables them to be added to Cocoa
 * collections.
 *
 * NOTE: this requires explicit cancellation of dispatch sources and xpc
 *       connections whose handler blocks capture the source/connection object,
 *       resp. ensuring that such captures do not form retain cycles (e.g. by
 *       declaring the source as __weak).
 *
 * To opt-out of this default behavior, add -DOS_OBJECT_USE_OBJC=0 to your
 * compiler flags.
 *
 * This mode requires a platform with the modern Objective-C runtime, the
 * Objective-C GC compiler option to be disabled, and at least a Mac OS X 10.8
 * or iOS 6.0 deployment target.
</code></p>

<p>This means you can store your queue in an NSArray or NSDictionary, or in a property with one of the strong, weak, unsafe_unretained, assign, or retain attributes. It also means that if you refer to your queue from a block, the block will retain the queue automatically.</p>

<p>So <strong>if your deployment target is at least iOS 6.0 or Mac OS X 10.8</strong>, and you have <em>ARC enabled</em>, ARC will retain and release your queue, and the compiler will flag any attempt to use dispatch_retain or dispatch_release as an error.</p>

<p><strong>If your deployment target is at least iOS 6.0 or Mac OS X 10.8</strong>, and you have <em>ARC disabled</em>, you must manually retain and release your queue, either by calling dispatch_retain and dispatch_release, or by sending the queue retain and release messages (like [queue retain] and [queue release]).</p>

<p>For compatibility with old codebases, you can prevent the compiler from seeing your queue as an Objective-C object by defining OS_OBJECT_USE_OBJC to 0. For example, you can put this in your .pch file (before any #import statements):</p>

<p>```</p>

<h1>define OS_OBJECT_USE_OBJC 0</h1>

<p>```</p>

<p>or you can add OS_OBJECT_USE_OBJC=0 as a preprocessor macro in your build settings. If you set OS_OBJECT_USE_OBJC to 0, ARC will not retain or release your queue for you, and you will have to do it yourself using dispatch_retain and dispatch_release.</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[iOS Crash:nested pop animation can result in corrupted navigation bar nested pop animation can result in ..]]></title>
    <link href="http://saick.net/blog/2013/12/01/ios-crash-nested-pop-animation-can-result-in-corrupted-navigation-bar-nested-pop-animation-can-result-in/"/>
    <updated>2013-12-01T01:37:00+08:00</updated>
    <id>http://saick.net/blog/2013/12/01/ios-crash-nested-pop-animation-can-result-in-corrupted-navigation-bar-nested-pop-animation-can-result-in</id>
    <content type="html"><![CDATA[<p><a href="http://yul100887.blog.163.com/blog/static/20033613520137205121620/">Origin</a></p>

<p>Nested pop animation can result in corrupted navigation bar</p>

<p>Finishing up a navigation transition in an unexpected state. Navigation Bar subview tree might get corrupted.</p>

<h3>【情况一】</h3>

<p>出现此问题的原因是在A界面弹出B界面完成后，又掉A界面POP出栈，这必然导致以上问题。如下，在弹出personalController后面，又在后面调用了[self.navigationController popViewControllerAnimated:YES];将自己弹出！解决方法，还用说吗？｛删除最后一行代码，要弹出此界面，自然有自己的返回按钮来处理｝，至少在B界面未POP以前，A界面是无论如何也不能将自己POP去消毁！</p>

<!-- more -->


<p><code>
NSString *memberId = [dictionary objectForKey:@"PlayerNo"];
PersonalInfoViewController* personalController = [[PersonalInfoViewController alloc] init];
[personalController.navigationItems etHidesBackButton:YES];
[personalController setMemberId:memberId];
[self.navigationController pushViewController:personalController animated:YES];
[personalController release];
[self.navigationController popViewControllerAnimated:YES];
</code></p>

<h3>【情况二】</h3>

<p>nested push animation can result in corrupted navigation bar <br/>
嵌套的navigation动画会造成  navigation bar 错误<br/>
具体表现为上一层的titleview 和这一层重叠， navigationbaritem维持上一层的左按钮,右按钮,系统警告提示nested push animation can result in corrupted navigation bar</p>

<p>从头到尾分析了整个项目的代码， 最后确认问题根源——<strong>自定义UITabbarController</strong>引发的血案
项目中使用了自定义的UITabbarController ，修改里面的tabbar视图， 在这个UITabbarController 中实现了viewWillAppear方法， 里面没有加super viewWillAppear ， 结果导致了这一连串的问题，</p>

<ul>
<li>整个软件里面，都会出现弹一次模态窗口，导航视图就会动画乱序，</li>
<li>导航视图前进后退过快， 导致导航栏嵌套， 一个上面覆盖另一个。</li>
</ul>


<p>```
&ndash; (void)viewWillAppear:(BOOL)animated
{</p>

<pre><code>[super viewWillAppear:animated];
</code></pre>

<p>}
```</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[iOS 7教程：浅析Text Kit]]></title>
    <link href="http://saick.net/blog/2013/11/23/ios-7jiao-cheng-qian-xi-text-kit/"/>
    <updated>2013-11-23T22:06:00+08:00</updated>
    <id>http://saick.net/blog/2013/11/23/ios-7jiao-cheng-qian-xi-text-kit</id>
    <content type="html"><![CDATA[<p>转自<a href="http://beyondvincent.com/blog/2013/11/12/121-brief-analysis-text-kit/">破船</a>的博客</p>

<p>Text Kit是iOS 7中引入的一个新功能，非常值得开发者使用，下面先看看本文的目录结构：</p>

<ul>
<li>什么是Text Kit</li>
<li>Text Kit架构</li>
<li>Text Kit特点</li>
<li>Text Kit功能概述</li>
<li>Text Kit中重要的一些对象</li>
<li>Text Kit示例</li>
<li>小结</li>
<li>推荐Text Kit学习资源</li>
</ul>


<!-- more -->


<h3>什么是Text Kit</h3>

<p>在iOS7中，苹果引入了Text Kit&mdash;Text Kit是一个快速而又现代化的文字排版和渲染引擎。Text Kit在UIKit framework中的定义了一些类和相关协议，它最主要的作用就是为程序提供文字排版和渲染的功能。在程序中，通过Text Kit可以对文字进行存储(store)、布局(lay out)，以及用最精细的排版方式(例如文字间距、换行和对齐等)来显示文本内容。 苹果引入Text Kit的目的并非要取代已有的Core Text，Core Text的主要作用也是用于文字的排版和渲染中，它是一种先进而又处于底层技术，如果我们需要将文本内容直接渲染到图形上下文(Graphics context)时，从性能和易用性来考虑，最佳方案就是使用Core Text。而如果我们直接利用苹果提供的一些控件(例如UITextView、UILabel和UITextField等)对文字进行排版，无疑就是借助于UIkit framework中Text Kit提供的API。</p>

<h3>Text Kit架构</h3>

<p>下面，我们通过图1(此图来自WWDC2013 Session 210)来了解一下Text Kit的架构。图1是基于iOS 7绘制的，从图中，我们可以看到Text Kit是基于Core Text构建的，它通过Core Text与Core Graphics进行交互。而UI控件(UILabel、UITextField和UITextView)则构建于Text Kit之上，可见这些文本控件可以利用Text Kit提供的API来对文字进行排版和渲染处理。 从图中我们也可以看到SDK提供的UIWebView是基于WebKit的，它不能使用Text Kit提供的功能。</p>

<p><a href="http://www.flickr.com/photos/105999540@N03/11028898935/" title="2013-11-24-1 by EricShj, on Flickr"><img src="http://farm8.staticflickr.com/7439/11028898935_e836a8c934.jpg" width="500" height="211" alt="2013-11-24-1"></a></p>

<p>图1 Text Kit在iOS 7 SDK中的位置</p>

<p>我们再来看看图1中的相关组件在iOS6里面是如何对应的，如图2所示，可以看出在iOS 6中是没有Text Kit，并且UILabel、UIText和UITextView是基于String Drawing和WebKit构建的。其中String Drawing是与Core Graphics直接通讯。</p>

<p><a href="http://www.flickr.com/photos/105999540@N03/11029000326/" title="2013-11-24-2 by EricShj, on Flickr"><img src="http://farm8.staticflickr.com/7430/11029000326_f1345af879.jpg" width="500" height="242" alt="2013-11-24-2"></a></p>

<p>图2 在iOS 6中并没有Text Kit</p>

<h3>Text Kit特点</h3>

<p>从上面的介绍中，我们可以了解到Text Kit在UIKit中的作用非常重要。Text Kit在实际开发中具有如下特点：</p>

<ul>
<li>1.在UI控件中Text Kit完全掌控着文字的排版和渲染</li>
<li>2.UITextView、UITextField和UILabel是构建于Text Kit之上的</li>
<li>3.能够与动画、UICollectionView和UITableView做到无缝集成</li>
<li>4.Text Kit具有这样一些能力：Subclassing、Delegation和Notifcation。</li>
</ul>


<h3>Text Kit功能概述</h3>

<p>下面我们看看通过Text Kit，都能实现那些功能(这里列出了是一些常用和重要功能)：</p>

<ul>
<li>1.对文字进行分页或多列排版</li>
<li>2.支持文字的换行、折叠和着色等处理</li>
<li>3.可以调整字与字之间的距离、行间距、文字大小、指定特定的字体</li>
<li>4.支持富文本编辑，可以自定义文字截断</li>
<li>5.支持凸版印刷效果(letterpress)</li>
<li>6.支持数据类型的检测(例如链接、附件等)</li>
</ul>


<p>如图3，是利用Text Kit对文字做的分页排版</p>

<p><a href="http://www.flickr.com/photos/105999540@N03/11028898985/" title="2013-11-24-3 by EricShj, on Flickr"><img src="http://farm8.staticflickr.com/7420/11028898985_e42af249cf.jpg" width="500" height="303" alt="2013-11-24-3"></a></p>

<p>图3 利用Text Kit做的分页排版效果</p>

<p>再看图4，是利用Text Kit做的换行处理，其中对某个路径范围做了排除。</p>

<p><a href="http://www.flickr.com/photos/105999540@N03/11029105983/" title="2013-11-24-4 by EricShj, on Flickr"><img src="http://farm6.staticflickr.com/5530/11029105983_dba9ffd9fb.jpg" width="500" height="359" alt="2013-11-24-4"></a></p>

<p>图4 利用Text Kit做的换行处理效果</p>

<p>再来看看利用Text Kit做的凸版印刷效果，如图5所示</p>

<p><a href="http://www.flickr.com/photos/105999540@N03/11029054444/" title="2013-11-24-5 by EricShj, on Flickr"><img src="http://farm3.staticflickr.com/2885/11029054444_fd67572185.jpg" width="500" height="365" alt="2013-11-24-5"></a></p>

<p>图5 利用Text Kit做的凸版印刷效果</p>

<h3>Text Kit中重要的一些对象</h3>

<p>下面我们来看看Text Kit中重要的几个对象。</p>

<p><a href="http://www.flickr.com/photos/105999540@N03/11029054134/" title="2013-11-24-6 by EricShj, on Flickr"><img src="http://farm3.staticflickr.com/2849/11029054134_87158b12d4.jpg" width="500" height="293" alt="2013-11-24-6"></a></p>

<p>图6 Text Kit中重要的几个对象</p>

<p>如图6所示，Text Kit中主要有4个重要的对象。</p>

<ul>
<li>1.Text View是用来显示文本内容的控件，主要包括UILabel、UITextView和UITextField。</li>
<li>2.Text containers对应着NSTextContainer类。NSTextContainer定义了文本可以排版的区域。一般来说，都是矩形区域，当然，也可以根据需求，通过子类化NSTextContainer来创建别的一些形状，例如圆形、不规则的形状等。NSTextContainer不仅可以创建文本可以填充的区域，它还维护着一个数组——该数组定义了一个区域，排版的时候文字不会填充该区域，因此，我们可以在排版文字的时候，填充非文本元素(例如图片，如图4所示)。</li>
<li>3.Layout manager对应着NSLayoutManager类。该类负责对文字进行编辑排版处理——通过将存储在NSTextStorage中的数据转换为可以在视图控件中显示的文本内容，并把统一的字符编码映射到对应的字形(glyphs)上，然后将字形排版到NSTextContainer定义的区域中。</li>
<li>4.Text storage对应着NSTextStorage类。该类定义了Text Kit扩展文本处理系统中的基本存储机制。NSTextStorage继承自NSmutableAttributedString，主要用来存储文本的字符和相关属性。另外，当NSTextStorage中的字符或属性发生了改变，会通知NSLayoutManager，进而做到文本内容的显示更新。</li>
</ul>


<p>通常情况下，NSTextStorage、NSLayoutManager和NSTextContainer是一一对应的。如图7所示关系：</p>

<p><a href="http://www.flickr.com/photos/105999540@N03/11028999346/" title="2013-11-24-7 by EricShj, on Flickr"><img src="http://farm4.staticflickr.com/3722/11028999346_3d78e9639e.jpg" width="500" height="41" alt="2013-11-24-7"></a></p>

<p>图7 普通排版</p>

<p>当然，如果需要将文字显示为多列，或多页，可以按照如图8所示关系——使用多个NSTextContainer。</p>

<p><a href="http://www.flickr.com/photos/105999540@N03/11029104793/" title="2013-11-24-8 by EricShj, on Flickr"><img src="http://farm6.staticflickr.com/5472/11029104793_ed7de38158.jpg" width="500" height="64" alt="2013-11-24-8"></a></p>

<p>图8 多页或者多列排版</p>

<p>如果针对不同的排版方式，则可以使用多个NSLayoutManager，如图9所示</p>

<p><a href="http://www.flickr.com/photos/105999540@N03/11029104933/" title="2013-11-24-9 by EricShj, on Flickr"><img src="http://farm4.staticflickr.com/3826/11029104933_824d194d5f.jpg" width="500" height="59" alt="2013-11-24-9"></a></p>

<p>图9 不同的排版方式</p>

<p>如图10所示，通过形象的方式，对UITextView的组成做了分解。通常，我们在设备上只能看到最右边的文本显示界面，而内部的NSTextStorage、NSLayoutManager和NSTextContainer是看不出来的。通常由NSLayoutManager从NSTextStorage中读取出文本数据，然后根据一定的排版方式，将文本排版到NSTextContainer中，再由NSTextContainer结合UITextView将最终效果显示出来。</p>

<p><a href="http://www.flickr.com/photos/105999540@N03/11029105053/" title="2013-11-24-10 by EricShj, on Flickr"><img src="http://farm8.staticflickr.com/7294/11029105053_875c954204.jpg" width="500" height="319" alt="2013-11-24-10"></a></p>

<p>图10 UITextView的分解</p>

<h3>Text Kit示例</h3>

<p>前面对Text Kit做了一些介绍，下面我们配合一个例子(图文排版)，来进一步加深对Text Kit的认识。具体实现步骤如下：</p>

<ul>
<li>1.打开Xcode 5，新建一个Single View Application模板的程序，将工程命名为ExclusionPath。</li>
<li>2.打开Main.storyboard文件，然后再默认View Controller的View里面分别添加一个UITextView和UIImageView。并将这两个控件连接到ViewController.h中(名称分别为textView何imageView)。然后给textView设置一些字符串，imageView设置一个图片。</li>
<li>3.打开ViewController.m文件，找到viewDidLoad方法，用如下代码替换该方法：</li>
</ul>


<p>```
&ndash; (void)viewDidLoad
{</p>

<pre><code>[super viewDidLoad]; 

//创建一个平移手势对象，该对象可以调用imagePanned：方法 
UIPanGestureRecognizer *panGes = [[UIPanGestureRecognizer alloc] initWithTarget:self action:@selector(imagePanned:)]; 
[self.imageView addGestureRecognizer:panGes]; 

self.textView.textContainer.exclusionPaths = @[[self translatedBezierPath]]; 
</code></pre>

<p>}
```</p>

<p>在上面的代码中，给imageView添加了一个平移手势。另外通过调用translatedBezierPath方法，给textView的textContainer设置exclusionPaths属性值。表示需要排除的区域（也就是图片在排版中显示的位置）。</p>

<ul>
<li>4.下面来看一下translatedBezierPath方法的实现，如下代码所示</li>
</ul>


<p>```
&ndash; (UIBezierPath *)translatedBezierPath
{</p>

<pre><code>CGRect butterflyImageRect = [self.textView convertRect:self.imageView.frame fromView:self.view]; 
UIBezierPath *newButterflyPath = [UIBezierPath bezierPathWithRect:butterflyImageRect]; 

return newButterflyPath; 
</code></pre>

<p>}
```</p>

<p>在上面的代码中，利用imageView的frame属性创建了一个UIBezierPath，然后将该值返回。</p>

<ul>
<li>5, 还记得第3步中创建的平移手势吗。里面有一个action需要实现imagePanned:，下面来看看这个方法的实现：</li>
</ul>


<p>```
&ndash; (void)imagePanned:(id)sender
{</p>

<pre><code>if ([sender isKindOfClass:[UIPanGestureRecognizer class]]) { 
    UIPanGestureRecognizer *localSender = sender; 

    if (localSender.state == UIGestureRecognizerStateBegan) { 
        self.gestureStartingPoint = [localSender translationInView:self.textView]; 
        self.gestureStartingCenter = self.imageView.center; 
    } else if (localSender.state == UIGestureRecognizerStateChanged) { 
        CGPoint currentPoint = [localSender translationInView:self.textView]; 

        CGFloat distanceX = currentPoint.x - self.gestureStartingPoint.x; 
        CGFloat distanceY = currentPoint.y - self.gestureStartingPoint.y; 

        CGPoint newCenter = self.gestureStartingCenter; 

        newCenter.x += distanceX; 
        newCenter.y += distanceY; 

        self.imageView.center = newCenter; 

        self.textView.textContainer.exclusionPaths = @[[self translatedBezierPath]]; 
    } else if (localSender.state == UIGestureRecognizerStateEnded) { 
        self.gestureStartingPoint = CGPointZero; 
        self.gestureStartingCenter = CGPointZero; 
    } 
} 
</code></pre>

<p>}
```</p>

<p>在上面的代码中首先根据平移的距离来设置imageView的位置，然后利用translatedBezierPath方法重新计算了一下排除区域。</p>

<ul>
<li>6, 至此代码编写完毕，下面来运行程序，看看实际效果。如图11所示：</li>
</ul>


<p><a href="http://www.flickr.com/photos/105999540@N03/11028998926/" title="2013-11-24-11 by EricShj, on Flickr"><img src="http://farm4.staticflickr.com/3709/11028998926_73393ee43a.jpg" width="332" height="500" alt="2013-11-24-11"></a></p>

<p>图11 运行效果</p>

<h3>小结</h3>

<p>实际上，上面的示例，只是揭秘了Text Kit功能的冰山一角。从iOS7及以后的版本中，Text Kit在UIKit framework里面占据重要的地位，Text Kit在文字处理方面，具有非常强大的功能，并且开发者可以对Text Kit进行定制和扩展。据悉，苹果利用了2年的时间来开发Text Kit，相信这对许多开发者来说都是福音。</p>

<p>推荐Text Kit学习资源
更多关于Text Kit的学习资料，请参考下面的内容：
wwdc视频:
Introducing Text Kit
Advanced Text Layouts and Effects with Text Kit
Using Fonts with Text Kit</p>

<p>苹果官方参考文档
Text Programming Guide for iOS.pdf
NSLayoutManager Class Reference for iOS.pdf
NSLayoutManagerDelegate Protocol Reference for iOS.pdf
NSTextContainer Class Reference for iOS.pdf
NSTextStorage Class Reference for iOS.pdf
NSTextStorageDelegate Protocol Reference for iOS.pdf</p>

<p>苹果官方示例：
IntroToTextKit</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Autolayout及VFL经验分享]]></title>
    <link href="http://saick.net/blog/2013/11/23/autolayoutji-vfljing-yan-fen-xiang/"/>
    <updated>2013-11-23T17:53:00+08:00</updated>
    <id>http://saick.net/blog/2013/11/23/autolayoutji-vfljing-yan-fen-xiang</id>
    <content type="html"><![CDATA[<p><a href="http://www.cocoachina.com/applenews/devnews/2013/1108/7322.html">Origin</a></p>

<p>这篇不是什么教程, Cocoa autolayout出来蛮久了。以前多次想去深入研究一下，每次都很蛋疼无序。这东西是在有些搞。尤其习惯了code写布局的。看到Visual format language，简直要掀桌子。搜教程，满世界都是，没有一个讲得透彻的。例子空洞。你们就只会３个控件横向布局对法？浑浑噩噩看了多篇。有了点总结。槽不多吐了。简单讲讲。</p>

<!--more-->


<h3>Autolayout，开始于iOS6.0</h3>

<h4>一.什么时候用autolayout比较适合</h4>

<ul>
<li>１.不负责任的骑墙派说法：apple的设备越来越多了，你的应用应该都使用al。（并且用sb）</li>
<li>２.要看应用内容决定。如果你的内容是信息众多，同时需要展示的类别也很多，尺寸动态不定，甚至这些是在列表中的。（如社交应用）。Al能给于很大的帮助。</li>
<li>３.Mac os的应用。现在都做iOS了。mac app的窗口，会有大小变化。al比较合适。</li>
<li>４.支持多向转屏的iPad应用。（有需要支持多方向iphone场景么？那么长，脑残了？）</li>
<li>５.其他业务不复杂,页面较少的应用，其实，cocoa程序员写了多年code都有自己的ui编程习惯，这些习惯对于他们来说是很高效的。就算是第一项所说，布局的坐标都是相对的。</li>
</ul>


<p>如果是习惯于code写布局的，建议可以继续沿用，同时也要学习al。自我感觉al和传统布局写法，工作量不会相差太多。但是VFL用熟练了以后会有很大的改善。</p>

<h4>二.autolayout的基础理论</h4>

<p>al的核心出发点是</p>

<ul>
<li>1.view具有自我计算尺寸，布局的能力。通过它自身的内容，能够得到尺寸。</li>
<li>2.view的布局位置，确定于它与superview及其他view的关系。</li>
<li>3.与传统的autoresizingmask自适应相比，al更精确，能绝对的确定view的布局。</li>
<li>4.view不一定需要一个初始的rect。al中，view如果有足够的constraint，便可以确定自己的尺寸和位置，并且知道自己和其他view的关系。即，想确定view的布局，就给它（们）添加constraint。</li>
</ul>


<h4>三.xib下的autolayout</h4>

<p>似乎al和xib布局模式生来就是要搞在一起的。用xib加al，view布局非常简单容易。编程工作立刻变成了美工的连线拼图游戏。</p>

<p>开启xib或者sb后，选择需要view(s)。选择menu的Editor，选择Pin。子菜单的项目就是可用的constraints。</p>

<p>Width:固定自身宽度</p>

<p>Height:。。。</p>

<p>H- Spacing: 固定两个view的水平间距</p>

<p>V- Spacing:。。。</p>

<p>下面４个分别是view相对于superview的左、右、上、下的间距</p>

<p>Widths Equally:两个view保持宽度相同</p>

<p>Heights Equally:。。。</p>

<p>xib界面右下角工具条也有可以编辑constraint的方式：</p>

<p>每个constraint添加后都是可以编辑的。选中某个constraint后开启右边栏选inspector。可以修改数值。（这个数值是view间的偏移量）和优先级。</p>

<p>自己慢慢拖着玩去。这不是傻瓜教程。点到位，自己研究。</p>

<p>xib下的al比较直观。可以基本看到效果和误差值。还有不正确的constraint的提示。少了constraint编译器会补，多了会提示报错。（不过都会引起界面布局不对，自己慢慢调吧，哥现在还是满篇alert，没有让编译器感觉矛盾费解的constraint，都是可以work的。）</p>

<p>还有resolve的方式解决constraint的问题，抱歉，我不会。</p>

<h4>四.编码方式使用autolayout</h4>

<p>对于页面不多，的普通应用。xib/sb加al。拖拖拽拽。娱乐中就可以完成UI的工作。al的确给于了不少方便。</p>

<p>不过多年的强迫症程序猿怎么会忍受这种很逊的方式。（拖积木？不敲代码？好像一天没做事。）</p>

<p>1.Visual format language　（应该不算语言）
Apple的工程师很有爱，发明了这种哭笑不得的象形文字。感觉它就是种解析方式。</p>

<p>Apple的官方文档给出了少之又少的文档和坑爹的例子。（视频我没看，不知道怎么样）网上的同学们也写了点不痛不痒的几句代码。你这是学了１＋１就让人搞微积分的节奏么？要写不写清楚，不如不写。</p>

<p>从厚道的老外那看了几篇。自己体会了些，分享给大家。只是个基本水平吧，会了这些，代码写al应该没有问题了。深入的我也还不会，希望遇到更有爱的牛人分享。</p>

<p>VFL在程序中由支持：</p>

<p><code>
+ (NSArray *)constraintsWithVisualFormat:(NSString *)format options:(NSLayoutFormatOptions)opts metrics:(NSDictionary *)metrics views:(NSDictionary *)views;   
</code></p>

<ul>
<li>它返回一组constraint.</li>
<li>format是你的VFL字串，等下讲。</li>
<li>opts自己点去头文件看。有些情况会用，等下有例子。</li>
<li>metrics是一个奇妙的字典，是你自己定义的。这个字典里面的key可以写在format字串中。编译器解析时，自动替换为metrics字典中的value。等下有例子。</li>
<li>views是需要constraint关系的所有view.(也可以是一个)</li>
</ul>


<p>2.VFL例子</p>

<p>写vfl字串的时候，脑海里要想象出画面的合理性。不合理的constraint会导致程序运行时报错或者直接崩溃。</p>

<p>随便写几个</p>

<p><code>
NSDictionary *dict1 = NSDictionaryOfVariableBindings(_boxV,_headerL,_imageV,_backBtn,_doneBtn);   
NSDictionary *metrics = @{@"hPadding":@5,@"vPadding":@5,@"imageEdge":@150.0};   
NSString *vfl = @"|-hPadding-[_boxV]-hPadding-|";   
NSString *vfl0 = @"V:|-25-[_boxV]";   
NSString *vfl3 = @"V:|-vPadding-[_headerL]-vPadding-[_imageV(imageEdge)]-vPadding-[_backBtn]-vPadding-|";   
</code></p>

<p>dict1就是api 中需要的最后一个参数views。由上述宏来完成。</p>

<p>metrics定义了一些vfl中要用的参数。
下面有些vfl字串，一看便知如何使用metrics。</p>

<p>看到：</p>

<p>1) &ldquo;|"表示superview. |-间距-[view1对象名]&ndash;(>=20)&ndash;[view2对象名] 不写H/V就表示横向，间距可以写固定值也可写>/&lt;。形象化的理解，&rdquo;|&ldquo;是用来确定view上、下、左、右关系的。 想要确定从上到下的关系，就加V:|。那么这个vfl字串就可以描述从上到下的view们的关系。</p>

<p>2) 看到vfl3里面，方括号表示view，圆括号表示尺寸数值。支持大小等于。或者另一个view　|&ndash;[view1(view2)]，v１的宽度等于v２。</p>

<p>3) 优先级用＠表示。如V:|-50@750-[view(55)]，或者写到metrics里面更好。 具体定义查看UILayoutPriority。有几个固定的数值。1000表示必须支持。</p>

<p>4) options，这个要看具体需要。如果是竖排V布局，可以添加NSLayoutFormatAlignAllLeft，让他们对齐。根据需要也可以添加按位或NSLayoutFormatAlignAllLeft | NSLayoutFormatAlignAllRight。（鬼知道什么需要，自己看经验吧）</p>

<p>5) 写好以后一般把constraint添加给superview：</p>

<p><code>
NSString *vfl1 = @"|-hPadding-[_headerL]-hPadding-|";   
[self.view addConstraints:[NSLayoutConstraint constraintsWithVisualFormat:vfl1 options:0 metrics:metrics views:dict1]];   
</code></p>

<p>6)还有一个api用于生成单个constaint</p>

<p><code>
+(id)constraintWithItem:(id)view1 attribute:(NSLayoutAttribute)attr1 relatedBy:(NSLayoutRelation)relation toItem:(id)view2 attribute:(NSLayoutAttribute)attr2 multiplier:(CGFloat)multiplier constant:(CGFloat)c;  
</code></p>

<p>对于参数，记得，view1.attr1 = view2.attr2 * multiplier + constant就好。
这个是不用VFL的，好理解，但是不方便。如果用这个写。工作两不会比传统布局少多少。</p>

<h4>五.实际操作中的问题</h4>

<p>上面都是理论，世界操作会有些奇怪的问题要注意。这节才是重点。</p>

<p>xib模式，没啥要注意的，xib里报warning就报吧，我也不知道怎么弄，一切正常就好。</p>

<p><strong>编码模式中，注意</strong></p>

<ul>
<li>1.addConstraint(s)前，view应该去部被addSubView上去了。</li>
<li>2.不必给views写frame</li>
<li>3.给必要的view关掉AutoresizeingMask。[_aView setTranslatesAutoresizingMaskIntoConstraints:NO];</li>
<li>4.UILabel换行要写linebreakMode,要写numberOfLines(iOS7.0默认好像是1，坑爹了)</li>
<li>5.UILabel要想换行，一定要添加preferredMaxLayoutWidth。否则没法初始化宽度。</li>
</ul>


<p>编码模式感受到的最大方便。label换行不用写行高计算了。完全自动适应。label所在的superview也会自动计算rect。这才是al的精华。</p>

<p>所以，可以不用写这些了：</p>

<p><div class='bogus-wrapper'><notextile><figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
<span class='line-number'>11</span>
<span class='line-number'>12</span>
<span class='line-number'>13</span>
<span class='line-number'>14</span>
<span class='line-number'>15</span>
<span class='line-number'>16</span>
<span class='line-number'>17</span>
<span class='line-number'>18</span>
<span class='line-number'>19</span>
<span class='line-number'>20</span>
<span class='line-number'>21</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>/*&lt;/p>
</span><span class='line'>
</span><span class='line'>&lt;pre>&lt;code>if([[UIDevice currentDevice].systemVersion floatValue]&lt;7.0){  
</span><span class='line'>    CGSize titleS = [title sizeWithFont:[_headerL font]  
</span><span class='line'>                       constrainedToSize:CGSizeMake(270.0, CGFLOAT_MAX)  
</span><span class='line'>                           lineBreakMode:NSLineBreakByWordWrapping];  
</span><span class='line'>
</span><span class='line'>    _headerL.frame = CGRectMake(_headerL.frame.origin.x, _headerL.frame.origin.y,  
</span><span class='line'>                                _headerL.frame.size.width, titleS.height);  
</span><span class='line'>}else{  
</span><span class='line'>    CGRect titleR = [title boundingRectWithSize:CGSizeMake(270.0, CGFLOAT_MAX)  
</span><span class='line'>                                        options:NSStringDrawingUsesLineFragmentOrigin  
</span><span class='line'>                                     attributes:nil  
</span><span class='line'>                                        context:nil];  
</span><span class='line'>    headerL.frame = CGRectMake(_headerL.frame.origin.x, _headerL.frame.origin.y,  
</span><span class='line'>                               _headerL.frame.size.width, titleR.size.height);  
</span><span class='line'>}  
</span><span class='line'>*/
</span><span class='line'>&lt;/code>&lt;/pre>
</span><span class='line'>
</span><span class='line'>&lt;p></span></code></pre></td></tr></table></div></figure></notextile></div></p>

<p>我遇到了些问题，至今没有解决：</p>

<p>纯代码写的Viewcontroller 无法正常显示al布局。用空白的xib做了vc后，其余再用code写，就正常了。怀疑自己写的self.view，还需要针对autolayout做什么处理。至此，al，基本功能已经可以为你服务了。的确方便很多，建议还是使用VFL代码模式，熟练后能够提高很多效率。</p>

<p>引用别的同学的评论：</p>

<p><em>最后一个问题：可以试一下self.view=自定义的视图； 不要用[self.view addSubview:&hellip;];</em></p>

<p><a href="https://www.dropbox.com/s/vizq53ig4e1z7io/20131123_AutoLayoutTest.zip">demo</a></p>
]]></content>
  </entry>
  
</feed>
