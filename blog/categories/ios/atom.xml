<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">

  <title><![CDATA[Category: iOS | Saick Blog - 专注技术，乐在其中]]></title>
  <link href="http://saick.net/blog/categories/ios/atom.xml" rel="self"/>
  <link href="http://saick.net/"/>
  <updated>2013-10-20T22:01:26+08:00</updated>
  <id>http://saick.net/</id>
  <author>
    <name><![CDATA[Eric Shi]]></name>
    
  </author>
  <generator uri="http://octopress.org/">Octopress</generator>

  
  <entry>
    <title type="html"><![CDATA[iOS ARC 兼容处理]]></title>
    <link href="http://saick.net/blog/2013/10/19/ios-arc-jian-rong-chu-li/"/>
    <updated>2013-10-19T01:56:00+08:00</updated>
    <id>http://saick.net/blog/2013/10/19/ios-arc-jian-rong-chu-li</id>
    <content type="html"><![CDATA[<p>From:宋红日（转自：<a href="http://blog.sina.com.cn/s/blog_9792a85b01018v83.html%EF%BC%89">http://blog.sina.com.cn/s/blog_9792a85b01018v83.html%EF%BC%89</a></p>

<p>我们经常在引用第三方控件或者阅读一个开源的代码的时候，与自己的xcode 的开发环境不一样，导致编译不过的问题，还得改代码，带来了一定的工作量。其实有一下方法做到兼容处理。统一用下面定义的宏就可以。
尤其当你决定做一个通用的控件 或 模块的时候。</p>

<p>```
// ARC conditions</p>

<h1>if !__has_feature(objc_arc)</h1>

<h1>define Release(obj) [obj release]</h1>

<h1>define Retain(obj) [obj retain]</h1>

<h1>else</h1>

<h1>define Release(obj)</h1>

<h1>define Retain(obj) obj</h1>

<h1>endif</h1>

<p>```</p>

<p>另外，如果是ARC工程，某些文件不支持ARC的话，可以在Target->Build Phases->Complie sources 中对某个文件加入Complier Flags “-fno-objc-arc”</p>

<p>如下图：</p>

<p><a href="http://www.flickr.com/photos/105999540@N03/10374769035/" title="2013-10-19-1 by EricShj, on Flickr"><img src="http://farm8.staticflickr.com/7294/10374769035_c11c167c38_z.jpg" width="640" height="237" alt="2013-10-19-1"></a></p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[iOS Cookie使用]]></title>
    <link href="http://saick.net/blog/2013/10/19/ios-cookieshi-yong/"/>
    <updated>2013-10-19T01:08:00+08:00</updated>
    <id>http://saick.net/blog/2013/10/19/ios-cookieshi-yong</id>
    <content type="html"><![CDATA[<p>转自：<a href="http://geeklu.com/2013/04/ios-cookie/">http://geeklu.com/2013/04/ios-cookie/</a></p>

<p>关于Cookie的标准和原理这里就不细说了，这里只说说在iOS平台下如何进行Cookie相关的编程。
和Mac上不同，在iOS平台上各个App都有自己的Cookie，App之间不共享Cookie。
一个Cookie对应一个NSHTTPCookie实体，并通过NSHTTPCookieStorage进行管理。
那些需要持久化的Cookie是存放在 ~/Library/Cookies/Cookies.binarycookies 文件中的，二进制格式。</p>

<p>Cookie生成的有两个途径，一个是访问一个网页，这个网页返回的HTTP Header中有Set-Cookie指令进行Cookie的设置，这里Cookie的本地处理其实是由WebKit进行的；还有一种途径就是客户端通过代码手动设置Cookie。</p>

<p><code>
NSMutableDictionary *cookieProperties = [NSMutableDictionary dictionary];[cookieProperties setObject:@"name" forKey:NSHTTPCookieName];
[cookieProperties setObject:@"value" forKey:NSHTTPCookieValue];
[cookieProperties setObject:@"www.taobao.com" forKey:NSHTTPCookieDomain];[cookieProperties setObject:@"/" forKey:NSHTTPCookiePath];
[cookieProperties setObject:@"0" forKey:NSHTTPCookieVersion];
[cookieProperties setObject:@"30000" forKey:NSHTTPCookieMaximumAge];
NSHTTPCookie *cookie = [NSHTTPCookie cookieWithProperties:cookieProperties];
[[NSHTTPCookieStorage sharedHTTPCookieStorage] setCookie:cookie];
//删除cookie的方法为deleteCookie:
</code></p>

<p>在通过setCookie:进行设置cookie的时候，会覆盖name,domain,path都相同的cookie的。
至于cookie会不会持久化到cookie文件中主要看这个cookie的生命周期，和Max-Age或者Expires有关。</p>

<p>不过NSHTTPCookieStorage存在一个问题，setCookie或者deleteCookie后并不会立即进行持久化，而是有几秒的延迟。如果在持久化之前App接收到SIGKILL信号，App退出，那么会导致cookie相关操作的丢失。在模拟器调试的过程中，XCode重启App的时发给App的就是SIGKILL，不过真正的生产环境中很少有这种情况。
但是有时候为了可靠性，我们还是会将cookie信息保存一份到User Defaults，需要用的时候load进来。关于cookie操作丢失的详情可以查看这里<a href="http://openradar.appspot.com/radar?id=2776403">NSHTTPCookieStorage looses cookies on SIGKILL</a></p>

<p>卢克 / 2013-04-02</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[iOS库添加CocoaPods支持]]></title>
    <link href="http://saick.net/blog/2013/10/17/iosku-tian-jia-cocoapodszhi-chi/"/>
    <updated>2013-10-17T15:30:00+08:00</updated>
    <id>http://saick.net/blog/2013/10/17/iosku-tian-jia-cocoapodszhi-chi</id>
    <content type="html"><![CDATA[<p>现在CocoaPods如此方便（虽然可能也有它的缺点），但是很多开源库，自己写的库并没有对它进行支持，特研究了一下，分享给大家。</p>

<h3>准备好库代码（GitHub上）</h3>

<p>将代码Checkout下来，打开命令行，cd到代码根目录</p>

<h3>创建XXXX.podspec</h3>

<p><code>
pod spec create XXXX
</code></p>

<h3>编辑XXXX.podspec</h3>

<p>创建好的文件里有很多指引，这步很简单。 实在不明白，再看看GitHub上别的库的spec文件怎么写的。</p>

<h3>验证合法性</h3>

<p><code>
pod spec lint XXXX.podspec
</code></p>

<p>完成后即可把这个文件提交到<a href="https://github.com/CocoaPods/Specs">CocoaPods specs</a>中。</p>

<p>When you&rsquo;re done you can also fork the <a href="https://github.com/CocoaPods/Specs">CocoaPods specs</a>  GitHub repository and send a pull request. We really love contributions and will help ensure it&rsquo;s perfect!</p>

<h3>详细提交步骤</h3>

<p>From：<a href="http://docs.cocoapods.org/guides/contributing_to_the_master_repo.html">http://docs.cocoapods.org/guides/contributing_to_the_master_repo.html</a></p>

<h3>Contributing to the master repo</h3>

<p>The master repo contains specifications of open-source Objective-C libraries.</p>

<h4>Details</h4>

<ul>
<li> installation path: ~/.cocoapods/master</li>
<li> home: <a href="https://github.com/CocoaPods/Specs">https://github.com/CocoaPods/Specs</a></li>
</ul>


<h4>Contributing</h4>

<p>To ensure a high quality, reliable collection of Pods, the master repo is strict about the acceptable specifications. The CocoaPods linter (see the pod spec lint command) is used to validate specifications, and no errors or warnings are accepted.
The highest priority of the master repo is to guarantee the integrity of existing CocoaPods installations.
In general this means that:</p>

<ul>
<li> A specification cannot be deleted.</li>
<li> Specifications can be updated only if they don’t affect existing installations.</li>
<li><ul>
<li>Broken specifications can be updated.</li>
<li>Subspecs can be added as they are included by the parent specification by default.</li>
</ul>
</li>
<li> Only authoritative version numbers are accepted.</li>
</ul>


<p>CocoaPods uses a versioning scheme known as Semantic Versioning, necessary for cross resolution of dependencies.</p>

<h4>Unversioned libraries</h4>

<p>One of the CocoaPods goals is to promote the discovery of open-source software, for this reason new Pods for libraries which are not versioned are accepted in the master repo. The specifications of those pods should carry the version 0.0.1 under the assumption that, if the author starts versioning, she/he is unlikely to pick 0.0.1. This is the only exception for authoritative version numbers.
If you add an unversioned Pod it is your responsibility to ask the author of the library to tag versions, luckily we have a template for this.
To prevent collisions with possible future versions, unversioned libraries can’t be updated until the author starts to tag them.
If you need to update an unversioned library you can:</p>

<ul>
<li> Ask the author to version the library.</li>
<li> Maintain a fork which is versioned. This fork should be clearly namespaced from the original library according the NAME@USERconvention (e.g. Reachability@irrationalfab). It should also mention in the summary that it is a versioned fork.</li>
<li> Create a podspec and use it in a private repo.</li>
</ul>


<h4>Creating podspecs</h4>

<p>Creating a podspec is very easy as we provide templates full of examples.
You can use the following command:</p>

<p><code>
$ pod spec create Bananas
</code></p>

<p>If the library is hosted on GitHub you can pass the url so CocoaPods can precompile the template:</p>

<p><code>
$ pod spec create https://github.com/Bananas/Bananas
</code></p>

<p>A this point you need edit compile the template (a pod specification is a Ruby source file):</p>

<p><code>
$ pod spec lint Bananas.podspec --verboseSharing podspecs
</code></p>

<h4>Sharing podspecs</h4>

<p>When a podspec lints you can submit it to the master repo.</p>

<h4>Without push access</h4>

<p>You need to fork the master repo on github, then you need to:</p>

<p><code>
$ cd ~/.cocoapods/master
$ git checkout -b fork
$ git remote add myfork https://github.com/YOUR_USER_NAME/Specs.git
$ cp ~/Bananas.podspec ~/.cocoapods/master/Bananas/VERSION/
$ git push myfork
$ git checkout master
</code></p>

<p>Once you push your changes, you can make a pull request on CocoaPods/Specs.
With push access</p>

<p><code>
$ pod push Bananas.podspec
</code></p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[iOS应用处理崩溃的几种方法]]></title>
    <link href="http://saick.net/blog/2013/10/16/iosying-yong-chu-li-beng-kui-de-ji-chong-fang-fa/"/>
    <updated>2013-10-16T23:31:00+08:00</updated>
    <id>http://saick.net/blog/2013/10/16/iosying-yong-chu-li-beng-kui-de-ji-chong-fang-fa</id>
    <content type="html"><![CDATA[<p>在开发IOS app的过程中,XCode在遇到程序崩溃时打印的信息一般时比较少的。
在iOS7时，这个情况好像有些一些变化，但不太明确，也不太稳定。</p>

<h3>1.在XCode中使用一个通用断点</h3>

<p>在XCode中打开工程，在左边的工程导航栏中选中断点,点击下放的＋号,选择“Add Exception BreakPoint”。点done即可。</p>

<h3>2.开启NSZombieEnabled等调试选项</h3>

<p>XCode->Product->Scheme->Edit Scheme->Run XXX.app->Arguments
在Environment Variables中增加下面属性并都配置为YES。</p>

<p><code>
MallocStackLogging
MallocStackLoggingNoCompact
NSAutoreleaseFreedObjectCheckEnabled
NSDebugEnabled
NSZombieEnabled
</code></p>

<p>在实际使用中发现，使用了上述配置之后，如果能在模拟器上运行效果更佳。比如,真机调试时遇到过如下错误：</p>

<p><code>
-[CALayer retain]: message sent to deallocated instance 0x1d418a30
</code></p>

<p>使用网上很多地方都提到的方法：</p>

<p><code>
info malloc-history 0x1d418a30
XCode提示:Undefined info command: "malloc-history".  Try "help info".
</code>
针对这种情况可以参考:<a href="http://stackoverflow.com/questions/3851565/using-gdb-info-malloc-command-within-xcode-iphone-dev,%E9%87%8C%E9%9D%A2%E5%B0%B1%E8%AF%B4%E6%88%91%E4%BB%AC%E5%BA%94%E8%AF%A5%E5%9C%A8%E6%A8%A1%E6%8B%9F%E5%99%A8%E4%B8%AD%E4%BD%BF%E7%94%A8%E7%B1%BB%E4%BC%BCmalloc-history%E7%9A%84gdb%E8%B0%83%E8%AF%95%E5%8A%9F%E8%83%BD%E3%80%82">http://stackoverflow.com/questions/3851565/using-gdb-info-malloc-command-within-xcode-iphone-dev,%E9%87%8C%E9%9D%A2%E5%B0%B1%E8%AF%B4%E6%88%91%E4%BB%AC%E5%BA%94%E8%AF%A5%E5%9C%A8%E6%A8%A1%E6%8B%9F%E5%99%A8%E4%B8%AD%E4%BD%BF%E7%94%A8%E7%B1%BB%E4%BC%BCmalloc-history%E7%9A%84gdb%E8%B0%83%E8%AF%95%E5%8A%9F%E8%83%BD%E3%80%82</a></p>

<p><strong>其中最主要的还是</strong> <em>NSZombieEnabled</em>, 这个解决EXC_BAD_ACCESS还是很有用的。
具体参考这个：<a href="http://www.cocoachina.com/macdev/objc/2011/0219/2661.html">http://www.cocoachina.com/macdev/objc/2011/0219/2661.html</a></p>

<h3>3.增加异常处理[理论上和"在XCode中使用一个通用断点"效果类似]</h3>

<p>写iOS代码的时候,经常会遇到程序崩溃在main函数的入口处并出现类似"First throw call stack"这样的错误。为了更好的知道崩溃的原因,我们可以在AppDelegate中定义一个方法, 用于处理异常:</p>

<p>```
void caughtException(NSException *exception)
{</p>

<pre><code>NSLog(@"CRASH: %@", exception);  
NSLog(@"Stack Trace: %@", [exception callStackSymbols]);  
// Internal error reporting 
</code></pre>

<p>}
```
另外，在打印时，也可以使用GTM，GTMStackTraceFromException(exception)，跟系统的类似。</p>

<p>然后在应用启动时，设置这个方法作为自己的自定义异常回调：</p>

<p>```
&ndash; (BOOL)application:(UIApplication <em>)application didFinishLaunchingWithOptions:(NSDictionary </em>)launchOptions
{</p>

<pre><code>NSSetUncaughtExceptionHandler(&amp; caughtException); 
</code></pre>

<p>}
```
在定义了这个回调之后，崩溃是的控制台信息一般都会一目了然，我们甚至可以看出是那个类的哪一行出问题了。</p>

<h3>4.signal处理，并提示。</h3>

<p>启动信号处理</p>

<p>```</p>

<pre><code>signal(SIGABRT, signalHandler);
signal(SIGILL, signalHandler);
signal(SIGSEGV, signalHandler);
signal(SIGFPE, signalHandler);
signal(SIGBUS, signalHandler);
signal(SIGPIPE, signalHandler);
</code></pre>

<p>```</p>

<p>其它相关代码
<div class='bogus-wrapper'><notextile><figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
<span class='line-number'>11</span>
<span class='line-number'>12</span>
<span class='line-number'>13</span>
<span class='line-number'>14</span>
<span class='line-number'>15</span>
<span class='line-number'>16</span>
<span class='line-number'>17</span>
<span class='line-number'>18</span>
<span class='line-number'>19</span>
<span class='line-number'>20</span>
<span class='line-number'>21</span>
<span class='line-number'>22</span>
<span class='line-number'>23</span>
<span class='line-number'>24</span>
<span class='line-number'>25</span>
<span class='line-number'>26</span>
<span class='line-number'>27</span>
<span class='line-number'>28</span>
<span class='line-number'>29</span>
<span class='line-number'>30</span>
<span class='line-number'>31</span>
<span class='line-number'>32</span>
<span class='line-number'>33</span>
<span class='line-number'>34</span>
<span class='line-number'>35</span>
<span class='line-number'>36</span>
<span class='line-number'>37</span>
<span class='line-number'>38</span>
<span class='line-number'>39</span>
<span class='line-number'>40</span>
<span class='line-number'>41</span>
<span class='line-number'>42</span>
<span class='line-number'>43</span>
<span class='line-number'>44</span>
<span class='line-number'>45</span>
<span class='line-number'>46</span>
<span class='line-number'>47</span>
<span class='line-number'>48</span>
<span class='line-number'>49</span>
<span class='line-number'>50</span>
<span class='line-number'>51</span>
<span class='line-number'>52</span>
<span class='line-number'>53</span>
<span class='line-number'>54</span>
<span class='line-number'>55</span>
<span class='line-number'>56</span>
<span class='line-number'>57</span>
<span class='line-number'>58</span>
<span class='line-number'>59</span>
<span class='line-number'>60</span>
<span class='line-number'>61</span>
<span class='line-number'>62</span>
<span class='line-number'>63</span>
<span class='line-number'>64</span>
<span class='line-number'>65</span>
<span class='line-number'>66</span>
<span class='line-number'>67</span>
<span class='line-number'>68</span>
<span class='line-number'>69</span>
<span class='line-number'>70</span>
<span class='line-number'>71</span>
<span class='line-number'>72</span>
<span class='line-number'>73</span>
<span class='line-number'>74</span>
<span class='line-number'>75</span>
<span class='line-number'>76</span>
<span class='line-number'>77</span>
<span class='line-number'>78</span>
<span class='line-number'>79</span>
<span class='line-number'>80</span>
<span class='line-number'>81</span>
<span class='line-number'>82</span>
<span class='line-number'>83</span>
<span class='line-number'>84</span>
<span class='line-number'>85</span>
<span class='line-number'>86</span>
<span class='line-number'>87</span>
<span class='line-number'>88</span>
<span class='line-number'>89</span>
<span class='line-number'>90</span>
<span class='line-number'>91</span>
<span class='line-number'>92</span>
<span class='line-number'>93</span>
<span class='line-number'>94</span>
<span class='line-number'>95</span>
<span class='line-number'>96</span>
<span class='line-number'>97</span>
<span class='line-number'>98</span>
<span class='line-number'>99</span>
<span class='line-number'>100</span>
<span class='line-number'>101</span>
<span class='line-number'>102</span>
<span class='line-number'>103</span>
<span class='line-number'>104</span>
<span class='line-number'>105</span>
<span class='line-number'>106</span>
<span class='line-number'>107</span>
<span class='line-number'>108</span>
<span class='line-number'>109</span>
<span class='line-number'>110</span>
<span class='line-number'>111</span>
<span class='line-number'>112</span>
<span class='line-number'>113</span>
<span class='line-number'>114</span>
<span class='line-number'>115</span>
<span class='line-number'>116</span>
<span class='line-number'>117</span>
<span class='line-number'>118</span>
<span class='line-number'>119</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>&lt;/p>
</span><span class='line'>
</span><span class='line'>&lt;h1>include &lt;libkern/OSAtomic.h>&lt;/h1>
</span><span class='line'>
</span><span class='line'>&lt;h1>include &lt;execinfo.h>&lt;/h1>
</span><span class='line'>
</span><span class='line'>&lt;p>NSString * const UncaughtExceptionHandlerSignalExceptionName = @&ldquo;UncaughtExceptionHandlerSignalExceptionName&rdquo;;
</span><span class='line'>NSString * const UncaughtExceptionHandlerSignalKey = @&ldquo;UncaughtExceptionHandlerSignalKey&rdquo;;
</span><span class='line'>NSString * const UncaughtExceptionHandlerAddressesKey = @&ldquo;UncaughtExceptionHandlerAddressesKey&rdquo;;&lt;/p>
</span><span class='line'>
</span><span class='line'>&lt;p>volatile int32_t UncaughtExceptionCount = 0;
</span><span class='line'>const int32_t UncaughtExceptionMaximum = 10;
</span><span class='line'>const NSInteger UncaughtExceptionHandlerSkipAddressCount = 0;
</span><span class='line'>const NSInteger UncaughtExceptionHandlerReportAddressCount = 100;&lt;/p>
</span><span class='line'>
</span><span class='line'>&lt;ul>
</span><span class='line'>&lt;li>&lt;p>(NSArray &lt;em>)backTrace
</span><span class='line'>{
</span><span class='line'>void&lt;/em> callstack[1024];
</span><span class='line'>int frames = backtrace(callstack, 1024);
</span><span class='line'>char **strs = backtrace_symbols(callstack, frames);&lt;/p>
</span><span class='line'>
</span><span class='line'>&lt;p>int i;
</span><span class='line'>NSMutableArray *backtrace = [NSMutableArray arrayWithCapacity:frames];
</span><span class='line'>for (i = UncaughtExceptionHandlerSkipAddressCount;
</span><span class='line'>     i &lt; UncaughtExceptionHandlerSkipAddressCount + UncaughtExceptionHandlerReportAddressCount;
</span><span class='line'>     i++)
</span><span class='line'>{
</span><span class='line'>  if (frames &lt;= i)
</span><span class='line'>    break;
</span><span class='line'>  [backtrace addObject:[NSString stringWithUTF8String:strs[i]]];
</span><span class='line'>}&lt;/p>
</span><span class='line'>
</span><span class='line'>&lt;p>free(strs);&lt;/p>
</span><span class='line'>
</span><span class='line'>&lt;p>return backtrace;
</span><span class='line'>}&lt;/p>&lt;/li>
</span><span class='line'>&lt;li>&lt;p>(void)alertView:(UIAlertView *)anAlertView clickedButtonAtIndex:(NSInteger)anIndex
</span><span class='line'>{
</span><span class='line'>if (anIndex == 0) {
</span><span class='line'>  _dismissed = YES;
</span><span class='line'>}
</span><span class='line'>}&lt;/p>&lt;/li>
</span><span class='line'>&lt;li>&lt;p>(void)handleException:(NSException &lt;em>)exception
</span><span class='line'>{
</span><span class='line'>UIAlertView &lt;/em>alert = [[UIAlertView alloc] initWithTitle:NSLocalizedString(@&ldquo;Unhandled exception&rdquo;, nil)
</span><span class='line'>                                                message:[NSString stringWithFormat:NSLocalizedString(@&ldquo;You can try to continue but the application may be unstable.\n&rdquo; @&ldquo;%@\n%@&rdquo;, nil), [exception reason], [[exception userInfo] objectForKey:UncaughtExceptionHandlerAddressesKey]]
</span><span class='line'>                                               delegate:self
</span><span class='line'>                                      cancelButtonTitle:NSLocalizedString(@&ldquo;Quit&rdquo;, nil)
</span><span class='line'>                                      otherButtonTitles:NSLocalizedString(@&ldquo;Continue&rdquo;, nil), nil];&lt;/p>
</span><span class='line'>
</span><span class='line'>&lt;p>[alert show];&lt;/p>
</span><span class='line'>
</span><span class='line'>&lt;p>CFRunLoopRef runLoop = CFRunLoopGetCurrent();
</span><span class='line'>CFArrayRef allModes = CFRunLoopCopyAllModes(runLoop);&lt;/p>
</span><span class='line'>
</span><span class='line'>&lt;p>while (!_dismissed) {
</span><span class='line'>  for (NSString &lt;em>mode in (NSArray &lt;/em>)CFBridgingRelease(allModes)) {
</span><span class='line'>    CFRunLoopRunInMode((CFStringRef)CFBridgingRetain(mode), 0.001, false);
</span><span class='line'>  }
</span><span class='line'>}&lt;/p>
</span><span class='line'>
</span><span class='line'>&lt;p>CFRelease(allModes);&lt;/p>
</span><span class='line'>
</span><span class='line'>&lt;p>NSString *log = [NSString stringWithFormat:@&ldquo;%@\n\n info:\n%@&rdquo;, exception, exception.userInfo];
</span><span class='line'>[[DebugUtil sharedDebug] LogException:log];&lt;/p>
</span><span class='line'>
</span><span class='line'>&lt;p>NSSetUncaughtExceptionHandler(NULL);
</span><span class='line'>signal(SIGABRT, SIG_DFL);
</span><span class='line'>signal(SIGILL, SIG_DFL);
</span><span class='line'>signal(SIGSEGV, SIG_DFL);
</span><span class='line'>signal(SIGFPE, SIG_DFL);
</span><span class='line'>signal(SIGBUS, SIG_DFL);
</span><span class='line'>signal(SIGPIPE, SIG_DFL);&lt;/p>
</span><span class='line'>
</span><span class='line'>&lt;p>if ([[exception name] isEqual:UncaughtExceptionHandlerSignalExceptionName]) {
</span><span class='line'>  kill(getpid(), [[[exception userInfo] objectForKey:UncaughtExceptionHandlerSignalKey] intValue]);
</span><span class='line'>} else {
</span><span class='line'>  [exception raise];
</span><span class='line'>}
</span><span class='line'>}&lt;/p>&lt;/li>
</span><span class='line'>&lt;/ul>
</span><span class='line'>
</span><span class='line'>
</span><span class='line'>&lt;p>NSString * getAppInfo()
</span><span class='line'>{
</span><span class='line'>  NSString *appInfo = [NSString stringWithFormat:@&ldquo;App : %@ %@(%@)\nDevice : %@\nOS Version : %@ %@\nUDID : %@\n&rdquo;,&lt;/p>
</span><span class='line'>
</span><span class='line'>&lt;pre>&lt;code>                   [[NSBundle mainBundle] objectForInfoDictionaryKey:@"CFBundleDisplayName"],
</span><span class='line'>                   [[NSBundle mainBundle] objectForInfoDictionaryKey:@"CFBundleShortVersionString"],
</span><span class='line'>                   [[NSBundle mainBundle] objectForInfoDictionaryKey:@"CFBundleVersion"],
</span><span class='line'>                   [UIDevice currentDevice].model,
</span><span class='line'>                   [UIDevice currentDevice].systemName,
</span><span class='line'>                   [UIDevice currentDevice].systemVersion,
</span><span class='line'>                   /*[UIDevice currentDevice].uniqueIdentifier*/@""];
</span><span class='line'>&lt;/code>&lt;/pre>
</span><span class='line'>
</span><span class='line'>&lt;p>  return appInfo;
</span><span class='line'>}&lt;/p>
</span><span class='line'>
</span><span class='line'>&lt;p>void signalHandler(int signal)
</span><span class='line'>{
</span><span class='line'>  int32_t exceptionCount = OSAtomicIncrement32(&amp;UncaughtExceptionCount);&lt;/p>
</span><span class='line'>
</span><span class='line'>&lt;p>  if (exceptionCount > UncaughtExceptionMaximum) {&lt;/p>
</span><span class='line'>
</span><span class='line'>&lt;pre>&lt;code>return;
</span><span class='line'>&lt;/code>&lt;/pre>
</span><span class='line'>
</span><span class='line'>&lt;p>  }&lt;/p>
</span><span class='line'>
</span><span class='line'>&lt;p>  NSMutableDictionary *userInfo = [NSMutableDictionary dictionaryWithObject:[NSNumber numberWithInt:signal] forKey:UncaughtExceptionHandlerSignalKey];&lt;/p>
</span><span class='line'>
</span><span class='line'>&lt;p>  NSArray *callStack = [DebugUtil backTrace];&lt;/p>
</span><span class='line'>
</span><span class='line'>&lt;p>  [userInfo setObject:callStack forKey:UncaughtExceptionHandlerAddressesKey];&lt;/p>
</span><span class='line'>
</span><span class='line'>&lt;p>  [[[DebugUtil alloc] init] performSelectorOnMainThread:@selector(handleException:) withObject: [NSException exceptionWithName:UncaughtExceptionHandlerSignalExceptionName reason:[NSString stringWithFormat: NSLocalizedString(@&ldquo;Signal %d was raised.\n&rdquo; @&ldquo;%@&rdquo;, nil), signal, getAppInfo()] userInfo:userInfo] waitUntilDone:YES];
</span><span class='line'>}</span></code></pre></td></tr></table></div></figure></notextile></div></p>

<p>第4部分 原文：<a href="http://www.cocoachina.com/newbie/tutorial/2012/0829/4672.html">http://www.cocoachina.com/newbie/tutorial/2012/0829/4672.html</a></p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[在应用中从竖屏模式强制转换为横屏模式 & 状态栏白边问题]]></title>
    <link href="http://saick.net/blog/2013/10/14/zai-ying-yong-zhong-cong-shu-ping-mo-shi-qiang-zhi-zhuan-huan-wei-heng-ping-mo-shi/"/>
    <updated>2013-10-14T16:28:00+08:00</updated>
    <id>http://saick.net/blog/2013/10/14/zai-ying-yong-zhong-cong-shu-ping-mo-shi-qiang-zhi-zhuan-huan-wei-heng-ping-mo-shi</id>
    <content type="html"><![CDATA[<h4>序：状态栏白边问题解决</h4>

<p>在旋转前，先隐藏掉状态栏，再设置相关的Frame。（别犯低级错误即可）</p>

<p>在 iPhone 应用里，有时我们想强行把显示模式从纵屏改为横屏（反之亦然），CocoaChina 会员 “alienblue” 为我们提供了两种思路</p>

<h3>第一种：通过人为的办法改变view.transform的属性。</h3>

<p>具体办法：</p>

<p><code>view.transform</code>一般是View的旋转，拉伸移动等属性，类似<code>view.layer.transform</code>，区别在于<code>view.transform</code>是二维的，也就是使用仿射的办法通常就是带有前缀CGAffineTransform的类（可以到API文档里面搜索这个前缀的所有类），而<code>view.layer.transform</code>可以在3D模式下面的变化，通常使用的都是前缀为CATransform3D的类。</p>

<p>   这里要记住一点，当你改变过一个<code>view.transform</code>属性或者<code>view.layer.transform</code>的时候需要恢复默认状态的话，记得先把他们重置可以使用<code>view.transform = CGAffineTransformIdentity</code>，或者<code>view.layer.transform = CATransform3DIdentity</code>，假设你一直不断的改变一个<code>view.transform</code>的属性，而每次改变之前没有重置的话，你会发现后来的改变和你想要的发生变化了，不是你真正想要的结果。</p>

<p>   好了，上面介绍了旋转的属性，接下来就是关键了。官方提供了一个办法就是查看当前电池条的状态<code>UIInterfaceOrientation orientation = [UIApplication sharedApplication].statusBarOrientation;</code>通过这个办法，你可以知道当前屏幕的电池条的显示方向，而且你还可以强制设置他的显示方向，通过设置这个属性就OK了，可以选择是否动画改变电池条方向。有了这两个那我们就可以任意的改变我们想要的显示方式了。</p>

<ul>
<li>1.获取当前电池条的方向</li>
</ul>


<p><code>
UIInterfaceOrientation orientation = [UIApplication sharedApplication].statusBarOrientation
</code></p>

<ul>
<li>2.获取当前屏幕的大小</li>
</ul>


<p><code>
CGRect frame = [UIScreen mainScreen].applicationFrame;
</code></p>

<ul>
<li>3.设置我们的View的中心点</li>
</ul>


<p>```</p>

<pre><code>CGPoint center = CGPointMake(frame.origin.x + ceil(frame.size.width/2), frame.origin.y + ceil(frame.size.height/2));
</code></pre>

<p>```</p>

<ul>
<li>4.根据当前电池条的方向，获取需要旋转的角度的大小。通常</li>
</ul>


<p>```</p>

<pre><code>if (orientation == UIInterfaceOrientationLandscapeLeft) {
    return CGAffineTransformMakeRotation(M_PI*1.5);
} else if (orientation == UIInterfaceOrientationLandscapeRight) {
    return CGAffineTransformMakeRotation(M_PI/2);
} else if (orientation == UIInterfaceOrientationPortraitUpsideDown) {
    return CGAffineTransformMakeRotation(-M_PI);
} else {
    return CGAffineTransformIdentity;
}
</code></pre>

<p>```</p>

<ul>
<li>5.可以动画的改变我们view的显示方式了</li>
</ul>


<p><div class='bogus-wrapper'><notextile><figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>[[UIApplication sharedApplication] setStatusBarOrientation:UIDeviceOrientationLandscapeRight animated:YES];&lt;/p>
</span><span class='line'>
</span><span class='line'>&lt;p>CGFloat duration = [UIApplication sharedApplication].statusBarOrientationAnimationDuration;（获取当前电池条动画改变的时间）
</span><span class='line'>[UIView beginAnimations:nil context:nil];
</span><span class='line'>[UIView setAnimationDuration:duration];&lt;/p>
</span><span class='line'>
</span><span class='line'>&lt;p>//在这里设置view.transform需要匹配的旋转角度的大小就可以了。
</span><span class='line'>[UIView commitAnimations];&lt;/p>
</span><span class='line'>
</span><span class='line'>&lt;p></span></code></pre></td></tr></table></div></figure></notextile></div></p>

<h3>第二种：通过setOrientation:的办法强制性的旋转到一个特定的方向。</h3>

<p>   注意：Apple在3.0以后都不支持这个办法了，这个办法已经成为了私有的了，但是要跳过App Stroe的审核，需要一点巧妙的办法。</p>

<p>   不要直接调用<code>[[UIDevice currentDevice] setOrientation: UIInterfaceOrientationLandscapeRight]</code>这样的办法来强制性的横屏，这样导致你的程序是很难通过App Store审核的。但是你可以选择使用performSelector的办法来调用它。具体就几行代码如下：</p>

<p><div class='bogus-wrapper'><notextile><figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
<span class='line-number'>11</span>
<span class='line-number'>12</span>
<span class='line-number'>13</span>
<span class='line-number'>14</span>
<span class='line-number'>15</span>
<span class='line-number'>16</span>
<span class='line-number'>17</span>
<span class='line-number'>18</span>
<span class='line-number'>19</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>//强制横屏&lt;/p>
</span><span class='line'>
</span><span class='line'>&lt;pre>&lt;code>if ([[UIDevice currentDevice] respondsToSelector:@selector(setOrientation:)]) {
</span><span class='line'>    [[UIDevice currentDevice] performSelector:@selector(setOrientation:)
</span><span class='line'>                                   withObject:(id)UIInterfaceOrientationLandscapeRight];
</span><span class='line'>}
</span><span class='line'>
</span><span class='line'>// 更保险的写法 add by Eric
</span><span class='line'>+ (void)changeOrientation:(UIInterfaceOrientation)toOrientation
</span><span class='line'>{
</span><span class='line'>if ([[UIDevice currentDevice] respondsToSelector:NSSelectorFromString(@"setOrientation:")]) {
</span><span class='line'>    [[UIDevice currentDevice] performSelector:NSSelectorFromString(@"setOrientation:")
</span><span class='line'>                               withObject:(id)toOrientation];
</span><span class='line'>}
</span><span class='line'>&lt;/code>&lt;/pre>
</span><span class='line'>
</span><span class='line'>&lt;p>}&lt;/p>
</span><span class='line'>
</span><span class='line'>&lt;p></span></code></pre></td></tr></table></div></figure></notextile></div></p>

<p>   总结:如果第一种办法可以满足你需要的话，最好使用第一种办法，因为那个上 App Store肯定没问问题，但是第二种的话是需要冒风险的，但是如果你的结构太复杂了，导致使用第一种办法人为很难控制的话，可以尝试简单的使用第二种办法。</p>
]]></content>
  </entry>
  
</feed>
