<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">

  <title><![CDATA[Category: iOS | Saick Blog]]></title>
  <link href="http://saick.net/blog/categories/ios/atom.xml" rel="self"/>
  <link href="http://saick.net/"/>
  <updated>2014-02-07T18:15:53+08:00</updated>
  <id>http://saick.net/</id>
  <author>
    <name><![CDATA[Eric Shi]]></name>
    
  </author>
  <generator uri="http://octopress.org/">Octopress</generator>

  
  <entry>
    <title type="html"><![CDATA[Objective-C&amp;XCode注释的正确写法]]></title>
    <link href="http://saick.net/blog/2014/02/07/objective-c-and-xcodezhu-shi-de-zheng-que-xie-fa/"/>
    <updated>2014-02-07T18:02:00+08:00</updated>
    <id>http://saick.net/blog/2014/02/07/objective-c-and-xcodezhu-shi-de-zheng-que-xie-fa</id>
    <content type="html"><![CDATA[<p>注释对于C体系的同学来说还是不太规范，对于XCode的文档系统来说，规范还是有帮助的，能在QuickHelp等提示中反应出来。所以还是多注意下会比较好。</p>

<p>推荐以下两种写法(主是方法注释，其它的以后遇到再补充吧)</p>

<p><div class='bogus-wrapper'><notextile><figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
<span class='line-number'>11</span>
<span class='line-number'>12</span>
<span class='line-number'>13</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>/**
</span><span class='line'> *  @brief update table
</span><span class='line'> *
</span><span class='line'> *  @param  model   you want to update the entity
</span><span class='line'> *  @param  where   can use NSString or NSDictionary or nil&lt;/p>
</span><span class='line'>
</span><span class='line'>&lt;pre>&lt;code>                when "where" is nil : update the value based on rowid column or primary key column
</span><span class='line'>&lt;/code>&lt;/pre>
</span><span class='line'>
</span><span class='line'>&lt;p> *
</span><span class='line'> *  @return the updated was successful
</span><span class='line'> &lt;em>/
</span><span class='line'>&ndash;(BOOL)updateToDB:(NSObject &lt;/em>)model where:(id)where;</span></code></pre></td></tr></table></div></figure></notextile></div></p>

<p><div class='bogus-wrapper'><notextile><figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>/&lt;em>&lt;em>
</span><span class='line'> @brief   每个Section的高度，默认为 0
</span><span class='line'> @param   niDropDown: NIDropDown，用于区分不同的NI
</span><span class='line'> @param   indexPath:  定位Section
</span><span class='line'> @return  高度
</span><span class='line'> &lt;/em>/
</span><span class='line'>&ndash; (CGFloat)niDropDown:(NIDropDown &lt;/em>)niDropDown heightForHeaderInSection:(NSInteger)section;</span></code></pre></td></tr></table></div></figure></notextile></div></p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[iOS中签名相关-MD5-sha1-10进制与16进制互转]]></title>
    <link href="http://saick.net/blog/2014/01/21/ioszhong-qian-ming-xiang-guan-md5-sha1-10jin-zhi-yu-16jin-zhi-hu-zhuan/"/>
    <updated>2014-01-21T21:32:00+08:00</updated>
    <id>http://saick.net/blog/2014/01/21/ioszhong-qian-ming-xiang-guan-md5-sha1-10jin-zhi-yu-16jin-zhi-hu-zhuan</id>
    <content type="html"><![CDATA[<p>费话少说，直接上代码</p>

<h4>md5, sha1</h4>

<p>```
+ (NSString <em>)md5:(NSString </em>)str
{
  if ([str length] == 0)</p>

<pre><code>return @"";
</code></pre>

<p>  unsigned char result[CC_MD5_DIGEST_LENGTH];
  CC_MD5([str UTF8String], (CC_LONG)strlen([str UTF8String]) , result);
  NSMutableString *digest = [NSMutableString string];
  for (int i = 0; i &lt; CC_MD5_DIGEST_LENGTH; i++)</p>

<pre><code>[digest appendFormat:@"%02X", result[i]];
</code></pre>

<p>  return [digest lowercaseString];
}</p>

<ul>
<li><p>(NSString <em>)sha1:(NSString </em>)input
{
if ([input length] == 0)
  return @&ldquo;&rdquo;;</p>

<p>const char <em>cstr = [input cStringUsingEncoding:NSUTF8StringEncoding];
NSData </em>data = [NSData dataWithBytes:cstr length:input.length];</p>

<p>uint8_t digest[CC_SHA1_DIGEST_LENGTH];</p>

<p>CC_SHA1(data.bytes, data.length, digest);</p>

<p>NSMutableString *output = [NSMutableString stringWithCapacity:CC_SHA1_DIGEST_LENGTH * 2];</p>

<p>for(int i=0; i&lt;CC_SHA1_DIGEST_LENGTH; i++) {
  [output appendFormat:@&ldquo;%02X&rdquo;, digest[i]];
}</p>

<p>return output;
}
```</p></li>
</ul>


<h4>10进制转16进制</h4>

<p><code>
NSString *num16Str = [NSString stringWithFormat:@"%x", numBase10];
</code></p>

<h4>16进制转10进制</h4>

<p><code>
NSString *num10Str = [NSString stringWithFormat:@"%d", strtoul([numBase16 UTF8String], 0, 16)];
</code></p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[iOS7 UI兼容 导航栏按钮边框 UINavigationItem left and right padding]]></title>
    <link href="http://saick.net/blog/2014/01/20/ios7-uijian-rong-dao-hang-lan-an-niu-bian-kuang-uinavigationitem-left-and-right-padding/"/>
    <updated>2014-01-20T23:16:00+08:00</updated>
    <id>http://saick.net/blog/2014/01/20/ios7-uijian-rong-dao-hang-lan-an-niu-bian-kuang-uinavigationitem-left-and-right-padding</id>
    <content type="html"><![CDATA[<p>iOS7之前的UI为：</p>

<iframe src="https://www.flickr.com/photos/shjborage/12052252814/player/120d793b08" height="44" width="324"  frameborder="0" allowfullscreen webkitallowfullscreen mozallowfullscreen oallowfullscreen msallowfullscreen></iframe>


<p>而在iOS7中，由于设计方面的原因，使得UI变为:</p>

<iframe src="https://www.flickr.com/photos/shjborage/12052149003/player/bb36320bc9" height="44" width="322"  frameborder="0" allowfullscreen webkitallowfullscreen mozallowfullscreen oallowfullscreen msallowfullscreen></iframe>




<!-- more -->


<p>修改的方法重写UINavigationItem的setLeftBarButtonItem和setRightBarButtonItem方法，使之与之前版本兼容；</p>

<p>代码如下：</p>

<p><em>UINavigationItem+margin.h</em></p>

<p>```
//
//  UINavigationItem+margin.h
//
//  Created by shjborage on 1/20/14.
//  Copyright &copy; 2014 Saick. All rights reserved.
//</p>

<h1>import &lt;UIKit/UIKit.h></h1>

<p>@interface UINavigationItem (margin)</p>

<p>@end</p>

<p>```</p>

<p><em>UINavigationItem+margin.m</em></p>

<p>```
//
//  UINavigationItem+margin.m
//
//  Created by shjborage on 1/20/14.
//  Copyright &copy; 2014 Saick. All rights reserved.
//</p>

<h1>import &ldquo;UINavigationItem+margin.h&rdquo;</h1>

<p>@implementation UINavigationItem (margin)</p>

<h1>if <strong>IPHONE_OS_VERSION_MAX_ALLOWED > </strong>IPHONE_6_1</h1>

<ul>
<li><p>(void)setLeftBarButtonItem:(UIBarButtonItem <em>)_leftBarButtonItem
{
if ([[[UIDevice currentDevice] systemVersion] floatValue] >= 7.0) {
  UIBarButtonItem </em>negativeSeperator = [[UIBarButtonItem alloc] initWithBarButtonSystemItem:UIBarButtonSystemItemFixedSpace target:nil action:nil];
  negativeSeperator.width = -10.0f;</p>

<p>  if (<em>leftBarButtonItem) {
    [self setLeftBarButtonItems:@[negativeSeperator, </em>leftBarButtonItem]];
  } else {
    [self setLeftBarButtonItems:@[negativeSeperator]];
  }
} else {
  [self setLeftBarButtonItem:_leftBarButtonItem animated:NO];
}
}</p></li>
</ul>


<p>//&ndash; (void)setLeftBarButtonItems:(NSArray <em>)leftBarButtonItems
//{
//  if ([[[UIDevice currentDevice] systemVersion] floatValue] >= 7.0) {
//    UIBarButtonItem </em>negativeSeperator = [[UIBarButtonItem alloc] initWithBarButtonSystemItem:UIBarButtonSystemItemFixedSpace target:nil action:nil];
//    negativeSeperator.width = -10.0f;
//  <br/>
//    if ([_leftBarButtonItems count] > 0) {
//      NSMutableArray *items = [NSMutableArray arrayWithArray:leftBarButtonItems];
//      [items insertObject:negativeSeperator atIndex:0];
//      [self setLeftBarButtonItems:items animated:NO];
//    } else {
//      [self setLeftBarButtonItems:leftBarButtonItems animated:NO];
//    }
//  } else {
//    [self setLeftBarButtonItems:leftBarButtonItems animated:NO];
//  }
//}</p>

<ul>
<li><p>(void)setRightBarButtonItem:(UIBarButtonItem <em>)_rightBarButtonItem
{
if ([[[UIDevice currentDevice] systemVersion] floatValue] >= 7.0) {
  UIBarButtonItem </em>negativeSeperator = [[UIBarButtonItem alloc] initWithBarButtonSystemItem:UIBarButtonSystemItemFixedSpace target:nil action:nil];
  negativeSeperator.width = -10.0f;</p>

<p>  if (<em>rightBarButtonItem) {
    [self setRightBarButtonItems:@[negativeSeperator, </em>rightBarButtonItem]];
  } else {
    [self setRightBarButtonItems:@[negativeSeperator]];
  }
} else {
  [self setRightBarButtonItem:_rightBarButtonItem animated:NO];
}
}</p></li>
</ul>


<p>//&ndash; (void)setRightBarButtonItems:(NSArray <em>)rightBarButtonItems
//{
//  if ([[[UIDevice currentDevice] systemVersion] floatValue] >= 7.0) {
//    UIBarButtonItem </em>negativeSeperator = [[UIBarButtonItem alloc] initWithBarButtonSystemItem:UIBarButtonSystemItemFixedSpace target:nil action:nil];
//    negativeSeperator.width = -10.0f;
//  <br/>
//    if ([_leftBarButtonItems count] > 0) {
//      NSMutableArray *items = [NSMutableArray arrayWithArray:rightBarButtonItems];
//      [items insertObject:negativeSeperator atIndex:0];
//      [self setRightBarButtonItems:items animated:NO];
//    } else {
//      [self setRightBarButtonItems:rightBarButtonItems animated:NO];
//    }
//  } else {
//    [self setRightBarButtonItems:rightBarButtonItems animated:NO];
//  }
//}</p>

<h1>endif</h1>

<p>@end</p>

<p>```</p>

<p>项目源码不做任何修改，问题解决；</p>

<p>添加Button：</p>

<p><code>
UIBarButtonItem *leftBarItem = [[UIBarButtonItem alloc] initWithCustomView:btnBack];
self.navigationItem.leftBarButtonItem = leftBarItem;
[leftBarItem release];
</code></p>

<p>如果原来项目中有使用<code>self.navigationItem.leftBarButtonItems</code>或<code>self.navigationItem.rightBarButtonItems</code>可参考注释部分内容。如果都是多个的，那么直接换把注释解开，把单个的给注释掉。<strong>搞懂原理才是重要的</strong></p>

<p><a href="http://www.cnblogs.com/maxfong/p/3375167.html">原文地址</a></p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[iOS客户端的gzip处理-gzip-ungzip]]></title>
    <link href="http://saick.net/blog/2014/01/20/ioske-hu-duan-de-gzipchu-li-gzip-ungzip/"/>
    <updated>2014-01-20T20:28:00+08:00</updated>
    <id>http://saick.net/blog/2014/01/20/ioske-hu-duan-de-gzipchu-li-gzip-ungzip</id>
    <content type="html"><![CDATA[<p>服务端使用gzip压缩，可以大幅度减小传输包的体积，加快客户端网络请求速度，为用户节省流量。当服务器返回的httpHeader的"Content-Encoding" 属性的值是gzip时，数据会自动被解压缩，但有时候在客户端还没拿到数据的时候，就已经被某些网关解压了，这样gzip就没有起到作用。因此可以约定其他策略，防止网关解压，例如在别的头属性中标记gzip。</p>

<!-- more -->


<p>如此，就需要我们自己来解压gzip数据。方法如下：添加framework库中的libbz2.1.0.dylib；</p>

<p>添加以下静态方法：</p>

<h4>gzip解压：</h4>

<p>```
+ (NSData <em>)ungzipData:(NSData </em>)compressedData
{
  if ([compressedData length] == 0)</p>

<pre><code>return compressedData;
</code></pre>

<p>  unsigned full_length = [compressedData length];
  unsigned half_length = [compressedData length] / 2;</p>

<p>  NSMutableData *decompressed = [NSMutableData dataWithLength: full_length + half_length];
  BOOL done = NO;
  int status;</p>

<p>  z_stream strm;
  strm.next_in = (Bytef *)[compressedData bytes];
  strm.avail_in = [compressedData length];
  strm.total_out = 0;
  strm.zalloc = Z_NULL;
  strm.zfree = Z_NULL;
  if (inflateInit2(&amp;strm, (15+32)) != Z_OK)</p>

<pre><code>return nil;
</code></pre>

<p>  while (!done) {</p>

<pre><code>// Make sure we have enough room and reset the lengths.
if (strm.total_out &gt;= [decompressed length]) {
  [decompressed increaseLengthBy: half_length];
}
strm.next_out = [decompressed mutableBytes] + strm.total_out;
strm.avail_out = [decompressed length] - strm.total_out;
// Inflate another chunk.
status = inflate (&amp;strm, Z_SYNC_FLUSH);
if (status == Z_STREAM_END) {
  done = YES;
} else if (status != Z_OK) {
  break;
}
</code></pre>

<p>  }</p>

<p>  if (inflateEnd (&amp;strm) != Z_OK)</p>

<pre><code>return nil;
</code></pre>

<p>  // Set real length.
  if (done) {</p>

<pre><code>[decompressed setLength: strm.total_out];
return [NSData dataWithData: decompressed];
</code></pre>

<p>  }
  return nil;
}
```</p>

<h4><em>顺便附上gzip压缩：</em></h4>

<p>```
+ (NSData<em>)gzipData:(NSData</em>)pUncompressedData
{
  if (!pUncompressedData || [pUncompressedData length] == 0)
  {</p>

<pre><code>NSLog(@"%s: Error: Can't compress an empty or null NSData object.", __func__);
return nil;
</code></pre>

<p>  }</p>

<p>  z_stream zlibStreamStruct;
  zlibStreamStruct.zalloc    = Z_NULL; // Set zalloc, zfree, and opaque to Z_NULL so
  zlibStreamStruct.zfree     = Z_NULL; // that when we call deflateInit2 they will be
  zlibStreamStruct.opaque    = Z_NULL; // updated to use default allocation functions.
  zlibStreamStruct.total_out = 0; // Total number of output bytes produced so far
  zlibStreamStruct.next_in   = (Bytef*)[pUncompressedData bytes]; // Pointer to input bytes
  zlibStreamStruct.avail_in  = [pUncompressedData length]; // Number of input bytes left to process</p>

<p>  int initError = deflateInit2(&amp;zlibStreamStruct, Z_DEFAULT_COMPRESSION, Z_DEFLATED, (15+16), 8, Z_DEFAULT_STRATEGY);
  if (initError != Z_OK)
  {</p>

<pre><code>NSString *errorMsg = nil;
switch (initError)
{
  case Z_STREAM_ERROR:
    errorMsg = @"Invalid parameter passed in to function.";
    break;
  case Z_MEM_ERROR:
    errorMsg = @"Insufficient memory.";
    break;
  case Z_VERSION_ERROR:
    errorMsg = @"The version of zlib.h and the version of the library linked do not match.";
    break;
  default:
    errorMsg = @"Unknown error code.";
    break;
}
NSLog(@"%s: deflateInit2() Error: \"%@\" Message: \"%s\"", __func__, errorMsg, zlibStreamStruct.msg);

return nil;
</code></pre>

<p>  }</p>

<p>  // Create output memory buffer for compressed data. The zlib documentation states that
  // destination buffer size must be at least 0.1% larger than avail_in plus 12 bytes.
  NSMutableData *compressedData = [NSMutableData dataWithLength:[pUncompressedData length] * 1.01 + 12];</p>

<p>  int deflateStatus;
  do
  {</p>

<pre><code>// Store location where next byte should be put in next_out
zlibStreamStruct.next_out = [compressedData mutableBytes] + zlibStreamStruct.total_out;

// Calculate the amount of remaining free space in the output buffer
// by subtracting the number of bytes that have been written so far
// from the buffer's total capacity
zlibStreamStruct.avail_out = [compressedData length] - zlibStreamStruct.total_out;
deflateStatus = deflate(&amp;zlibStreamStruct, Z_FINISH);
</code></pre>

<p>  } while ( deflateStatus == Z_OK );</p>

<p>  // Check for zlib error and convert code to usable error message if appropriate
  if (deflateStatus != Z_STREAM_END)
  {</p>

<pre><code>NSString *errorMsg = nil;
switch (deflateStatus)
{
  case Z_ERRNO:
    errorMsg = @"Error occured while reading file.";
    break;
  case Z_STREAM_ERROR:
    errorMsg = @"The stream state was inconsistent (e.g., next_in or next_out was NULL).";
    break;
  case Z_DATA_ERROR:
    errorMsg = @"The deflate data was invalid or incomplete.";
    break;
  case Z_MEM_ERROR:
    errorMsg = @"Memory could not be allocated for processing.";
    break;
  case Z_BUF_ERROR:
    errorMsg = @"Ran out of output buffer for writing compressed bytes.";
    break;
  case Z_VERSION_ERROR:
    errorMsg = @"The version of zlib.h and the version of the library linked do not match.";
    break;
  default:
    errorMsg = @"Unknown error code.";
    break;
}
DDLogError(@"%s: zlib error while attempting compression: \"%@\" Message: \"%s\"", __func__, errorMsg, zlibStreamStruct.msg);

// Free data structures that were dynamically created for the stream.
deflateEnd(&amp;zlibStreamStruct);

return nil;
</code></pre>

<p>  }
  // Free data structures that were dynamically created for the stream.
  deflateEnd(&amp;zlibStreamStruct);
  [compressedData setLength: zlibStreamStruct.total_out];
  DDLogInfo(@&ldquo;%s: Compressed file from %d KB to %d KB&rdquo;, <strong>func</strong>, [pUncompressedData length]/1024, [compressedData length]/1024);</p>

<p>  return compressedData;
}
```</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Auto Layout by Example]]></title>
    <link href="http://saick.net/blog/2014/01/18/auto-layout-by-example/"/>
    <updated>2014-01-18T16:21:00+08:00</updated>
    <id>http://saick.net/blog/2014/01/18/auto-layout-by-example</id>
    <content type="html"><![CDATA[<p>Autolayout 博大精深，以前转过一篇，可是用的时候还是不会用。没办法只能看苹果官方的文档，发现除了讲基本的使用（XCode5中的一些操作已不太一样）外，还有这么个例子，主要解决了屏幕大小不同适配的问题，真是不错。摘录下来，希望对大家有用。</p>

<p>如果某个地方看不明白可以留言给我，我翻译并给大家讲。</p>

<p>ScrollView这块我暂时没有用，没细看，下面Size适配那个我试了，并且写了Demo，大家感兴趣下文下载研究。</p>

<p>Auto Layout makes it easy to solve many complex layout problems automatically, without the need for manual view manipulation. By creating the right combination of constraints, you can create layouts that are traditionally difficult to manage in code, such as equally spaced views that adjust to changes in orientation or size, elements inside scroll views that affect the size of the scrolling content, or elements inside scroll views that don’t scroll with the rest of the contents.</p>

<!-- more -->


<h3>Using Scroll Views with Auto Layout</h3>

<p>When you are creating an app using Auto Layout, scroll views can present a unique challenge. The size of the scrolling content must be set correctly so that the user can scroll through all of the available content, for example, and if you need to lock a contextual view in place on top of a scroll view, such as the scale and legend for a map, it’s difficult to ensure that the element doesn’t scroll with the rest of the content.</p>

<h4>Controlling Scroll View Content Size</h4>

<p>The size of the content inside of a scroll view is determined by the constraints of its descendants.</p>

<p><em>To set the size of a scroll view</em></p>

<ul>
<li>Create the scroll view.</li>
<li>Place the UI element inside it.</li>
<li>Create constraints that fully define the width and height of the scroll view content.</li>
</ul>


<p>You must make sure you create constraints for all the subviews inside a scroll view. For example, when defining the constraints for a view that doesn’t have an intrinsic content size, you’ll need more than just a leading edge constraint—you must also create trailing edge, width, and height constraints. There cannot be any missing constraints, starting from one edge of the scroll view to the other.</p>

<h4>Creating Anchored Views Inside a Scroll View</h4>

<p>You may find you want to create an area inside a scroll view that doesn’t move when a user scrolls the contents of the scroll view. You accomplish this by using a separate <strong>container view</strong>.</p>

<p><em>To lock a view inside a scroll view</em>
*   Create a container view to hold the scroll view.
*   Create the scroll view and place it in the container view with all edges equal to zero points.
*   Create and place a subview inside of the scroll view.
*   Create constraints from the subview to the container view.</p>

<p>The following example uses the steps in the above task to show how to position a text view inside of a scroll view. In this example, the text view stays at the bottom of the scroll view and doesn’t move when the scroll view contents are moved.</p>

<p>First, create the container view that will contain the scroll view. Set the size of the container view equal to the desired size of the scroll view.</p>

<iframe src="https://www.flickr.com/photos/shjborage/12008276023/player/b1ddbeff09" height="500" width="291"  frameborder="0" allowfullscreen webkitallowfullscreen mozallowfullscreen oallowfullscreen msallowfullscreen></iframe>


<p>After the container view is created, create a scroll view and place it inside of the container view. Resize the scroll view so that all of the edges are flush with the container view’s edges, by setting the distance to 0.</p>

<iframe src="https://www.flickr.com/photos/shjborage/12008810786/player/1202126aa8" height="500" width="290"  frameborder="0" allowfullscreen webkitallowfullscreen mozallowfullscreen oallowfullscreen msallowfullscreen></iframe>


<p>Create another view and place it inside of the scroll view. In this example, a text view is placed inside of the scroll view.</p>

<iframe src="https://www.flickr.com/photos/shjborage/12007999315/player/ddc38c3ea6" height="500" width="288"  frameborder="0" allowfullscreen webkitallowfullscreen mozallowfullscreen oallowfullscreen msallowfullscreen></iframe>


<p>After placing the text view, create constraints from the text view to the container view. Creating constraints that anchor the text view to the container view (skipping the scroll view) anchors the text view relative to the container view, which ensures that the scroll view won’t scroll the text view.</p>

<p>To create a constraint that crosses multiple views in the view hierarchy, it is generally easier to Control-drag from the view to the container view in the Interface Builder outline view.</p>

<iframe src="https://www.flickr.com/photos/shjborage/12008810736/player/e32e620ff4" height="298" width="270"  frameborder="0" allowfullscreen webkitallowfullscreen mozallowfullscreen oallowfullscreen msallowfullscreen></iframe>


<p>In the constraint overlay that appears, set the required constraints for the view.</p>

<iframe src="https://www.flickr.com/photos/shjborage/12008275923/player/194c48615c" height="273" width="158"  frameborder="0" allowfullscreen webkitallowfullscreen mozallowfullscreen oallowfullscreen msallowfullscreen></iframe>


<p>In this example, constraints are created from the leading, trailing, and bottom edges of the text view to the container view. The height of the text view is also constrained.</p>

<iframe src="https://www.flickr.com/photos/shjborage/12008810686/player/bdc0cae834" height="500" width="287"  frameborder="0" allowfullscreen webkitallowfullscreen mozallowfullscreen oallowfullscreen msallowfullscreen></iframe>


<p>The following two figures show the app in iOS Simulator, both in normal and landscape positions. The text view is constrained at the bottom of the scroll view and doesn’t move as the scroll view is moved.</p>

<iframe src="https://www.flickr.com/photos/shjborage/12007999185/player/a051895080" height="296" width="495"  frameborder="0" allowfullscreen webkitallowfullscreen mozallowfullscreen oallowfullscreen msallowfullscreen></iframe>




<iframe src="https://www.flickr.com/photos/shjborage/12007999135/player/4f87b36fa7" height="495" width="296"  frameborder="0" allowfullscreen webkitallowfullscreen mozallowfullscreen oallowfullscreen msallowfullscreen></iframe>


<h3>Spacing and Wrapping</h3>

<p>Auto Layout provides several techniques for automatically spacing views and resizing items based on their content. The following sections describe how to create constraints that keep visible views proportionally spaced based on the orientation of the device.</p>

<h4>Creating Equal Spacing Between Views</h4>

<p>To lay out several views that are proportionally spaced based on the orientation of a device, create spacer views between the visible views. Set the constraints of these spacer views correctly to ensure that the visible views are able to stay spaced apart based on the orientation of the device.</p>

<p><em>To space views proportionally</em>
*   Create the visible views.
*   Create the spacer views equal to the number of visible views plus one.
*   Alternate placing your views, starting with a spacer view.</p>

<pre><code>To space two visible views, place all of the views in the following pattern, starting from the left side of the screen and moving right:
</code></pre>

<p><code>spacer1 | view1 | spacer2 | view2 | spacer3.</code></p>

<ul>
<li>Constrain the spacer views so that their lengths are equal to each other.</li>
</ul>


<p><code>
Note: The height of the spacer views can be any value, including 0. However, you must create constraints for the height of the views—don’t leave the height ambiguous.
Create a leading constraint from the first spacer view to the container view.
</code></p>

<ul>
<li>Create a trailing constraint from the last spacer view to the container view.</li>
<li>Create constraints between the spacer views and the visible views.</li>
</ul>


<p><code>
Note: When spacing views vertically, start from the top of the screen and place each view below the previous view. Set the heights of the spacer views equal to each other.
The following example uses the steps in the above task to show how to position two views proportionally spaced. The spacer views are annotated for the example, but are normally left empty with no background. First, create the two views and place them in the storyboard.
</code></p>

<iframe src="https://www.flickr.com/photos/shjborage/12008351964/player/6cff17637e" height="310" width="236"  frameborder="0" allowfullscreen webkitallowfullscreen mozallowfullscreen oallowfullscreen msallowfullscreen></iframe>


<p>Add the three spacer views—one to the left of the leftmost view, one between the two views, and one to the right of the rightmost view. The spacer views don’t have to be the same size at this time because their size will be set through constraints.</p>

<iframe src="https://www.flickr.com/photos/shjborage/12008275823/player/bdda53d7d0" height="310" width="235"  frameborder="0" allowfullscreen webkitallowfullscreen mozallowfullscreen oallowfullscreen msallowfullscreen></iframe>


<p>Create the following constraints for the spacer views:</p>

<ul>
<li>Constrain the width of spacer view 2 and spacer view 3 to be equal to the width of spacer view 1.</li>
<li>Constrain the width of spacer view 1 to be greater than or equal to the minimum desired width.</li>
<li>Create a Leading Space to Container constraint from spacer view 1 to the container.</li>
<li>Create a Horizontal Spacing constraint from spacer view 1 to view 1. Set this constraint to be a less-than-or-equal-to constraint with a priority of 1000.</li>
<li>Create Horizontal Spacing constraints from spacer view 2 to view 1 and view 2. Set these constraints to be a less-than-or-equal-to constraint with a priority of 999.</li>
<li>Create a Horizontal Spacing constraint from spacer view 3 to view 2. Set this constraint to be a less-than-or-equal-to constraint with a priority of 1000.</li>
<li>Create a Trailing Space to Container constraint from spacer view 3 to the container.</li>
</ul>


<p>These constraints create two visible views and three invisible views (spacer views). These spacer views automatically resize as the orientation of the device changes, keeping the visible views proportionally spaced, as shown in the following two figures:</p>

<iframe src="https://www.flickr.com/photos/shjborage/12008275833/player/7290ca4711" height="337" width="261"  frameborder="0" allowfullscreen webkitallowfullscreen mozallowfullscreen oallowfullscreen msallowfullscreen></iframe>




<iframe src="https://www.flickr.com/photos/shjborage/12008351904/player/a2b7a82a10" height="261" width="337"  frameborder="0" allowfullscreen webkitallowfullscreen mozallowfullscreen oallowfullscreen msallowfullscreen></iframe>


<p><a href="https://www.dropbox.com/s/23vrbep9khfyvb6/AutoLayoutDemo.zip">Demo</a></p>

<h3>Animating Changes Made by Auto Layout</h3>

<p>If you need full control over animating changes made by Auto Layout, you must make your constraint changes programmatically. The basic concept is the same for both iOS and OS X, but there are a few minor differences.</p>

<p>In an iOS app, your code would look something like the following:</p>

<p>```
[containerView layoutSubtreeIfNeeded]; // Ensures that all pending layout operations have been completed
[UIView animateWithDuration:1.0 animations:^{</p>

<pre><code> // Make all constraint changes here
 [containerView layoutSubtreeIfNeeded]; // Forces the layout of the subtree animation block and then captures all of the frame changes
</code></pre>

<p>}];
```</p>

<p>In OS X, use the following code when using layer-backed animations:</p>

<p>```
[containterView layoutIfNeeded];
NSAnimationContext runAnimationGroup:^(NSAnimationContext *context) {</p>

<pre><code> [context setAllowsImplicitAnimation: YES];
 // Make all constraint changes here
 [containerView layoutIfNeeded];
</code></pre>

<p>}];
```</p>

<p>When you aren’t using layer-backed animations, you must animate the constant using the constraint’s animator:</p>

<p><code>
[[constraint animator] setConstant:42];
</code></p>

<h3>个人总结</h3>

<ol>
<li>所有相关Contraints都加好后再自动让XCode补全，或者干脆在没问题的时候忽略警告</li>
<li><code>Constrain the width of spacer view 2 and spacer view 3 to be equal to the width of spacer view 1</code>. 这意思是让三个视频的width相等，并不是给他们三个都加上width的Contraints。</li>
<li>最后是在3.5寸屏幕下开发，再适应4寸，这样直接拉开。（在开发时，点那个大小切换那个可能会带来Contraints警告，要小心。不行就Commond+Z）</li>
</ol>

]]></content>
  </entry>
  
</feed>
