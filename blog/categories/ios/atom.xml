<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">

  <title><![CDATA[Category: iOS | Saick Blog]]></title>
  <link href="http://saick.net/blog/categories/ios/atom.xml" rel="self"/>
  <link href="http://saick.net/"/>
  <updated>2014-03-06T01:03:38+08:00</updated>
  <id>http://saick.net/</id>
  <author>
    <name><![CDATA[Eric Shi]]></name>
    
  </author>
  <generator uri="http://octopress.org/">Octopress</generator>

  
  <entry>
    <title type="html"><![CDATA[GCD的坑]]></title>
    <link href="http://saick.net/blog/2014/02/19/gcdde-keng/"/>
    <updated>2014-02-19T22:22:00+08:00</updated>
    <id>http://saick.net/blog/2014/02/19/gcdde-keng</id>
    <content type="html"><![CDATA[<p>最近用不少GCD的东西，相信很多童鞋也会被GCD的简便给吸引过来。
但是这玩意使用起来，还是有不少的坑，列举出来，希望能对遇到的有用。</p>

<!-- more -->


<p>大多数时间没啥事，但是有时这样使用，就会带来问题了。见测试代码：</p>

<p>```
//  dispatch_async(dispatch_get_global_queue(DISPATCH_QUEUE_PRIORITY_DEFAULT, 0), ^{</p>

<pre><code>for (int i=0; i&lt;=100; i++) {
</code></pre>

<p>//    for (int i=0; i&lt;=62; i++) {</p>

<pre><code>  dispatch_async(dispatch_get_global_queue(DISPATCH_QUEUE_PRIORITY_DEFAULT, 0), ^{
    NSString *key = [NSString stringWithFormat:@"key%d", i];
    NSMutableDictionary *value = [NSMutableDictionary dictionary];
    for (int j=0; j&lt;1/*10000*/; j++) {
      NSString *subKey = [NSString stringWithFormat:@"subkey%d", j];
      int random = arc4random();
      [value setObject:[NSString stringWithFormat:@"%d", random] forKey:subKey];
    }
</code></pre>

<p>//        int j=100;
//        while (&mdash;j>0) {
//          dispatch_async(dispatch_get_global_queue(DISPATCH_QUEUE_PRIORITY_DEFAULT, 0), ^{
//            NSLog(@&ldquo;sub&rdquo;);
//          });
//        }</p>

<p>//        [[TMCache sharedCache] setObject:value forKey:key];</p>

<pre><code>    [[TMCache sharedCache] setObject:value forKey:key block:NULL];
</code></pre>

<p>//        TMDiskCache *cache = [[TMDiskCache alloc] initWithName:@&ldquo;test.diskCache&rdquo;];
//        [cache setObject:value forKey:key block:NULL];</p>

<pre><code>    NSLog(@"%@", key);
  });
}
</code></pre>

<p>//  });
```</p>

<p><em>TMCache setObject:forKey:</em></p>

<p>```
&ndash; (void)setObject:(id <NSCoding>)object forKey:(NSString *)key
{</p>

<pre><code>if (!object || !key)
    return;

dispatch_semaphore_t semaphore = dispatch_semaphore_create(0);

[self setObject:object forKey:key block:^(TMCache *cache, NSString *key, id object) {
    dispatch_semaphore_signal(semaphore);
}];

dispatch_semaphore_wait(semaphore, DISPATCH_TIME_FOREVER);

#if !OS_OBJECT_USE_OBJC
dispatch_release(semaphore);
#endif
</code></pre>

<p>}
```</p>

<p><em>TMDiskCache 定义</em>
```
//#if <strong>IPHONE_OS_VERSION_MIN_REQUIRED >= </strong>IPHONE_4_0 //这个是默认值</p>

<h1>if 0</h1>

<pre><code>#define TMCacheStartBackgroundTask() UIBackgroundTaskIdentifier taskID = UIBackgroundTaskInvalid; \
        taskID = [[UIApplication sharedApplication] beginBackgroundTaskWithExpirationHandler:^{ \
        [[UIApplication sharedApplication] endBackgroundTask:taskID]; }];
#define TMCacheEndBackgroundTask() [[UIApplication sharedApplication] endBackgroundTask:taskID];
</code></pre>

<h1>else</h1>

<pre><code>#define TMCacheStartBackgroundTask()
#define TMCacheEndBackgroundTask()
</code></pre>

<h1>endif</h1>

<p>```</p>

<p><em>TMDiskCache 使用</em>
```
&ndash; (void)setObject:(id <NSCoding>)object forKey:(NSString *)key block:(TMDiskCacheObjectBlock)block
{</p>

<pre><code>NSDate *now = [[NSDate alloc] init];

if (!key || !object)
    return;

TMCacheStartBackgroundTask();

__weak TMDiskCache *weakSelf = self;

dispatch_async(_queue, ^{
    TMDiskCache *strongSelf = weakSelf;
    if (!strongSelf) {
        TMCacheEndBackgroundTask();
        return;
    }

    ...

    TMCacheEndBackgroundTask();
});
</code></pre>

<p>}
```</p>

<p>这样一个for循环，次数超过63就卡死了，啥也执行不了。
还有，如果关掉<code>TMCacheStartBackgroundTask</code>，并且不使用<code>dispatch_semaphore_t</code>做异步转同步的处理（直接使用<code>[[TMCache sharedCache] setObject:value forKey:key block:NULL];</code>），就没啥问题了。</p>

<p>看详情，跑数据的在此<a href="https://www.dropbox.com/s/59kdkfc3sm2gx1q/test_GCD.zip">下载测试工程</a></p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Objective-C&amp;XCode注释的正确写法]]></title>
    <link href="http://saick.net/blog/2014/02/07/objective-c-and-xcodezhu-shi-de-zheng-que-xie-fa/"/>
    <updated>2014-02-07T18:02:00+08:00</updated>
    <id>http://saick.net/blog/2014/02/07/objective-c-and-xcodezhu-shi-de-zheng-que-xie-fa</id>
    <content type="html"><![CDATA[<p>注释对于C体系的同学来说还是不太规范，对于XCode的文档系统来说，规范还是有帮助的，能在QuickHelp等提示中反应出来。所以还是多注意下会比较好。</p>

<p>推荐以下两种写法(主是方法注释，其它的以后遇到再补充吧)</p>

<p><div class='bogus-wrapper'><notextile><figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
<span class='line-number'>11</span>
<span class='line-number'>12</span>
<span class='line-number'>13</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>/**
</span><span class='line'> *  @brief update table
</span><span class='line'> *
</span><span class='line'> *  @param  model   you want to update the entity
</span><span class='line'> *  @param  where   can use NSString or NSDictionary or nil&lt;/p>
</span><span class='line'>
</span><span class='line'>&lt;pre>&lt;code>                when "where" is nil : update the value based on rowid column or primary key column
</span><span class='line'>&lt;/code>&lt;/pre>
</span><span class='line'>
</span><span class='line'>&lt;p> *
</span><span class='line'> *  @return the updated was successful
</span><span class='line'> &lt;em>/
</span><span class='line'>&ndash;(BOOL)updateToDB:(NSObject &lt;/em>)model where:(id)where;</span></code></pre></td></tr></table></div></figure></notextile></div></p>

<p><div class='bogus-wrapper'><notextile><figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>/&lt;em>&lt;em>
</span><span class='line'> @brief   每个Section的高度，默认为 0
</span><span class='line'> @param   niDropDown: NIDropDown，用于区分不同的NI
</span><span class='line'> @param   indexPath:  定位Section
</span><span class='line'> @return  高度
</span><span class='line'> &lt;/em>/
</span><span class='line'>&ndash; (CGFloat)niDropDown:(NIDropDown &lt;/em>)niDropDown heightForHeaderInSection:(NSInteger)section;</span></code></pre></td></tr></table></div></figure></notextile></div></p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[iOS中签名相关-MD5-sha1-10进制与16进制互转]]></title>
    <link href="http://saick.net/blog/2014/01/21/ioszhong-qian-ming-xiang-guan-md5-sha1-10jin-zhi-yu-16jin-zhi-hu-zhuan/"/>
    <updated>2014-01-21T21:32:00+08:00</updated>
    <id>http://saick.net/blog/2014/01/21/ioszhong-qian-ming-xiang-guan-md5-sha1-10jin-zhi-yu-16jin-zhi-hu-zhuan</id>
    <content type="html"><![CDATA[<p>费话少说，直接上代码</p>

<h4>md5, sha1</h4>

<p>```
+ (NSString <em>)md5:(NSString </em>)str
{
  if ([str length] == 0)</p>

<pre><code>return @"";
</code></pre>

<p>  unsigned char result[CC_MD5_DIGEST_LENGTH];
  CC_MD5([str UTF8String], (CC_LONG)strlen([str UTF8String]) , result);
  NSMutableString *digest = [NSMutableString string];
  for (int i = 0; i &lt; CC_MD5_DIGEST_LENGTH; i++)</p>

<pre><code>[digest appendFormat:@"%02X", result[i]];
</code></pre>

<p>  return [digest lowercaseString];
}</p>

<ul>
<li><p>(NSString <em>)sha1:(NSString </em>)input
{
if ([input length] == 0)
  return @&ldquo;&rdquo;;</p>

<p>const char <em>cstr = [input cStringUsingEncoding:NSUTF8StringEncoding];
NSData </em>data = [NSData dataWithBytes:cstr length:input.length];</p>

<p>uint8_t digest[CC_SHA1_DIGEST_LENGTH];</p>

<p>CC_SHA1(data.bytes, data.length, digest);</p>

<p>NSMutableString *output = [NSMutableString stringWithCapacity:CC_SHA1_DIGEST_LENGTH * 2];</p>

<p>for(int i=0; i&lt;CC_SHA1_DIGEST_LENGTH; i++) {
  [output appendFormat:@&ldquo;%02X&rdquo;, digest[i]];
}</p>

<p>return output;
}
```</p></li>
</ul>


<h4>10进制转16进制</h4>

<p><code>
NSString *num16Str = [NSString stringWithFormat:@"%x", numBase10];
</code></p>

<h4>16进制转10进制</h4>

<p><code>
NSString *num10Str = [NSString stringWithFormat:@"%d", strtoul([numBase16 UTF8String], 0, 16)];
</code></p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[iOS7 UI兼容 导航栏按钮边框 UINavigationItem left and right padding]]></title>
    <link href="http://saick.net/blog/2014/01/20/ios7-uijian-rong-dao-hang-lan-an-niu-bian-kuang-uinavigationitem-left-and-right-padding/"/>
    <updated>2014-01-20T23:16:00+08:00</updated>
    <id>http://saick.net/blog/2014/01/20/ios7-uijian-rong-dao-hang-lan-an-niu-bian-kuang-uinavigationitem-left-and-right-padding</id>
    <content type="html"><![CDATA[<p>iOS7之前的UI为：</p>

<iframe src="https://www.flickr.com/photos/shjborage/12052252814/player/120d793b08" height="44" width="324"  frameborder="0" allowfullscreen webkitallowfullscreen mozallowfullscreen oallowfullscreen msallowfullscreen></iframe>


<p>而在iOS7中，由于设计方面的原因，使得UI变为:</p>

<iframe src="https://www.flickr.com/photos/shjborage/12052149003/player/bb36320bc9" height="44" width="322"  frameborder="0" allowfullscreen webkitallowfullscreen mozallowfullscreen oallowfullscreen msallowfullscreen></iframe>




<!-- more -->


<p>修改的方法重写UINavigationItem的setLeftBarButtonItem和setRightBarButtonItem方法，使之与之前版本兼容；</p>

<p>代码如下：</p>

<p><em>UINavigationItem+margin.h</em></p>

<p>```
//
//  UINavigationItem+margin.h
//
//  Created by shjborage on 1/20/14.
//  Copyright &copy; 2014 Saick. All rights reserved.
//</p>

<h1>import &lt;UIKit/UIKit.h></h1>

<p>@interface UINavigationItem (margin)</p>

<p>@end</p>

<p>```</p>

<p><em>UINavigationItem+margin.m</em></p>

<p>```
//
//  UINavigationItem+margin.m
//
//  Created by shjborage on 1/20/14.
//  Copyright &copy; 2014 Saick. All rights reserved.
//</p>

<h1>import &ldquo;UINavigationItem+margin.h&rdquo;</h1>

<p>@implementation UINavigationItem (margin)</p>

<h1>if <strong>IPHONE_OS_VERSION_MAX_ALLOWED > </strong>IPHONE_6_1</h1>

<ul>
<li><p>(void)setLeftBarButtonItem:(UIBarButtonItem <em>)_leftBarButtonItem
{
if ([[[UIDevice currentDevice] systemVersion] floatValue] >= 7.0) {
  UIBarButtonItem </em>negativeSeperator = [[UIBarButtonItem alloc] initWithBarButtonSystemItem:UIBarButtonSystemItemFixedSpace target:nil action:nil];
  negativeSeperator.width = -10.0f;</p>

<p>  if (<em>leftBarButtonItem) {
    [self setLeftBarButtonItems:@[negativeSeperator, </em>leftBarButtonItem]];
  } else {
    [self setLeftBarButtonItems:@[negativeSeperator]];
  }
} else {
  [self setLeftBarButtonItem:_leftBarButtonItem animated:NO];
}
}</p></li>
</ul>


<p>//&ndash; (void)setLeftBarButtonItems:(NSArray <em>)leftBarButtonItems
//{
//  if ([[[UIDevice currentDevice] systemVersion] floatValue] >= 7.0) {
//    UIBarButtonItem </em>negativeSeperator = [[UIBarButtonItem alloc] initWithBarButtonSystemItem:UIBarButtonSystemItemFixedSpace target:nil action:nil];
//    negativeSeperator.width = -10.0f;
//  <br/>
//    if ([_leftBarButtonItems count] > 0) {
//      NSMutableArray *items = [NSMutableArray arrayWithArray:leftBarButtonItems];
//      [items insertObject:negativeSeperator atIndex:0];
//      [self setLeftBarButtonItems:items animated:NO];
//    } else {
//      [self setLeftBarButtonItems:leftBarButtonItems animated:NO];
//    }
//  } else {
//    [self setLeftBarButtonItems:leftBarButtonItems animated:NO];
//  }
//}</p>

<ul>
<li><p>(void)setRightBarButtonItem:(UIBarButtonItem <em>)_rightBarButtonItem
{
if ([[[UIDevice currentDevice] systemVersion] floatValue] >= 7.0) {
  UIBarButtonItem </em>negativeSeperator = [[UIBarButtonItem alloc] initWithBarButtonSystemItem:UIBarButtonSystemItemFixedSpace target:nil action:nil];
  negativeSeperator.width = -10.0f;</p>

<p>  if (<em>rightBarButtonItem) {
    [self setRightBarButtonItems:@[negativeSeperator, </em>rightBarButtonItem]];
  } else {
    [self setRightBarButtonItems:@[negativeSeperator]];
  }
} else {
  [self setRightBarButtonItem:_rightBarButtonItem animated:NO];
}
}</p></li>
</ul>


<p>//&ndash; (void)setRightBarButtonItems:(NSArray <em>)rightBarButtonItems
//{
//  if ([[[UIDevice currentDevice] systemVersion] floatValue] >= 7.0) {
//    UIBarButtonItem </em>negativeSeperator = [[UIBarButtonItem alloc] initWithBarButtonSystemItem:UIBarButtonSystemItemFixedSpace target:nil action:nil];
//    negativeSeperator.width = -10.0f;
//  <br/>
//    if ([_leftBarButtonItems count] > 0) {
//      NSMutableArray *items = [NSMutableArray arrayWithArray:rightBarButtonItems];
//      [items insertObject:negativeSeperator atIndex:0];
//      [self setRightBarButtonItems:items animated:NO];
//    } else {
//      [self setRightBarButtonItems:rightBarButtonItems animated:NO];
//    }
//  } else {
//    [self setRightBarButtonItems:rightBarButtonItems animated:NO];
//  }
//}</p>

<h1>endif</h1>

<p>@end</p>

<p>```</p>

<p>项目源码不做任何修改，问题解决；</p>

<p>添加Button：</p>

<p><code>
UIBarButtonItem *leftBarItem = [[UIBarButtonItem alloc] initWithCustomView:btnBack];
self.navigationItem.leftBarButtonItem = leftBarItem;
[leftBarItem release];
</code></p>

<p>如果原来项目中有使用<code>self.navigationItem.leftBarButtonItems</code>或<code>self.navigationItem.rightBarButtonItems</code>可参考注释部分内容。如果都是多个的，那么直接换把注释解开，把单个的给注释掉。<strong>搞懂原理才是重要的</strong></p>

<p><a href="http://www.cnblogs.com/maxfong/p/3375167.html">原文地址</a></p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[iOS客户端的gzip处理-gzip-ungzip]]></title>
    <link href="http://saick.net/blog/2014/01/20/ioske-hu-duan-de-gzipchu-li-gzip-ungzip/"/>
    <updated>2014-01-20T20:28:00+08:00</updated>
    <id>http://saick.net/blog/2014/01/20/ioske-hu-duan-de-gzipchu-li-gzip-ungzip</id>
    <content type="html"><![CDATA[<p>服务端使用gzip压缩，可以大幅度减小传输包的体积，加快客户端网络请求速度，为用户节省流量。当服务器返回的httpHeader的"Content-Encoding" 属性的值是gzip时，数据会自动被解压缩，但有时候在客户端还没拿到数据的时候，就已经被某些网关解压了，这样gzip就没有起到作用。因此可以约定其他策略，防止网关解压，例如在别的头属性中标记gzip。</p>

<!-- more -->


<p>如此，就需要我们自己来解压gzip数据。方法如下：添加framework库中的libbz2.1.0.dylib；</p>

<p>添加以下静态方法：</p>

<h4>gzip解压：</h4>

<p>```
+ (NSData <em>)ungzipData:(NSData </em>)compressedData
{
  if ([compressedData length] == 0)</p>

<pre><code>return compressedData;
</code></pre>

<p>  unsigned full_length = [compressedData length];
  unsigned half_length = [compressedData length] / 2;</p>

<p>  NSMutableData *decompressed = [NSMutableData dataWithLength: full_length + half_length];
  BOOL done = NO;
  int status;</p>

<p>  z_stream strm;
  strm.next_in = (Bytef *)[compressedData bytes];
  strm.avail_in = [compressedData length];
  strm.total_out = 0;
  strm.zalloc = Z_NULL;
  strm.zfree = Z_NULL;
  if (inflateInit2(&amp;strm, (15+32)) != Z_OK)</p>

<pre><code>return nil;
</code></pre>

<p>  while (!done) {</p>

<pre><code>// Make sure we have enough room and reset the lengths.
if (strm.total_out &gt;= [decompressed length]) {
  [decompressed increaseLengthBy: half_length];
}
strm.next_out = [decompressed mutableBytes] + strm.total_out;
strm.avail_out = [decompressed length] - strm.total_out;
// Inflate another chunk.
status = inflate (&amp;strm, Z_SYNC_FLUSH);
if (status == Z_STREAM_END) {
  done = YES;
} else if (status != Z_OK) {
  break;
}
</code></pre>

<p>  }</p>

<p>  if (inflateEnd (&amp;strm) != Z_OK)</p>

<pre><code>return nil;
</code></pre>

<p>  // Set real length.
  if (done) {</p>

<pre><code>[decompressed setLength: strm.total_out];
return [NSData dataWithData: decompressed];
</code></pre>

<p>  }
  return nil;
}
```</p>

<h4><em>顺便附上gzip压缩：</em></h4>

<p>```
+ (NSData<em>)gzipData:(NSData</em>)pUncompressedData
{
  if (!pUncompressedData || [pUncompressedData length] == 0)
  {</p>

<pre><code>NSLog(@"%s: Error: Can't compress an empty or null NSData object.", __func__);
return nil;
</code></pre>

<p>  }</p>

<p>  z_stream zlibStreamStruct;
  zlibStreamStruct.zalloc    = Z_NULL; // Set zalloc, zfree, and opaque to Z_NULL so
  zlibStreamStruct.zfree     = Z_NULL; // that when we call deflateInit2 they will be
  zlibStreamStruct.opaque    = Z_NULL; // updated to use default allocation functions.
  zlibStreamStruct.total_out = 0; // Total number of output bytes produced so far
  zlibStreamStruct.next_in   = (Bytef*)[pUncompressedData bytes]; // Pointer to input bytes
  zlibStreamStruct.avail_in  = [pUncompressedData length]; // Number of input bytes left to process</p>

<p>  int initError = deflateInit2(&amp;zlibStreamStruct, Z_DEFAULT_COMPRESSION, Z_DEFLATED, (15+16), 8, Z_DEFAULT_STRATEGY);
  if (initError != Z_OK)
  {</p>

<pre><code>NSString *errorMsg = nil;
switch (initError)
{
  case Z_STREAM_ERROR:
    errorMsg = @"Invalid parameter passed in to function.";
    break;
  case Z_MEM_ERROR:
    errorMsg = @"Insufficient memory.";
    break;
  case Z_VERSION_ERROR:
    errorMsg = @"The version of zlib.h and the version of the library linked do not match.";
    break;
  default:
    errorMsg = @"Unknown error code.";
    break;
}
NSLog(@"%s: deflateInit2() Error: \"%@\" Message: \"%s\"", __func__, errorMsg, zlibStreamStruct.msg);

return nil;
</code></pre>

<p>  }</p>

<p>  // Create output memory buffer for compressed data. The zlib documentation states that
  // destination buffer size must be at least 0.1% larger than avail_in plus 12 bytes.
  NSMutableData *compressedData = [NSMutableData dataWithLength:[pUncompressedData length] * 1.01 + 12];</p>

<p>  int deflateStatus;
  do
  {</p>

<pre><code>// Store location where next byte should be put in next_out
zlibStreamStruct.next_out = [compressedData mutableBytes] + zlibStreamStruct.total_out;

// Calculate the amount of remaining free space in the output buffer
// by subtracting the number of bytes that have been written so far
// from the buffer's total capacity
zlibStreamStruct.avail_out = [compressedData length] - zlibStreamStruct.total_out;
deflateStatus = deflate(&amp;zlibStreamStruct, Z_FINISH);
</code></pre>

<p>  } while ( deflateStatus == Z_OK );</p>

<p>  // Check for zlib error and convert code to usable error message if appropriate
  if (deflateStatus != Z_STREAM_END)
  {</p>

<pre><code>NSString *errorMsg = nil;
switch (deflateStatus)
{
  case Z_ERRNO:
    errorMsg = @"Error occured while reading file.";
    break;
  case Z_STREAM_ERROR:
    errorMsg = @"The stream state was inconsistent (e.g., next_in or next_out was NULL).";
    break;
  case Z_DATA_ERROR:
    errorMsg = @"The deflate data was invalid or incomplete.";
    break;
  case Z_MEM_ERROR:
    errorMsg = @"Memory could not be allocated for processing.";
    break;
  case Z_BUF_ERROR:
    errorMsg = @"Ran out of output buffer for writing compressed bytes.";
    break;
  case Z_VERSION_ERROR:
    errorMsg = @"The version of zlib.h and the version of the library linked do not match.";
    break;
  default:
    errorMsg = @"Unknown error code.";
    break;
}
DDLogError(@"%s: zlib error while attempting compression: \"%@\" Message: \"%s\"", __func__, errorMsg, zlibStreamStruct.msg);

// Free data structures that were dynamically created for the stream.
deflateEnd(&amp;zlibStreamStruct);

return nil;
</code></pre>

<p>  }
  // Free data structures that were dynamically created for the stream.
  deflateEnd(&amp;zlibStreamStruct);
  [compressedData setLength: zlibStreamStruct.total_out];
  DDLogInfo(@&ldquo;%s: Compressed file from %d KB to %d KB&rdquo;, <strong>func</strong>, [pUncompressedData length]/1024, [compressedData length]/1024);</p>

<p>  return compressedData;
}
```</p>
]]></content>
  </entry>
  
</feed>
