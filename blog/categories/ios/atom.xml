<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">

  <title><![CDATA[Category: iOS | Saick Blog]]></title>
  <link href="http://saick.net/blog/categories/ios/atom.xml" rel="self"/>
  <link href="http://saick.net/"/>
  <updated>2013-08-22T15:22:07+08:00</updated>
  <id>http://saick.net/</id>
  <author>
    <name><![CDATA[Eric Shi]]></name>
    
  </author>
  <generator uri="http://octopress.org/">Octopress</generator>

  
  <entry>
    <title type="html"><![CDATA[ iOS 权限管理-Best Practices for Maintaining User Privacy]]></title>
    <link href="http://saick.net/blog/2013/08/22/ios-quan-xian-guan-li-best-practices-for-maintaining-user-privacy/"/>
    <updated>2013-08-22T14:58:00+08:00</updated>
    <id>http://saick.net/blog/2013/08/22/ios-quan-xian-guan-li-best-practices-for-maintaining-user-privacy</id>
    <content type="html"><![CDATA[<p>从Notification的开关入手，发现了统一给出的入口。
从iOS7 beta的文档中获得，但目测还是老的。（关于MircoPhone的控制还没有）</p>

<p>来正文</p>

<h4>Best Practices for Maintaining User Privacy</h4>

<p>Maintaining user privacy should be an important consideration when designing your app. Most iOS devices contain user and device data that users might not want to expose to apps or external entities. If your app uses user or device data in an unexpected way, the user might delete your app rather than trust it to use the data in an appropriate way.</p>

<p>You should access user or device data only with the user’s informed consent obtained in accordance with applicable law. In addition, you should take appropriate steps to protect user and device data and be transparent about how you use it. Here are some best practices that you can take:</p>

<p>Review guidelines from government or industry sources, including the following documents:</p>

<p>The Federal Trade Commission’s report on mobile privacy: Mobile Privacy Disclosures: Building Trust Through Transparency.</p>

<p>The EU Data Protection Commissioners’ Opinion on data protection for Mobile Apps: <a href="http://ec.europa.eu/justice/data-protection/article-29/documentation/opinion-recommendation/files/2013/wp202_en.pdf">http://ec.europa.eu/justice/data-protection/article-29/documentation/opinion-recommendation/files/2013/wp202_en.pdf</a></p>

<p>The California State Attorney General’s recommendations for mobile privacy: Privacy on the Go: Recommendations for the Mobile Ecosystem</p>

<p>These reports provide helpful recommendations for protecting user privacy. You should also review these documents with your company’s legal counsel.
Request access to user or device data that is protected by the iOS system authorization settings at the time the data is needed. Consider supplying a usage description string in your app’s Info.plist file explaining why your app needs that data. Data protected by iOS system authorization settings includes location data, contacts, calendar events, reminders, photos, and media; see Table 1-1. Provide reasonable fallback behavior in situations where the user does not grant access to the requested data.</p>

<p>Be transparent with users about how their data is going to be used. For example, you should specify a URL for your privacy policy or statement with your iTunes Connect metadata when you submit your app, and you might also want to summarize that policy in your app description.
For more information about providing your app’s privacy policy in iTunes Connect, see “Adding New Apps” in iTunes Connect Developer Guide</p>

<p>Give the user control over their user or device data. Provide settings so that the user can disable access to certain types of sensitive information as needed.
Request and use the minimum amount of user or device data needed to accomplish a given task. Do not seek access to or collect data for non obvious reasons, for unnecessary reasons, or because you think it might be useful later.
Take reasonable steps to protect the user and device data that you collect in your apps. When storing such information locally, try to use the iOS data protection feature (described in “Protecting Data Using On-Disk Encryption”) to store it in an encrypted format. And try to use HTTPS when sending user or device data over the network.</p>

<p>If your app uses the ASIdentifierManager class, you must respect the value of its advertisingTrackingEnabled property. And if that property is set to NO by the user, then use the ASIdentifierManager class only for the following purposes: frequency capping, conversion events, estimating the number of unique users, security and fraud detection, and debugging. Remember the ASIdentifierManager class is to be used only for the purposes of serving advertising. Do not use it as a general advertising cookie or for any other purposes.</p>

<p>If you have not already done so, stop using the unique device identifier (UDID) provided by the uniqueIdentifier property of the UIDevice class. That property was deprecated in iOS 5.0, and starting May 1, 2013 the App Store will no longer accept new apps or app updates that use that identifier. Instead, apps should use the identifierForVendor property of the UIDevice class or the advertisingIdentifier property of the ASIdentifierManager class, as appropriate.</p>

<p>Table 1-1 lists the types of data authorizations supported by iOS and how you can determine if your app is authorized to use that data. You should view this table as a starting point for your app’s own privacy behaviors and not as a finite checklist. The contents of this table may evolve over time.</p>

<p>Table 1-1  Data protected by system authorization settings</p>

<p><img class="<a" src="href="http://www.saick.net/images/blog/2013-08-22-ios-quan-xian-guan-li-best-practices-for-maintaining-user-privacy.png">http://www.saick.net/images/blog/2013-08-22-ios-quan-xian-guan-li-best-practices-for-maintaining-user-privacy.png</a>"></p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Cocoa 自省机制]]></title>
    <link href="http://saick.net/blog/2013/08/01/cocoa-zi-sheng-ji-zhi/"/>
    <updated>2013-08-01T16:30:00+08:00</updated>
    <id>http://saick.net/blog/2013/08/01/cocoa-zi-sheng-ji-zhi</id>
    <content type="html"><![CDATA[<h3>内省</h3>

<p>内省（Introspection）是面向对象语言和环境的一个强大特性，Objective-C和Cocoa在这个方面尤其的丰富。内省是对象揭示自己作为一个运行时对象的详细信息的一种能力。这些详细信息包括对象在继承树上的位置，对象是否遵循特定的协议，以及是否可以响应特定的消息。NSObject协议和类定义了很多内省方法，用于查询运行时信息，以便根据对象的特征进行识别。</p>

<p>明智地使用内省可以使面向对象的程序更加高效和强壮。它有助于避免错误地进行消息派发、错误地假设对象相等、以及类似的问题。下面的部分将介绍如何在代码中有效地使用NSObject的内省方法。</p>

<p><strong><em>本部分包括如下内容：</em></strong></p>

<ul>
<li>评估继承关系</li>
<li>方法实现和协议遵循</li>
<li>对象的比较</li>
</ul>


<h4>评估继承关系</h4>

<p>一旦您知道一个对象属于什么类，就可能已经相当了解这个对象了。您可以知道它具有什么能力、哪些属性、以及可以响应哪些消息。即使在内省之后不能了解对象所属的类，也可以知道该对象不能响应特定的消息。</p>

<p>NSObject协议声明了几个方法，用于确定对象在类层次中的位置。这些方法在不同粒度上进行操作，比如class和superclass实例方法分别返回代表类和超类的Class对象。使用这些方法需要将一个Class对象和另一个进行对比。列表2-7给出了一个简单（可能是没有价值）的用法实例。</p>

<p>列表2-7  使用类和超类的方法</p>

<p>```
// &hellip;
while ( id anObject = [objectEnumerator nextObject] ) {</p>

<pre><code>if ( [self class] == [anObject superclass] ) {
    // do something appropriate...
}
</code></pre>

<p>}
```
请注意：有些时候您需要通过class或superclass方法得到正确的类消息接收者。
更加常见的是检查对象类的从属关系，这种情况下您需要向该对象发送isKindOfClass:或isMemberOfClass:消息。前一个方法返回接收者是否为给定类或其继承类的实例，isMemberOfClass:消息则告诉您接收者是否为指定类的实例。isKindOfClass: 方法通常更有用，因为通过它可以知道是否可以向该对象发送一系列消息。考虑列表2-8中的代码片断：</p>

<p>列表2-8  使用isKindOfClass:方法</p>

<p>```
if ([item isKindOfClass:[NSData class]]) {</p>

<pre><code>const unsigned char *bytes = [item bytes];
unsigned int length = [item length];
// ...
</code></pre>

<p>}
```
确定tem对象是NSData类的继承类的实例之后，代码就知道可以向它发送NSData的bytes和length消息。假定item是NSMutableData类的一个实例，则isKindOfClass:和isMemberOfClass:之间的差别就变得更加明显。如果您调用的是isMemberOfClass:，而不是isKindOfClass:，条件控制块中的代码将永远不会被执行，因为item并不是NSData类的实例，而是其子类NSMutableData的实例。</p>

<h4>方法实现和协议遵循</h4>

<p>NSObject还有两个功能更加强大的内省方法，即respondsToSelector:和conformsToProtocol:。这两个方法分别告诉您一个对象是否实现特定的方法，以及是否遵循指定的正式协议（即该对象是否采纳了该协议，且实现了该协议的所有方法）。</p>

<p>在代码中，您可以在类似的情况下使用这些方法。通过这些方法，您可以在将消息或消息集合发送给某些潜在的匿名对象之前，确定它们是否可以正确地进行响应。在发送消息之前进行检查可以避免由不能识别的选择器引起的运行时例外。在实现非正式协议（这种协议是委托技术的基础）时，Application Kit就是在调用委托方法之前检查委托对象是否实现该方法（通过respondsToSelector:方法）。</p>

<p>列表2-9显示了如何在代码中使用respondsToSelector:方法。</p>

<p>列表2-9  使用respondsToSelector:方法
```
&ndash; (void)doCommandBySelector:(SEL)aSelector {</p>

<pre><code>if ([self respondsToSelector:aSelector]) {
    [self performSelector:aSelector withObject:nil];
} else {
    [_client doCommandBySelector:aSelector];
}
</code></pre>

<p>}
```
列表2-10显示如何在代码中使用conformsToProtocol:方法：</p>

<p>列表2-10  使用conformsToProtocol:方法</p>

<p>```
// &hellip;
if (!([((id)testObject) conformsToProtocol:@protocol(NSMenuItem)])) {</p>

<pre><code>NSLog(@"Custom MenuItem, '%@', not loaded; it must conform to the
    'NSMenuItem' protocol.\n", [testObject class]);
[testObject release];
testObject = nil;
</code></pre>

<p>}
```</p>

<h4>对象的比较</h4>

<p>hash和isEqual:方法虽然不是严格的内省方法，但是可以发挥类似的作用，是进行对象的识别和比较时不可或缺的运行时工具。它们并不向运行环境查询对象信息，而是依赖于具体类的比较逻辑。</p>

<p>hash和isEqual:方法都在NSObject协议中声明，且彼此关系紧密。实现hash方法必须返回一个整型数，作为哈希表结构中的表地址。两个对象相等（isEqual:方法的判断结果）意味着它们有相同的哈希值。如果您的对象可能被包含在象NSSet这样的集合中，则需要定义hash方法，并确保该方法在两个对象相等的时候返回相同的哈希值。NSObject类中缺省的isEqual:实现只是简单地检查指针是否相等。</p>

<p>isEqual:的使用相当直接，它将消息的接收者和通过参数传入的对象进行比较。对象的比较常常可以在运行时决定应该对对象做些什么。如列表2-11所示，您可以通过isEqual:来确定是否执行某一个动作。在这个例子中，动作是指保存被修改了的预置信息。</p>

<p>列表2-11  使用isEqual:方法
```
&ndash; (void)saveDefaults {</p>

<pre><code>NSDictionary *prefs = [self preferences];
if (![origValues isEqual:prefs]) 
    [Preferences savePreferencesToDefaults:prefs];
</code></pre>

<p>}
```
如果您正在创建子类，则可能需要重载isEqual:方法，以进一步检查对象是否相等。子类可能定义额外的属性，当两个实例被认为相等时，属性的值必须相同。举例来说，假定您创建一个名为MyWidget的NSObject子类，类中包含两个实例变量：name和data。当MyWidget的两个实例被认为是相等时，这些变量必须具有相同的值。列表2-12显示如何在MyWidget类中实现isEqual:方法。</p>

<p>列表 2-12  重载isEqual:方法
```
&ndash; (BOOL)isEqual:(id)other {</p>

<pre><code>if (other == self) 
    return YES;
if (!other || ![other isKindOfClass:[self class]]) 
    return NO;
return [self isEqualToWidget:other];
</code></pre>

<p>}</p>

<ul>
<li>(BOOL)isEqualToWidget:(MyWidget *)aWidget {
  if (self == aWidget)
      return YES;
  if (![(id)[self name] isEqual:[aWidget name]])
      return NO;
  if (![[self data] isEqualToData:[aWidget data]])
      return NO;
  return YES;
}
```
isEqual:方法首先检查指针的等同性，然后是类的等同性，最后调用对象的比较器进行比较。比较器的名称指示出参与比较的对象的类名称。这种类型的比较器对传入的对象进行强制类型检查，是Cocoa中常见的约定，NSString的isEqualToString:和NSTimeZone的isEqualToTimeZone:就是两个这样的例子。特定类的比较器（在这个例子中是isEqualToWidget:）负责执行name和data变量的等同性。</li>
</ul>


<p>在Cocoa框架的所有isEqualToType:方法中，nil都不是正当的参数，这些方法的实现在接收到nil参数时会抛出例外。然而为了向后兼容，Cocoa框架中的isEqual:方法可以接收nil值，在这种情况下返回NO。</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Property 使用注意事项]]></title>
    <link href="http://saick.net/blog/2013/05/28/propertyshi-yong-zhu-yi-shi-xiang/"/>
    <updated>2013-05-28T11:04:00+08:00</updated>
    <id>http://saick.net/blog/2013/05/28/propertyshi-yong-zhu-yi-shi-xiang</id>
    <content type="html"><![CDATA[<ul>
<li>NSString property的属性必须是copy</li>
<li>delegate property的属性是assign</li>
<li>dealloc 时，如果有delegate，要把delegate置成nilj,避免收到消息等</li>
<li>init 和dealloc中不要用self.XX=;</li>
</ul>


<h4>NSCoping</h4>

<p>Any object that you wish to set for a copy property must support NSCopying, which means that it should conform to the NSCopying protocol.</p>

<p>If you need to set a copy property’s instance variable directly, for example in an initializer method, don’t forget to set a copy of the original object:</p>

<p>```
&ndash; (id)initWithSomeOriginalString:(NSString *)aString {</p>

<pre><code>self = [super init];
if (self) {
    _instanceVariableForCopyProperty = [aString copy];
}
return self;
</code></pre>

<p>}
```</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Category 巧用-调试程序]]></title>
    <link href="http://saick.net/blog/2013/05/28/category-qiao-yong-diao-shi-cheng-xu/"/>
    <updated>2013-05-28T10:52:00+08:00</updated>
    <id>http://saick.net/blog/2013/05/28/category-qiao-yong-diao-shi-cheng-xu</id>
    <content type="html"><![CDATA[<h3>Category可以用来调试</h3>

<p>除了隐藏私有方法外，我主要用它截住函数。</p>

<p>例1：测试时我想知道TableViewCell有没有释放，就可以这样写</p>

<p>```
@implementation UITableViewCell(dealloc)
&ndash;(void)dealloc
{
   NSLog(@&ldquo;%@&rdquo;,NSStringFromSelector(_cmd));</p>

<pre><code>NSArray *array = allSubviews(self);         // allSubviews是cookBook里的函数，可以取一个view的所有subView ,在这个文档后面也有
NSLog(@"%@",array); 
[super dealloc]; 
</code></pre>

<p>}
@end
```</p>

<p>其它的类也可以这样写，你随便输出什么</p>

<p>例2：我调试程序，觉得table的大小变了，想找到在哪改变的，这样做：</p>

<p>```
 @implementation UITableView(setframe)
&ndash;(void)setFrame:(CGRect)frame
{
   NSLog(%&ldquo;%@&rdquo;,self);</p>

<pre><code>[super setFrame: frame]; 
</code></pre>

<p>}
@end
```</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[iOS 开发常见低级错误]]></title>
    <link href="http://saick.net/blog/2013/05/28/ios-kai-fa-chang-jian-di-ji-cuo-wu/"/>
    <updated>2013-05-28T10:19:00+08:00</updated>
    <id>http://saick.net/blog/2013/05/28/ios-kai-fa-chang-jian-di-ji-cuo-wu</id>
    <content type="html"><![CDATA[<p><strong><em>不断更新中。。。</em></strong></p>

<p>Aug 5, 2013</p>

<ul>
<li><h3>如果使用C++代码混编，找不到iostream等</h3>

<p>可能是.m中直接import的，这个需要注意改成mm或者修改编译方式</p></li>
</ul>


<p>May 28, 2013</p>

<ul>
<li><h3>不要调用[super  release]</h3>

<p>在dealloc里要调用[super dealloc]，千万不要调用[super release]</p></li>
</ul>

]]></content>
  </entry>
  
</feed>
