<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">

  <title><![CDATA[Category: iOS | Saick Blog - 专注技术，乐在其中]]></title>
  <link href="http://saick.net/blog/categories/ios/atom.xml" rel="self"/>
  <link href="http://saick.net/"/>
  <updated>2013-12-01T22:31:57+08:00</updated>
  <id>http://saick.net/</id>
  <author>
    <name><![CDATA[Eric Shi]]></name>
    
  </author>
  <generator uri="http://octopress.org/">Octopress</generator>

  
  <entry>
    <title type="html"><![CDATA[Does ARC support dispatch queues?]]></title>
    <link href="http://saick.net/blog/2013/12/01/does-arc-support-dispatch-queues/"/>
    <updated>2013-12-01T01:48:00+08:00</updated>
    <id>http://saick.net/blog/2013/12/01/does-arc-support-dispatch-queues</id>
    <content type="html"><![CDATA[<p><strong>If your deployment target is lower than iOS 6.0 or Mac OS X 10.8</strong></p>

<p>You need to use dispatch_retain and dispatch_release on your queue. ARC does not manage them.</p>

<p><strong>If your deployment target is iOS 6.0 or Mac OS X 10.8 or later</strong></p>

<p>ARC will manage your queue for you. You do not need to (and cannot) use dispatch_retain or dispatch_release if ARC is enabled.</p>

<!-- more -->


<p>Details</p>

<p>Starting in the iOS 6.0 SDK and the Mac OS X 10.8 SDK, every dispatch object (including a dispatch_queue_t) is also an Objective-C object. This is documented in the &lt;os/object.h> header file:</p>

<p><code>
 * By default, libSystem objects such as GCD and XPC objects are declared as
 * Objective-C types when building with an Objective-C compiler. This allows
 * them to participate in ARC, in RR management by the Blocks runtime and in
 * leaks checking by the static analyzer, and enables them to be added to Cocoa
 * collections.
 *
 * NOTE: this requires explicit cancellation of dispatch sources and xpc
 *       connections whose handler blocks capture the source/connection object,
 *       resp. ensuring that such captures do not form retain cycles (e.g. by
 *       declaring the source as __weak).
 *
 * To opt-out of this default behavior, add -DOS_OBJECT_USE_OBJC=0 to your
 * compiler flags.
 *
 * This mode requires a platform with the modern Objective-C runtime, the
 * Objective-C GC compiler option to be disabled, and at least a Mac OS X 10.8
 * or iOS 6.0 deployment target.
</code></p>

<p>This means you can store your queue in an NSArray or NSDictionary, or in a property with one of the strong, weak, unsafe_unretained, assign, or retain attributes. It also means that if you refer to your queue from a block, the block will retain the queue automatically.</p>

<p>So <strong>if your deployment target is at least iOS 6.0 or Mac OS X 10.8</strong>, and you have <em>ARC enabled</em>, ARC will retain and release your queue, and the compiler will flag any attempt to use dispatch_retain or dispatch_release as an error.</p>

<p><strong>If your deployment target is at least iOS 6.0 or Mac OS X 10.8</strong>, and you have <em>ARC disabled</em>, you must manually retain and release your queue, either by calling dispatch_retain and dispatch_release, or by sending the queue retain and release messages (like [queue retain] and [queue release]).</p>

<p>For compatibility with old codebases, you can prevent the compiler from seeing your queue as an Objective-C object by defining OS_OBJECT_USE_OBJC to 0. For example, you can put this in your .pch file (before any #import statements):</p>

<p>```</p>

<h1>define OS_OBJECT_USE_OBJC 0</h1>

<p>```</p>

<p>or you can add OS_OBJECT_USE_OBJC=0 as a preprocessor macro in your build settings. If you set OS_OBJECT_USE_OBJC to 0, ARC will not retain or release your queue for you, and you will have to do it yourself using dispatch_retain and dispatch_release.</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[iOS Crash:nested pop animation can result in corrupted navigation bar nested pop animation can result in ..]]></title>
    <link href="http://saick.net/blog/2013/12/01/ios-crash-nested-pop-animation-can-result-in-corrupted-navigation-bar-nested-pop-animation-can-result-in/"/>
    <updated>2013-12-01T01:37:00+08:00</updated>
    <id>http://saick.net/blog/2013/12/01/ios-crash-nested-pop-animation-can-result-in-corrupted-navigation-bar-nested-pop-animation-can-result-in</id>
    <content type="html"><![CDATA[<p><a href="http://yul100887.blog.163.com/blog/static/20033613520137205121620/">Origin</a></p>

<p>Nested pop animation can result in corrupted navigation bar</p>

<p>Finishing up a navigation transition in an unexpected state. Navigation Bar subview tree might get corrupted.</p>

<h3>【情况一】</h3>

<p>出现此问题的原因是在A界面弹出B界面完成后，又掉A界面POP出栈，这必然导致以上问题。如下，在弹出personalController后面，又在后面调用了[self.navigationController popViewControllerAnimated:YES];将自己弹出！解决方法，还用说吗？｛删除最后一行代码，要弹出此界面，自然有自己的返回按钮来处理｝，至少在B界面未POP以前，A界面是无论如何也不能将自己POP去消毁！</p>

<!-- more -->


<p><code>
NSString *memberId = [dictionary objectForKey:@"PlayerNo"];
PersonalInfoViewController* personalController = [[PersonalInfoViewController alloc] init];
[personalController.navigationItems etHidesBackButton:YES];
[personalController setMemberId:memberId];
[self.navigationController pushViewController:personalController animated:YES];
[personalController release];
[self.navigationController popViewControllerAnimated:YES];
</code></p>

<h3>【情况二】</h3>

<p>nested push animation can result in corrupted navigation bar <br/>
嵌套的navigation动画会造成  navigation bar 错误<br/>
具体表现为上一层的titleview 和这一层重叠， navigationbaritem维持上一层的左按钮,右按钮,系统警告提示nested push animation can result in corrupted navigation bar</p>

<p>从头到尾分析了整个项目的代码， 最后确认问题根源——<strong>自定义UITabbarController</strong>引发的血案
项目中使用了自定义的UITabbarController ，修改里面的tabbar视图， 在这个UITabbarController 中实现了viewWillAppear方法， 里面没有加super viewWillAppear ， 结果导致了这一连串的问题，</p>

<ul>
<li>整个软件里面，都会出现弹一次模态窗口，导航视图就会动画乱序，</li>
<li>导航视图前进后退过快， 导致导航栏嵌套， 一个上面覆盖另一个。</li>
</ul>


<p>```
&ndash; (void)viewWillAppear:(BOOL)animated
{</p>

<pre><code>[super viewWillAppear:animated];
</code></pre>

<p>}
```</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[iOS 7教程：浅析Text Kit]]></title>
    <link href="http://saick.net/blog/2013/11/23/ios-7jiao-cheng-qian-xi-text-kit/"/>
    <updated>2013-11-23T22:06:00+08:00</updated>
    <id>http://saick.net/blog/2013/11/23/ios-7jiao-cheng-qian-xi-text-kit</id>
    <content type="html"><![CDATA[<p>转自<a href="http://beyondvincent.com/blog/2013/11/12/121-brief-analysis-text-kit/">破船</a>的博客</p>

<p>Text Kit是iOS 7中引入的一个新功能，非常值得开发者使用，下面先看看本文的目录结构：</p>

<ul>
<li>什么是Text Kit</li>
<li>Text Kit架构</li>
<li>Text Kit特点</li>
<li>Text Kit功能概述</li>
<li>Text Kit中重要的一些对象</li>
<li>Text Kit示例</li>
<li>小结</li>
<li>推荐Text Kit学习资源</li>
</ul>


<!-- more -->


<h3>什么是Text Kit</h3>

<p>在iOS7中，苹果引入了Text Kit&mdash;Text Kit是一个快速而又现代化的文字排版和渲染引擎。Text Kit在UIKit framework中的定义了一些类和相关协议，它最主要的作用就是为程序提供文字排版和渲染的功能。在程序中，通过Text Kit可以对文字进行存储(store)、布局(lay out)，以及用最精细的排版方式(例如文字间距、换行和对齐等)来显示文本内容。 苹果引入Text Kit的目的并非要取代已有的Core Text，Core Text的主要作用也是用于文字的排版和渲染中，它是一种先进而又处于底层技术，如果我们需要将文本内容直接渲染到图形上下文(Graphics context)时，从性能和易用性来考虑，最佳方案就是使用Core Text。而如果我们直接利用苹果提供的一些控件(例如UITextView、UILabel和UITextField等)对文字进行排版，无疑就是借助于UIkit framework中Text Kit提供的API。</p>

<h3>Text Kit架构</h3>

<p>下面，我们通过图1(此图来自WWDC2013 Session 210)来了解一下Text Kit的架构。图1是基于iOS 7绘制的，从图中，我们可以看到Text Kit是基于Core Text构建的，它通过Core Text与Core Graphics进行交互。而UI控件(UILabel、UITextField和UITextView)则构建于Text Kit之上，可见这些文本控件可以利用Text Kit提供的API来对文字进行排版和渲染处理。 从图中我们也可以看到SDK提供的UIWebView是基于WebKit的，它不能使用Text Kit提供的功能。</p>

<p><a href="http://www.flickr.com/photos/105999540@N03/11028898935/" title="2013-11-24-1 by EricShj, on Flickr"><img src="http://farm8.staticflickr.com/7439/11028898935_e836a8c934.jpg" width="500" height="211" alt="2013-11-24-1"></a></p>

<p>图1 Text Kit在iOS 7 SDK中的位置</p>

<p>我们再来看看图1中的相关组件在iOS6里面是如何对应的，如图2所示，可以看出在iOS 6中是没有Text Kit，并且UILabel、UIText和UITextView是基于String Drawing和WebKit构建的。其中String Drawing是与Core Graphics直接通讯。</p>

<p><a href="http://www.flickr.com/photos/105999540@N03/11029000326/" title="2013-11-24-2 by EricShj, on Flickr"><img src="http://farm8.staticflickr.com/7430/11029000326_f1345af879.jpg" width="500" height="242" alt="2013-11-24-2"></a></p>

<p>图2 在iOS 6中并没有Text Kit</p>

<h3>Text Kit特点</h3>

<p>从上面的介绍中，我们可以了解到Text Kit在UIKit中的作用非常重要。Text Kit在实际开发中具有如下特点：</p>

<ul>
<li>1.在UI控件中Text Kit完全掌控着文字的排版和渲染</li>
<li>2.UITextView、UITextField和UILabel是构建于Text Kit之上的</li>
<li>3.能够与动画、UICollectionView和UITableView做到无缝集成</li>
<li>4.Text Kit具有这样一些能力：Subclassing、Delegation和Notifcation。</li>
</ul>


<h3>Text Kit功能概述</h3>

<p>下面我们看看通过Text Kit，都能实现那些功能(这里列出了是一些常用和重要功能)：</p>

<ul>
<li>1.对文字进行分页或多列排版</li>
<li>2.支持文字的换行、折叠和着色等处理</li>
<li>3.可以调整字与字之间的距离、行间距、文字大小、指定特定的字体</li>
<li>4.支持富文本编辑，可以自定义文字截断</li>
<li>5.支持凸版印刷效果(letterpress)</li>
<li>6.支持数据类型的检测(例如链接、附件等)</li>
</ul>


<p>如图3，是利用Text Kit对文字做的分页排版</p>

<p><a href="http://www.flickr.com/photos/105999540@N03/11028898985/" title="2013-11-24-3 by EricShj, on Flickr"><img src="http://farm8.staticflickr.com/7420/11028898985_e42af249cf.jpg" width="500" height="303" alt="2013-11-24-3"></a></p>

<p>图3 利用Text Kit做的分页排版效果</p>

<p>再看图4，是利用Text Kit做的换行处理，其中对某个路径范围做了排除。</p>

<p><a href="http://www.flickr.com/photos/105999540@N03/11029105983/" title="2013-11-24-4 by EricShj, on Flickr"><img src="http://farm6.staticflickr.com/5530/11029105983_dba9ffd9fb.jpg" width="500" height="359" alt="2013-11-24-4"></a></p>

<p>图4 利用Text Kit做的换行处理效果</p>

<p>再来看看利用Text Kit做的凸版印刷效果，如图5所示</p>

<p><a href="http://www.flickr.com/photos/105999540@N03/11029054444/" title="2013-11-24-5 by EricShj, on Flickr"><img src="http://farm3.staticflickr.com/2885/11029054444_fd67572185.jpg" width="500" height="365" alt="2013-11-24-5"></a></p>

<p>图5 利用Text Kit做的凸版印刷效果</p>

<h3>Text Kit中重要的一些对象</h3>

<p>下面我们来看看Text Kit中重要的几个对象。</p>

<p><a href="http://www.flickr.com/photos/105999540@N03/11029054134/" title="2013-11-24-6 by EricShj, on Flickr"><img src="http://farm3.staticflickr.com/2849/11029054134_87158b12d4.jpg" width="500" height="293" alt="2013-11-24-6"></a></p>

<p>图6 Text Kit中重要的几个对象</p>

<p>如图6所示，Text Kit中主要有4个重要的对象。</p>

<ul>
<li>1.Text View是用来显示文本内容的控件，主要包括UILabel、UITextView和UITextField。</li>
<li>2.Text containers对应着NSTextContainer类。NSTextContainer定义了文本可以排版的区域。一般来说，都是矩形区域，当然，也可以根据需求，通过子类化NSTextContainer来创建别的一些形状，例如圆形、不规则的形状等。NSTextContainer不仅可以创建文本可以填充的区域，它还维护着一个数组——该数组定义了一个区域，排版的时候文字不会填充该区域，因此，我们可以在排版文字的时候，填充非文本元素(例如图片，如图4所示)。</li>
<li>3.Layout manager对应着NSLayoutManager类。该类负责对文字进行编辑排版处理——通过将存储在NSTextStorage中的数据转换为可以在视图控件中显示的文本内容，并把统一的字符编码映射到对应的字形(glyphs)上，然后将字形排版到NSTextContainer定义的区域中。</li>
<li>4.Text storage对应着NSTextStorage类。该类定义了Text Kit扩展文本处理系统中的基本存储机制。NSTextStorage继承自NSmutableAttributedString，主要用来存储文本的字符和相关属性。另外，当NSTextStorage中的字符或属性发生了改变，会通知NSLayoutManager，进而做到文本内容的显示更新。</li>
</ul>


<p>通常情况下，NSTextStorage、NSLayoutManager和NSTextContainer是一一对应的。如图7所示关系：</p>

<p><a href="http://www.flickr.com/photos/105999540@N03/11028999346/" title="2013-11-24-7 by EricShj, on Flickr"><img src="http://farm4.staticflickr.com/3722/11028999346_3d78e9639e.jpg" width="500" height="41" alt="2013-11-24-7"></a></p>

<p>图7 普通排版</p>

<p>当然，如果需要将文字显示为多列，或多页，可以按照如图8所示关系——使用多个NSTextContainer。</p>

<p><a href="http://www.flickr.com/photos/105999540@N03/11029104793/" title="2013-11-24-8 by EricShj, on Flickr"><img src="http://farm6.staticflickr.com/5472/11029104793_ed7de38158.jpg" width="500" height="64" alt="2013-11-24-8"></a></p>

<p>图8 多页或者多列排版</p>

<p>如果针对不同的排版方式，则可以使用多个NSLayoutManager，如图9所示</p>

<p><a href="http://www.flickr.com/photos/105999540@N03/11029104933/" title="2013-11-24-9 by EricShj, on Flickr"><img src="http://farm4.staticflickr.com/3826/11029104933_824d194d5f.jpg" width="500" height="59" alt="2013-11-24-9"></a></p>

<p>图9 不同的排版方式</p>

<p>如图10所示，通过形象的方式，对UITextView的组成做了分解。通常，我们在设备上只能看到最右边的文本显示界面，而内部的NSTextStorage、NSLayoutManager和NSTextContainer是看不出来的。通常由NSLayoutManager从NSTextStorage中读取出文本数据，然后根据一定的排版方式，将文本排版到NSTextContainer中，再由NSTextContainer结合UITextView将最终效果显示出来。</p>

<p><a href="http://www.flickr.com/photos/105999540@N03/11029105053/" title="2013-11-24-10 by EricShj, on Flickr"><img src="http://farm8.staticflickr.com/7294/11029105053_875c954204.jpg" width="500" height="319" alt="2013-11-24-10"></a></p>

<p>图10 UITextView的分解</p>

<h3>Text Kit示例</h3>

<p>前面对Text Kit做了一些介绍，下面我们配合一个例子(图文排版)，来进一步加深对Text Kit的认识。具体实现步骤如下：</p>

<ul>
<li>1.打开Xcode 5，新建一个Single View Application模板的程序，将工程命名为ExclusionPath。</li>
<li>2.打开Main.storyboard文件，然后再默认View Controller的View里面分别添加一个UITextView和UIImageView。并将这两个控件连接到ViewController.h中(名称分别为textView何imageView)。然后给textView设置一些字符串，imageView设置一个图片。</li>
<li>3.打开ViewController.m文件，找到viewDidLoad方法，用如下代码替换该方法：</li>
</ul>


<p>```
&ndash; (void)viewDidLoad
{</p>

<pre><code>[super viewDidLoad]; 

//创建一个平移手势对象，该对象可以调用imagePanned：方法 
UIPanGestureRecognizer *panGes = [[UIPanGestureRecognizer alloc] initWithTarget:self action:@selector(imagePanned:)]; 
[self.imageView addGestureRecognizer:panGes]; 

self.textView.textContainer.exclusionPaths = @[[self translatedBezierPath]]; 
</code></pre>

<p>}
```</p>

<p>在上面的代码中，给imageView添加了一个平移手势。另外通过调用translatedBezierPath方法，给textView的textContainer设置exclusionPaths属性值。表示需要排除的区域（也就是图片在排版中显示的位置）。</p>

<ul>
<li>4.下面来看一下translatedBezierPath方法的实现，如下代码所示</li>
</ul>


<p>```
&ndash; (UIBezierPath *)translatedBezierPath
{</p>

<pre><code>CGRect butterflyImageRect = [self.textView convertRect:self.imageView.frame fromView:self.view]; 
UIBezierPath *newButterflyPath = [UIBezierPath bezierPathWithRect:butterflyImageRect]; 

return newButterflyPath; 
</code></pre>

<p>}
```</p>

<p>在上面的代码中，利用imageView的frame属性创建了一个UIBezierPath，然后将该值返回。</p>

<ul>
<li>5, 还记得第3步中创建的平移手势吗。里面有一个action需要实现imagePanned:，下面来看看这个方法的实现：</li>
</ul>


<p>```
&ndash; (void)imagePanned:(id)sender
{</p>

<pre><code>if ([sender isKindOfClass:[UIPanGestureRecognizer class]]) { 
    UIPanGestureRecognizer *localSender = sender; 

    if (localSender.state == UIGestureRecognizerStateBegan) { 
        self.gestureStartingPoint = [localSender translationInView:self.textView]; 
        self.gestureStartingCenter = self.imageView.center; 
    } else if (localSender.state == UIGestureRecognizerStateChanged) { 
        CGPoint currentPoint = [localSender translationInView:self.textView]; 

        CGFloat distanceX = currentPoint.x - self.gestureStartingPoint.x; 
        CGFloat distanceY = currentPoint.y - self.gestureStartingPoint.y; 

        CGPoint newCenter = self.gestureStartingCenter; 

        newCenter.x += distanceX; 
        newCenter.y += distanceY; 

        self.imageView.center = newCenter; 

        self.textView.textContainer.exclusionPaths = @[[self translatedBezierPath]]; 
    } else if (localSender.state == UIGestureRecognizerStateEnded) { 
        self.gestureStartingPoint = CGPointZero; 
        self.gestureStartingCenter = CGPointZero; 
    } 
} 
</code></pre>

<p>}
```</p>

<p>在上面的代码中首先根据平移的距离来设置imageView的位置，然后利用translatedBezierPath方法重新计算了一下排除区域。</p>

<ul>
<li>6, 至此代码编写完毕，下面来运行程序，看看实际效果。如图11所示：</li>
</ul>


<p><a href="http://www.flickr.com/photos/105999540@N03/11028998926/" title="2013-11-24-11 by EricShj, on Flickr"><img src="http://farm4.staticflickr.com/3709/11028998926_73393ee43a.jpg" width="332" height="500" alt="2013-11-24-11"></a></p>

<p>图11 运行效果</p>

<h3>小结</h3>

<p>实际上，上面的示例，只是揭秘了Text Kit功能的冰山一角。从iOS7及以后的版本中，Text Kit在UIKit framework里面占据重要的地位，Text Kit在文字处理方面，具有非常强大的功能，并且开发者可以对Text Kit进行定制和扩展。据悉，苹果利用了2年的时间来开发Text Kit，相信这对许多开发者来说都是福音。</p>

<p>推荐Text Kit学习资源
更多关于Text Kit的学习资料，请参考下面的内容：
wwdc视频:
Introducing Text Kit
Advanced Text Layouts and Effects with Text Kit
Using Fonts with Text Kit</p>

<p>苹果官方参考文档
Text Programming Guide for iOS.pdf
NSLayoutManager Class Reference for iOS.pdf
NSLayoutManagerDelegate Protocol Reference for iOS.pdf
NSTextContainer Class Reference for iOS.pdf
NSTextStorage Class Reference for iOS.pdf
NSTextStorageDelegate Protocol Reference for iOS.pdf</p>

<p>苹果官方示例：
IntroToTextKit</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Autolayout及VFL经验分享]]></title>
    <link href="http://saick.net/blog/2013/11/23/autolayoutji-vfljing-yan-fen-xiang/"/>
    <updated>2013-11-23T17:53:00+08:00</updated>
    <id>http://saick.net/blog/2013/11/23/autolayoutji-vfljing-yan-fen-xiang</id>
    <content type="html"><![CDATA[<p><a href="http://www.cocoachina.com/applenews/devnews/2013/1108/7322.html">Origin</a></p>

<p>这篇不是什么教程, Cocoa autolayout出来蛮久了。以前多次想去深入研究一下，每次都很蛋疼无序。这东西是在有些搞。尤其习惯了code写布局的。看到Visual format language，简直要掀桌子。搜教程，满世界都是，没有一个讲得透彻的。例子空洞。你们就只会３个控件横向布局对法？浑浑噩噩看了多篇。有了点总结。槽不多吐了。简单讲讲。</p>

<!--more-->


<h3>Autolayout，开始于iOS6.0</h3>

<h4>一.什么时候用autolayout比较适合</h4>

<ul>
<li>１.不负责任的骑墙派说法：apple的设备越来越多了，你的应用应该都使用al。（并且用sb）</li>
<li>２.要看应用内容决定。如果你的内容是信息众多，同时需要展示的类别也很多，尺寸动态不定，甚至这些是在列表中的。（如社交应用）。Al能给于很大的帮助。</li>
<li>３.Mac os的应用。现在都做iOS了。mac app的窗口，会有大小变化。al比较合适。</li>
<li>４.支持多向转屏的iPad应用。（有需要支持多方向iphone场景么？那么长，脑残了？）</li>
<li>５.其他业务不复杂,页面较少的应用，其实，cocoa程序员写了多年code都有自己的ui编程习惯，这些习惯对于他们来说是很高效的。就算是第一项所说，布局的坐标都是相对的。</li>
</ul>


<p>如果是习惯于code写布局的，建议可以继续沿用，同时也要学习al。自我感觉al和传统布局写法，工作量不会相差太多。但是VFL用熟练了以后会有很大的改善。</p>

<h4>二.autolayout的基础理论</h4>

<p>al的核心出发点是</p>

<ul>
<li>1.view具有自我计算尺寸，布局的能力。通过它自身的内容，能够得到尺寸。</li>
<li>2.view的布局位置，确定于它与superview及其他view的关系。</li>
<li>3.与传统的autoresizingmask自适应相比，al更精确，能绝对的确定view的布局。</li>
<li>4.view不一定需要一个初始的rect。al中，view如果有足够的constraint，便可以确定自己的尺寸和位置，并且知道自己和其他view的关系。即，想确定view的布局，就给它（们）添加constraint。</li>
</ul>


<h4>三.xib下的autolayout</h4>

<p>似乎al和xib布局模式生来就是要搞在一起的。用xib加al，view布局非常简单容易。编程工作立刻变成了美工的连线拼图游戏。</p>

<p>开启xib或者sb后，选择需要view(s)。选择menu的Editor，选择Pin。子菜单的项目就是可用的constraints。</p>

<p>Width:固定自身宽度</p>

<p>Height:。。。</p>

<p>H- Spacing: 固定两个view的水平间距</p>

<p>V- Spacing:。。。</p>

<p>下面４个分别是view相对于superview的左、右、上、下的间距</p>

<p>Widths Equally:两个view保持宽度相同</p>

<p>Heights Equally:。。。</p>

<p>xib界面右下角工具条也有可以编辑constraint的方式：</p>

<p>每个constraint添加后都是可以编辑的。选中某个constraint后开启右边栏选inspector。可以修改数值。（这个数值是view间的偏移量）和优先级。</p>

<p>自己慢慢拖着玩去。这不是傻瓜教程。点到位，自己研究。</p>

<p>xib下的al比较直观。可以基本看到效果和误差值。还有不正确的constraint的提示。少了constraint编译器会补，多了会提示报错。（不过都会引起界面布局不对，自己慢慢调吧，哥现在还是满篇alert，没有让编译器感觉矛盾费解的constraint，都是可以work的。）</p>

<p>还有resolve的方式解决constraint的问题，抱歉，我不会。</p>

<h4>四.编码方式使用autolayout</h4>

<p>对于页面不多，的普通应用。xib/sb加al。拖拖拽拽。娱乐中就可以完成UI的工作。al的确给于了不少方便。</p>

<p>不过多年的强迫症程序猿怎么会忍受这种很逊的方式。（拖积木？不敲代码？好像一天没做事。）</p>

<p>1.Visual format language　（应该不算语言）
Apple的工程师很有爱，发明了这种哭笑不得的象形文字。感觉它就是种解析方式。</p>

<p>Apple的官方文档给出了少之又少的文档和坑爹的例子。（视频我没看，不知道怎么样）网上的同学们也写了点不痛不痒的几句代码。你这是学了１＋１就让人搞微积分的节奏么？要写不写清楚，不如不写。</p>

<p>从厚道的老外那看了几篇。自己体会了些，分享给大家。只是个基本水平吧，会了这些，代码写al应该没有问题了。深入的我也还不会，希望遇到更有爱的牛人分享。</p>

<p>VFL在程序中由支持：</p>

<p><code>
+ (NSArray *)constraintsWithVisualFormat:(NSString *)format options:(NSLayoutFormatOptions)opts metrics:(NSDictionary *)metrics views:(NSDictionary *)views;   
</code></p>

<ul>
<li>它返回一组constraint.</li>
<li>format是你的VFL字串，等下讲。</li>
<li>opts自己点去头文件看。有些情况会用，等下有例子。</li>
<li>metrics是一个奇妙的字典，是你自己定义的。这个字典里面的key可以写在format字串中。编译器解析时，自动替换为metrics字典中的value。等下有例子。</li>
<li>views是需要constraint关系的所有view.(也可以是一个)</li>
</ul>


<p>2.VFL例子</p>

<p>写vfl字串的时候，脑海里要想象出画面的合理性。不合理的constraint会导致程序运行时报错或者直接崩溃。</p>

<p>随便写几个</p>

<p><code>
NSDictionary *dict1 = NSDictionaryOfVariableBindings(_boxV,_headerL,_imageV,_backBtn,_doneBtn);   
NSDictionary *metrics = @{@"hPadding":@5,@"vPadding":@5,@"imageEdge":@150.0};   
NSString *vfl = @"|-hPadding-[_boxV]-hPadding-|";   
NSString *vfl0 = @"V:|-25-[_boxV]";   
NSString *vfl3 = @"V:|-vPadding-[_headerL]-vPadding-[_imageV(imageEdge)]-vPadding-[_backBtn]-vPadding-|";   
</code></p>

<p>dict1就是api 中需要的最后一个参数views。由上述宏来完成。</p>

<p>metrics定义了一些vfl中要用的参数。
下面有些vfl字串，一看便知如何使用metrics。</p>

<p>看到：</p>

<p>1) &ldquo;|"表示superview. |-间距-[view1对象名]&ndash;(>=20)&ndash;[view2对象名] 不写H/V就表示横向，间距可以写固定值也可写>/&lt;。形象化的理解，&rdquo;|&ldquo;是用来确定view上、下、左、右关系的。 想要确定从上到下的关系，就加V:|。那么这个vfl字串就可以描述从上到下的view们的关系。</p>

<p>2) 看到vfl3里面，方括号表示view，圆括号表示尺寸数值。支持大小等于。或者另一个view　|&ndash;[view1(view2)]，v１的宽度等于v２。</p>

<p>3) 优先级用＠表示。如V:|-50@750-[view(55)]，或者写到metrics里面更好。 具体定义查看UILayoutPriority。有几个固定的数值。1000表示必须支持。</p>

<p>4) options，这个要看具体需要。如果是竖排V布局，可以添加NSLayoutFormatAlignAllLeft，让他们对齐。根据需要也可以添加按位或NSLayoutFormatAlignAllLeft | NSLayoutFormatAlignAllRight。（鬼知道什么需要，自己看经验吧）</p>

<p>5) 写好以后一般把constraint添加给superview：</p>

<p><code>
NSString *vfl1 = @"|-hPadding-[_headerL]-hPadding-|";   
[self.view addConstraints:[NSLayoutConstraint constraintsWithVisualFormat:vfl1 options:0 metrics:metrics views:dict1]];   
</code></p>

<p>6)还有一个api用于生成单个constaint</p>

<p><code>
+(id)constraintWithItem:(id)view1 attribute:(NSLayoutAttribute)attr1 relatedBy:(NSLayoutRelation)relation toItem:(id)view2 attribute:(NSLayoutAttribute)attr2 multiplier:(CGFloat)multiplier constant:(CGFloat)c;  
</code></p>

<p>对于参数，记得，view1.attr1 = view2.attr2 * multiplier + constant就好。
这个是不用VFL的，好理解，但是不方便。如果用这个写。工作两不会比传统布局少多少。</p>

<h4>五.实际操作中的问题</h4>

<p>上面都是理论，世界操作会有些奇怪的问题要注意。这节才是重点。</p>

<p>xib模式，没啥要注意的，xib里报warning就报吧，我也不知道怎么弄，一切正常就好。</p>

<p><strong>编码模式中，注意</strong></p>

<ul>
<li>1.addConstraint(s)前，view应该去部被addSubView上去了。</li>
<li>2.不必给views写frame</li>
<li>3.给必要的view关掉AutoresizeingMask。[_aView setTranslatesAutoresizingMaskIntoConstraints:NO];</li>
<li>4.UILabel换行要写linebreakMode,要写numberOfLines(iOS7.0默认好像是1，坑爹了)</li>
<li>5.UILabel要想换行，一定要添加preferredMaxLayoutWidth。否则没法初始化宽度。</li>
</ul>


<p>编码模式感受到的最大方便。label换行不用写行高计算了。完全自动适应。label所在的superview也会自动计算rect。这才是al的精华。</p>

<p>所以，可以不用写这些了：</p>

<p><div class='bogus-wrapper'><notextile><figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
<span class='line-number'>11</span>
<span class='line-number'>12</span>
<span class='line-number'>13</span>
<span class='line-number'>14</span>
<span class='line-number'>15</span>
<span class='line-number'>16</span>
<span class='line-number'>17</span>
<span class='line-number'>18</span>
<span class='line-number'>19</span>
<span class='line-number'>20</span>
<span class='line-number'>21</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>/*&lt;/p>
</span><span class='line'>
</span><span class='line'>&lt;pre>&lt;code>if([[UIDevice currentDevice].systemVersion floatValue]&lt;7.0){  
</span><span class='line'>    CGSize titleS = [title sizeWithFont:[_headerL font]  
</span><span class='line'>                       constrainedToSize:CGSizeMake(270.0, CGFLOAT_MAX)  
</span><span class='line'>                           lineBreakMode:NSLineBreakByWordWrapping];  
</span><span class='line'>
</span><span class='line'>    _headerL.frame = CGRectMake(_headerL.frame.origin.x, _headerL.frame.origin.y,  
</span><span class='line'>                                _headerL.frame.size.width, titleS.height);  
</span><span class='line'>}else{  
</span><span class='line'>    CGRect titleR = [title boundingRectWithSize:CGSizeMake(270.0, CGFLOAT_MAX)  
</span><span class='line'>                                        options:NSStringDrawingUsesLineFragmentOrigin  
</span><span class='line'>                                     attributes:nil  
</span><span class='line'>                                        context:nil];  
</span><span class='line'>    headerL.frame = CGRectMake(_headerL.frame.origin.x, _headerL.frame.origin.y,  
</span><span class='line'>                               _headerL.frame.size.width, titleR.size.height);  
</span><span class='line'>}  
</span><span class='line'>*/
</span><span class='line'>&lt;/code>&lt;/pre>
</span><span class='line'>
</span><span class='line'>&lt;p></span></code></pre></td></tr></table></div></figure></notextile></div></p>

<p>我遇到了些问题，至今没有解决：</p>

<p>纯代码写的Viewcontroller 无法正常显示al布局。用空白的xib做了vc后，其余再用code写，就正常了。怀疑自己写的self.view，还需要针对autolayout做什么处理。至此，al，基本功能已经可以为你服务了。的确方便很多，建议还是使用VFL代码模式，熟练后能够提高很多效率。</p>

<p>引用别的同学的评论：</p>

<p><em>最后一个问题：可以试一下self.view=自定义的视图； 不要用[self.view addSubview:&hellip;];</em></p>

<p><a href="https://www.dropbox.com/s/vizq53ig4e1z7io/20131123_AutoLayoutTest.zip">demo</a></p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[iOS开发：从新手到专家的一些建议]]></title>
    <link href="http://saick.net/blog/2013/11/23/ioskai-fa-cong-xin-shou-dao-zhuan-jia-de-xie-jian-yi/"/>
    <updated>2013-11-23T17:32:00+08:00</updated>
    <id>http://saick.net/blog/2013/11/23/ioskai-fa-cong-xin-shou-dao-zhuan-jia-de-xie-jian-yi</id>
    <content type="html"><![CDATA[<p><a href="http://www.cocoachina.com/applenews/devnews/2013/1118/7371.html">Origin</a></p>

<p>虽然你有可能在一周内学习到iOS开发的本质，但想要精通iOS开发需则要花费更长的时间。问题是你如何从新手变成专家？在这篇文章中，我们主要就这个主题给出一些建议（如果你有好的建议和相关文章欢迎分享给更多开发者）</p>

<!-- more -->


<h3>1.练习，练习还是练习</h3>

<p>iOS开发没有捷径可走。这是我在继续这个话题之前需要强调的东西，因为摆脱任何常常浮现于你脑海的幻想很重要。如果你仅仅在星期天的4PM和5PM之间学习/练习编程，那么你不会成为一个熟练的iOS开发者。不要误会我的意思，这么做可能会很有趣，但是它很难让你成为一个老练的专业的iOS开发者。除了极少数的人，大部分人都需要不断的练习和实践。如果你还没有准备好投入大量时间，这时候最好重新审视你的目标和理想。</p>

<h3>2.向其他人学习</h3>

<p>提升开发技能和采用最佳实践的最好策略之一是学习别人的代码。这不仅仅意味着浏览Stack Overflow，但更重要的是其他开发者的各种开源类库和代码片段。</p>

<p>不管何时你一头扎进各种类库的学习，比如AFNetworking或者Magical Record，很关键的一点是不要被各种代码淹没。有可能你不理解各种库中的代码，但这不是真正的关键，重点是从一个更高的层次来看源码和尽可能多地学习，比如<em>命名规范</em>、<em>最佳实践</em>&amp;以及<em>设计模式</em>等。</p>

<p>除了学习别人的代码外，创建你自己的类库是一个最好的学习方法。不久前，我用Core Data作为数据层开发了一款app，我没有使用Magical Record，我决定通过学习Magical Record创建自己的库，并重新创建了我需要的功能。这种方法不仅帮我创建了一个更加灵活的库，也让我学习到很多Magical Record内部的工作原理。</p>

<h3>3. 不要仅仅复制和粘贴</h3>

<p>这一点让我看到了正确学习方式的另一个关键面：不要不动脑子简单地复制和粘贴。我们常常会使用我们在Stack Overflow或者苹果开发者论坛找到的各种代码片段，但是不要为了偷懒简单地复制粘贴你从网络上找到的代码，这样你很难彻底理解它。最大的危险在于这可能会导致意外的行为，以致于你的代码以后都很难调试和修复。</p>

<p>有时候，复制别人的代码片段看着可能已经解决了你遇到的问题，但是我强烈建议不要这么做。阅读代码，理解你往代码库添加的东西，可能的话定制你需要的解决方案。不用说，这并不适用于开发者积极维护的库或框架。在项目中使用Magical Record前，如果你需要仔细检查它，那么我确信你已经理解了不同之处。使用你自己的常识。</p>

<h3>4. 模式</h3>

<p>Cocoa和Objective-C在很多方面都不同于其他编程语言和环境。这意味着他们有自己独特的模式和最佳实践。我确信你已经熟悉了一些常见的模式，比如委托和通知。但还有很多模式可以开发过程中帮助你，比如单例模式、观察者模式以及通用模式等。Cocoa Fundamentals Guide很好地概述了Cocoa中大部分常用模式。</p>

<h3>5.了解你的工具</h3>

<p>作为一个开发者并不仅仅是理解语言和框架，理解你每天使用的工具同样重要。对于iOS开发来说，这意味着你需要很好地理解Xcode和其他可能用到的工具，比如PonyDebugger和Charles。如果你想学习一些额外的技巧，你可能会对我此前的一篇文章（iOS Quick Tip: 7 Tips to Speed Up Your Development）感兴趣。</p>

<h3>6.与时俱进</h3>

<p>即使你不能参加苹果一年一度的开发者大会&mdash;WWDC，但浏览大量的会议视频是个很好的学习方法，你可以观看你感兴趣的专题视频，它们都是由在某方面擅长的工程师演讲，他们可以告诉你一些细节信息以及相关使用说明。另外，你还可以多关注优秀的开发者，他们会定期写一些技术文章，比如比如Matt Gemmell、 Aaron Hillegass以及Mike Ash，你可以在我为Mobiletuts+写的这篇“Where To Go Next”文章中找到更多学习资源。</p>

<h3>7.学习其他语言</h3>

<p>我已经注意到学习新语言或者使用新框架让我对软件开发的整体理解有了明显提高。这种方法的优点在于不会限制你对最熟悉语言的认知和它潜在可能性的理解。我最近在研究Ember.js，并了解到它的创建者 Yehuda Katz和Tom Dale是从Cocoa获得的灵感。Ember.js对mvc的实现并没有遵循JavaScript framework，不过如果你熟悉cocoa的话，就不会感觉到奇怪了。</p>

<p>对于软件开发来说，没有最好的语言，每种语言都有自己的优势和劣势。但是好的一面在于或多或少他们都有所不同，这使得学习新语言变得更加有趣和更有启发性。比如对我来说，Ruby在写DRY (Don’t Repeat Yourself)、易读的、干净的代码方面让我大开眼界。</p>

<h3>总结</h3>

<p>如果你不想花费时间成为一个更好的程序员，那么你可能要重新考虑下为什么你把成为一个程序员摆在首位。但如果你会因为一个可以帮你的新类库或者开发工具而兴奋，那么随着时间的流逝，你在提高自身技能方面可能不会有什么问题。你真的必须热爱你所做的事情，并在这面擅长，这一点尤其适用于编程。不管什么人告诉你，你不会在一夜之间成为一个老练的开发者，但如果你保持不间断的学习，并细心打磨自己的“手艺”，我想你的技术会有很好的提高。</p>
]]></content>
  </entry>
  
</feed>
