<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">

  <title><![CDATA[Category: iOS | Saick Blog - 专注技术，乐在其中]]></title>
  <link href="http://saick.net/blog/categories/ios/atom.xml" rel="self"/>
  <link href="http://saick.net/"/>
  <updated>2013-11-23T17:43:36+08:00</updated>
  <id>http://saick.net/</id>
  <author>
    <name><![CDATA[Eric Shi]]></name>
    
  </author>
  <generator uri="http://octopress.org/">Octopress</generator>

  
  <entry>
    <title type="html"><![CDATA[iOS开发：从新手到专家的一些建议]]></title>
    <link href="http://saick.net/blog/2013/11/23/ioskai-fa-cong-xin-shou-dao-zhuan-jia-de-xie-jian-yi/"/>
    <updated>2013-11-23T17:32:00+08:00</updated>
    <id>http://saick.net/blog/2013/11/23/ioskai-fa-cong-xin-shou-dao-zhuan-jia-de-xie-jian-yi</id>
    <content type="html"><![CDATA[<p><a href="http://www.cocoachina.com/applenews/devnews/2013/1118/7371.html">Origin</a></p>

<p>虽然你有可能在一周内学习到iOS开发的本质，但想要精通iOS开发需则要花费更长的时间。问题是你如何从新手变成专家？在这篇文章中，我们主要就这个主题给出一些建议（如果你有好的建议和相关文章欢迎分享给更多开发者）</p>

<!-- more -->


<h3>1.练习，练习还是练习</h3>

<p>iOS开发没有捷径可走。这是我在继续这个话题之前需要强调的东西，因为摆脱任何常常浮现于你脑海的幻想很重要。如果你仅仅在星期天的4PM和5PM之间学习/练习编程，那么你不会成为一个熟练的iOS开发者。不要误会我的意思，这么做可能会很有趣，但是它很难让你成为一个老练的专业的iOS开发者。除了极少数的人，大部分人都需要不断的练习和实践。如果你还没有准备好投入大量时间，这时候最好重新审视你的目标和理想。</p>

<h3>2.向其他人学习</h3>

<p>提升开发技能和采用最佳实践的最好策略之一是学习别人的代码。这不仅仅意味着浏览Stack Overflow，但更重要的是其他开发者的各种开源类库和代码片段。</p>

<p>不管何时你一头扎进各种类库的学习，比如AFNetworking或者Magical Record，很关键的一点是不要被各种代码淹没。有可能你不理解各种库中的代码，但这不是真正的关键，重点是从一个更高的层次来看源码和尽可能多地学习，比如<em>命名规范</em>、<em>最佳实践</em>&amp;以及<em>设计模式</em>等。</p>

<p>除了学习别人的代码外，创建你自己的类库是一个最好的学习方法。不久前，我用Core Data作为数据层开发了一款app，我没有使用Magical Record，我决定通过学习Magical Record创建自己的库，并重新创建了我需要的功能。这种方法不仅帮我创建了一个更加灵活的库，也让我学习到很多Magical Record内部的工作原理。</p>

<h3>3. 不要仅仅复制和粘贴</h3>

<p>这一点让我看到了正确学习方式的另一个关键面：不要不动脑子简单地复制和粘贴。我们常常会使用我们在Stack Overflow或者苹果开发者论坛找到的各种代码片段，但是不要为了偷懒简单地复制粘贴你从网络上找到的代码，这样你很难彻底理解它。最大的危险在于这可能会导致意外的行为，以致于你的代码以后都很难调试和修复。</p>

<p>有时候，复制别人的代码片段看着可能已经解决了你遇到的问题，但是我强烈建议不要这么做。阅读代码，理解你往代码库添加的东西，可能的话定制你需要的解决方案。不用说，这并不适用于开发者积极维护的库或框架。在项目中使用Magical Record前，如果你需要仔细检查它，那么我确信你已经理解了不同之处。使用你自己的常识。</p>

<h3>4. 模式</h3>

<p>Cocoa和Objective-C在很多方面都不同于其他编程语言和环境。这意味着他们有自己独特的模式和最佳实践。我确信你已经熟悉了一些常见的模式，比如委托和通知。但还有很多模式可以开发过程中帮助你，比如单例模式、观察者模式以及通用模式等。Cocoa Fundamentals Guide很好地概述了Cocoa中大部分常用模式。</p>

<h3>5.了解你的工具</h3>

<p>作为一个开发者并不仅仅是理解语言和框架，理解你每天使用的工具同样重要。对于iOS开发来说，这意味着你需要很好地理解Xcode和其他可能用到的工具，比如PonyDebugger和Charles。如果你想学习一些额外的技巧，你可能会对我此前的一篇文章（iOS Quick Tip: 7 Tips to Speed Up Your Development）感兴趣。</p>

<h3>6.与时俱进</h3>

<p>即使你不能参加苹果一年一度的开发者大会&mdash;WWDC，但浏览大量的会议视频是个很好的学习方法，你可以观看你感兴趣的专题视频，它们都是由在某方面擅长的工程师演讲，他们可以告诉你一些细节信息以及相关使用说明。另外，你还可以多关注优秀的开发者，他们会定期写一些技术文章，比如比如Matt Gemmell、 Aaron Hillegass以及Mike Ash，你可以在我为Mobiletuts+写的这篇“Where To Go Next”文章中找到更多学习资源。</p>

<h3>7.学习其他语言</h3>

<p>我已经注意到学习新语言或者使用新框架让我对软件开发的整体理解有了明显提高。这种方法的优点在于不会限制你对最熟悉语言的认知和它潜在可能性的理解。我最近在研究Ember.js，并了解到它的创建者 Yehuda Katz和Tom Dale是从Cocoa获得的灵感。Ember.js对mvc的实现并没有遵循JavaScript framework，不过如果你熟悉cocoa的话，就不会感觉到奇怪了。</p>

<p>对于软件开发来说，没有最好的语言，每种语言都有自己的优势和劣势。但是好的一面在于或多或少他们都有所不同，这使得学习新语言变得更加有趣和更有启发性。比如对我来说，Ruby在写DRY (Don’t Repeat Yourself)、易读的、干净的代码方面让我大开眼界。</p>

<h3>总结</h3>

<p>如果你不想花费时间成为一个更好的程序员，那么你可能要重新考虑下为什么你把成为一个程序员摆在首位。但如果你会因为一个可以帮你的新类库或者开发工具而兴奋，那么随着时间的流逝，你在提高自身技能方面可能不会有什么问题。你真的必须热爱你所做的事情，并在这面擅长，这一点尤其适用于编程。不管什么人告诉你，你不会在一夜之间成为一个老练的开发者，但如果你保持不间断的学习，并细心打磨自己的“手艺”，我想你的技术会有很好的提高。</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[iOS Quick Tip: 7 Tips to Speed Up Your Development]]></title>
    <link href="http://saick.net/blog/2013/11/23/ios-quick-tip-7-tips-to-speed-up-your-development/"/>
    <updated>2013-11-23T16:18:00+08:00</updated>
    <id>http://saick.net/blog/2013/11/23/ios-quick-tip-7-tips-to-speed-up-your-development</id>
    <content type="html"><![CDATA[<p><a href="http://mobile.tutsplus.com/tutorials/iphone/ios-quick-tip-7-tips-to-speed-up-your-development/">origin</a></p>

<p>Most developers are always looking for ways to improve or automate their workflow being it with a simple script to automate a common task or by learning every possible keyboard shortcut of their favorite text editor. In this article, I will show you seven tips that will speed up and streamline your workflow in Xcode.</p>

<!-- more -->


<h3>1. Keyboard Shortcuts</h3>

<p>Virtually every Xcode command has a keyboard shortcut that you can learn and even customize. Investing the time to learn keyboard shortcuts will increase your efficiency tremendously. If you are like me, and a lot of other developers, you prefer to keep your hands on the keyboard when you’re writing code and that is exactly what most key bindings are for.</p>

<p>If you don’t like the default keyboard shortcuts, then you’ll be happy to learn that you can customize Xcode’s default keyboard shortcuts in the <strong>Preferences</strong> window under the <strong>Key Bindings</strong> tab.</p>

<p><a href="http://www.flickr.com/photos/105999540@N03/11006344093/" title="2013-11-23-1 by EricShj, on Flickr"><img src="http://farm4.staticflickr.com/3817/11006344093_814a28a77f.jpg" width="500" height="367" alt="2013-11-23-1"></a>
iOS Quick Tip: 5 Tips to Speed Up Your Development &ndash; Managing Key Bindings in Xcode&rsquo;s Preferences Window</p>

<p>If you don’t want to scroll through the long list of keyboard shortcuts to learn the most important ones, then I recommend browsing through this <a href="http://stackoverflow.com/questions/146297/hidden-features-of-xcode">question on Stack Overflow</a>. It lists the most important key bindings in Xcode and also includes a number of other neat tips and tricks.</p>

<h3>2. Cocoapods</h3>

<p>Cocoapods, a great project started by Eloy Durán, has gained significant traction in the Cocoa community. What is Cocoapods? Cocoapods is a tool for managing dependencies in Xcode projects. Due to Cocoapods’ popularity, hundreds of third party libraries have been updated to support Cocoapods. Even though Cocoapods is distributed as a Ruby gem, you don’t need to understand Ruby to benefit from Cocoapods.</p>

<p>If you are tired of manually managing third party libraries in your iOS or OS X projects, or you’re looking for a solution that makes updating third party libraries easier, then Cocoapods is the best solution available. If you want to learn about Cocoapods, then I recommend reading <a href="http://mobile.tutsplus.com/tutorials/iphone/streamlining-cocoa-development-with-cocoapods/">a post about Cocoapods</a> that I wrote earlier this year. It will get you up and running in minutes.</p>

<h3>3. Code Snippets</h3>

<p>Chances are that you use a text or code snippet manager, such as <strong>TextExpander</strong> or <strong>CodeBox</strong>. I use TextExpander all the time and it has saved me countless keystrokes over the years. <em>I use Dash to manage my document sets and code snippets.</em> However, Xcode also has a snippet manager. It lives in Xcode’s right sidebar next to the Object Library.</p>

<p>Why should you use Xcode’s snippet manager instead of the alternatives I mentioned earlier? In Xcode, each snippet has a number of additional attributes that really make snippets powerful and flexible. Each snippet has a Platform and Language attribute as well as a completion scope. A snippet’s completion scope is especially useful and integrates neatly with Xcode’s editor. Did I mention that each snippet can have multiple placeholders?</p>

<p><a href="http://www.flickr.com/photos/105999540@N03/11006222706/" title="2013-11-23-2 by EricShj, on Flickr"><img src="http://farm8.staticflickr.com/7364/11006222706_6e4d20315d.jpg" width="500" height="212" alt="2013-11-23-2"></a></p>

<p>iOS Quick Tip: 5 Tips to Speed Up Your Development &ndash; Creating and Managing Code Snippets is Very Easy in Xcode</p>

<h3>4. Learn Git</h3>

<p>If you’ve just started to learn how to program and the concept source control is new to you, then I strongly recommend that you take some time to learn the basics of Git. Git is <a href="http://en.wikipedia.org/wiki/Git_(software">a distributed version control and source code management system</a>). Euh … what? In short, Git helps you manage your source code easily and efficiently. Combine Git with GitHub or BitBucket and you are starting to look like a professional programmer. The added benefit is that Xcode integrates nicely with Git and this integration will only improve over time.</p>

<p>Once you’ve learned the basics of Git, it is recommended to include a proper .gitignore file in your Xcode project. A good place to start is this question on Stack Overflow.</p>

<p>Even though Git is commonly used through the command line, there are a number of applications that provide a GUI (Graphical User Interface). My favorite is <a href="http://www.git-tower.com/">Tower</a>, developed by Fournova, which recently reached version 1.5. Atlassian‘s <a href="https://www.atlassian.com/software/sourcetree/overview">SourceTree</a> is another great and free alternative.</p>

<h3>5. Xcode Behaviors</h3>

<p>Xcode is an incredibly powerful editor and it only gets better over the years. One of the aspects that I use frequently is Xcode’s <strong>Behaviors</strong> feature. By defining behaviors, you can tell Xcode what it should do when a particular event occurs, such as when a crash occurs while debugging or when you’ve successfully archived an application.</p>

<p>You can configure these behaviors in Xcode’s Preferences Window. If you don’t like it when Xcode shows the console when output is generated, you can disable this behavior in the <strong>Behaviors</strong> panel. Do you want Xcode to show the <strong>Issues Navigator</strong> when one or more tests fail? This is all possible with Xcode Behaviors.</p>

<p><a href="http://www.flickr.com/photos/105999540@N03/11006291054/" title="2013-11-23-3 by EricShj, on Flickr"><img src="http://farm4.staticflickr.com/3812/11006291054_0794190295.jpg" width="500" height="367" alt="2013-11-23-3"></a></p>

<p>iOS Quick Tip: 5 Tips to Speed Up Your Development &ndash; Managing Behaviors in Xcode&rsquo;s Preferences Window</p>

<p>Xcode predefines a number of common behaviors for you, such as Build, Testing, and Running. However, you can also define custom behaviors and assign a keyboard shortcut to it. This is a convenient way to set up Xcode the way you want with a single key binding.</p>

<h3>6. Tabs and Windows</h3>

<p>I really like the unified look of Xcode 4 and the integration of Interface Builder. However, it is sometimes useful to have more than one window at hand, for example, when you are working in the console and the editor at the same time or you use multiple monitors. In Xcode 4, it is still possible to work with multiple windows. You can create a new window using the keyboard shortcut <code>Shift + Cmd + T</code> or use the menu, <strong>File > New > Window</strong>.</p>

<p>Even more useful are tabs. Almost every code editor has tabs these days and Xcode is no exception. I rarely find myself in an Xcode window that has no, or one, tab. What few people know is that Xcode tabs can be named. You can even tie named tabs and Xcode behaviors together, which is especially useful during debugging.</p>

<h3>7. Documentation</h3>

<p>Even if you’ve been developing Cocoa applications for years, the documentation should never be more than a click away. There are a number of ways to quickly access Xcode’s documentation browser. The solution I use most often is holding the option key and clicking a method in Xcode’s code editor. This presents you with a summary of the particular method. If you want to read more or open the documentation browser, you can click one of the links in the pop up window.</p>

<p><a href="http://www.flickr.com/photos/105999540@N03/11006118705/" title="2013-11-23-4 by EricShj, on Flickr"><img src="http://farm8.staticflickr.com/7341/11006118705_ee2259bfdf.jpg" width="500" height="309" alt="2013-11-23-4"></a></p>

<p>iOS Quick Tip: 5 Tips to Speed Up Your Development &ndash; The Documentation is Your Friend</p>

<p>You can achieve the same by opening Xcode’s right sidebar and open the Quick Help Inspector tab. The help inspector updates as the cursor moves. As with the pop up window, clicking on one of the links in the help inspector takes you to the respective section in the documentation in the documentation browser.</p>

<p><a href="http://www.flickr.com/photos/105999540@N03/11006118685/" title="2013-11-23-5 by EricShj, on Flickr"><img src="http://farm4.staticflickr.com/3782/11006118685_ec1975ac10.jpg" width="500" height="422" alt="2013-11-23-5"></a></p>

<p>iOS Quick Tip: 5 Tips to Speed Up Your Development &ndash; The Quick Help Inspector</p>

<p>One of the downsides of Xcode’s documentation browser is that it can be slow at times. For this reason, I frequently use Dash, a dedicated documentation and snippet manager. Dash is very fast and provides support for more than eighty languages, libraries, frameworks, and APIs. It is well worth checking out.</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[深入浅出 Cocoa 多线程编程之 block 与 dispatch quene]]></title>
    <link href="http://saick.net/blog/2013/11/12/shen-ru-qian-chu-cocoa-duo-xian-cheng-bian-cheng-zhi-block-yu-dispatch-quene/"/>
    <updated>2013-11-12T22:20:00+08:00</updated>
    <id>http://saick.net/blog/2013/11/12/shen-ru-qian-chu-cocoa-duo-xian-cheng-bian-cheng-zhi-block-yu-dispatch-quene</id>
    <content type="html"><![CDATA[<p>深入浅出 Cocoa 多线程编程之 block 与 dispatch quene
罗朝辉(<a href="http://blog.csdn.net/kesalin">http://blog.csdn.net/kesalin</a>)
CC 许可，转载请注明出处</p>

<p>block 是 Apple 在 GCC 4.2 中扩充的新语法特性，其目的是支持多核并行编程。我们可以将
dispatch_queue 与 block 结合起来使用，方便进行多线程编程。</p>

<!-- more -->


<p>本文源代码下载：<a href="http://www.cppblog.com/Files/kesalin/StudyBlocks.zip">点击下载</a></p>

<h3>1，实验工程准备</h3>

<p>在 XCode 4.0 中，我们建立一个 Mac OS X Application 类型的 Command Line Tool，在 Type 里面我们选择 Foundation 就好，工程名字暂且为 StudyBlocks.默认生成的工程代码 main.m 内容如下：</p>

<p><div class='bogus-wrapper'><notextile><figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
<span class='line-number'>11</span>
<span class='line-number'>12</span>
<span class='line-number'>13</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>int main (int argc, const char * argv[])&lt;br/>
</span><span class='line'>{&lt;/p>
</span><span class='line'>
</span><span class='line'>&lt;pre>&lt;code>NSAutoreleasePool * pool = [[NSAutoreleasePool alloc] init];  
</span><span class='line'>
</span><span class='line'>// insert code here...  
</span><span class='line'>NSLog(@"Hello, World!");  
</span><span class='line'>
</span><span class='line'>[pool drain];  
</span><span class='line'>return 0;  
</span><span class='line'>&lt;/code>&lt;/pre>
</span><span class='line'>
</span><span class='line'>&lt;p>}&lt;br/></span></code></pre></td></tr></table></div></figure></notextile></div></p>

<h3>2，如何编写 block</h3>

<p>在自动生成的工程代码中，默认打印一条语句"Hello, World!&ldquo;，这个任务可以不可以用 block 语法来实现呢？答案是肯定的，请看：</p>

<p><code>
void (^aBlock)(void) = ^(void){ NSLog(@"Hello, World!"); };  
aBlock();  
</code></p>

<p>用上面的这两行语句替换 main.m 中的 NSLog(@&ldquo;Hello, World!&rdquo;); 语句，编译运行，结果是一样的。</p>

<p>这两行语句是什么意思呢？首先，等号左边的 void (^aBlock)(void) 表示声明了一个 block，这个 block 不带参数(void)且也无返回参数(void)；等号右边的 ^(void){ } 结构表示一个 block 的实现体，至于这个 block 具体要做的事情就都在 {} 之间了。在这里我们仅仅是打印一条语句。整个语句就是声明一个 block，并对其赋值。第二个语句就是调用这个 block 做实际的事情，就像我们调用函数一样。block 很有点像 C++0X 中的 Lambda 表达式。</p>

<p>我们也可以这么写：</p>

<p>```
void (^aBlock)(void) = 0;<br/>
aBlock = ^(void){</p>

<pre><code>NSLog(@" &gt;&gt; Hello, World!");  
</code></pre>

<p>};<br/>
aBlock();<br/>
```</p>

<p>现在我们知道了一个 block 该如何编写了，那么 block 数组呢？也很简单，请看：</p>

<p>```
void (^blocks[2])(void) = {</p>

<pre><code>^(void){ NSLog(@" &gt;&gt; This is block 1!"); },  
^(void){ NSLog(@" &gt;&gt; This is block 2!"); }  
</code></pre>

<p>};
blocks<a href="">0</a>;<br/>
blocks<a href="">1</a>;<br/>
```</p>

<p><strong>谨记！</strong></p>

<p>block 是分配在 <em>stack</em> 上的，这意味着我们必须小心里处理 block 的生命周期。
比如如下的做法是不对的，因为 stack 分配的 block 在 if 或 else 内是有效的，但是到大括号 } 退出时就可能无效了：</p>

<p><div class='bogus-wrapper'><notextile><figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
<span class='line-number'>11</span>
<span class='line-number'>12</span>
<span class='line-number'>13</span>
<span class='line-number'>14</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>dispatch_block_t block;&lt;/p>
</span><span class='line'>
</span><span class='line'>&lt;p>if (x) {&lt;/p>
</span><span class='line'>
</span><span class='line'>&lt;pre>&lt;code>block = ^{ printf("true\n"); };  
</span><span class='line'>&lt;/code>&lt;/pre>
</span><span class='line'>
</span><span class='line'>&lt;p>} else {&lt;/p>
</span><span class='line'>
</span><span class='line'>&lt;pre>&lt;code>block = ^{ printf("false\n"); };  
</span><span class='line'>&lt;/code>&lt;/pre>
</span><span class='line'>
</span><span class='line'>&lt;p>}&lt;br/>
</span><span class='line'>block();</span></code></pre></td></tr></table></div></figure></notextile></div></p>

<p>上面的代码就相当于下面这样的 unsafe 代码：</p>

<p>```
if (x) {</p>

<pre><code>struct Block __tmp_1 = ...; // setup details  
block = &amp;__tmp_1;  
</code></pre>

<p>} else {</p>

<pre><code>struct Block __tmp_2 = ...; // setup details  
block = &amp;__tmp_2;  
</code></pre>

<p>}
```</p>

<h3>3，如何在 block 中修改外部变量</h3>

<p>考虑到 block 的目的是为了支持并行编程，对于普通的 local 变量，我们就不能在 block 里面随意修改（原因很简单，block 可以被多个线程并行运行，会有问题的），而且如果你在 block 中修改普通的 local 变量，编译器也会报错。那么该如何修改外部变量呢？有两种办法，第一种是可以修改 static 全局变量；第二种是可以修改用新关键字 __block 修饰的变量。请看：</p>

<p><div class='bogus-wrapper'><notextile><figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
<span class='line-number'>11</span>
<span class='line-number'>12</span>
<span class='line-number'>13</span>
<span class='line-number'>14</span>
<span class='line-number'>15</span>
<span class='line-number'>16</span>
<span class='line-number'>17</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>__block int blockLocal  = 100;&lt;br/>
</span><span class='line'>static int staticLocal  = 100;&lt;/p>
</span><span class='line'>
</span><span class='line'>&lt;p>void (^aBlock)(void) = ^(void){&lt;/p>
</span><span class='line'>
</span><span class='line'>&lt;pre>&lt;code>NSLog(@" &gt;&gt; Sum: %d\n", global + staticLocal);  
</span><span class='line'>
</span><span class='line'>global++;  
</span><span class='line'>blockLocal++;  
</span><span class='line'>staticLocal++;  
</span><span class='line'>&lt;/code>&lt;/pre>
</span><span class='line'>
</span><span class='line'>&lt;p>};&lt;/p>
</span><span class='line'>
</span><span class='line'>&lt;p>aBlock();&lt;/p>
</span><span class='line'>
</span><span class='line'>&lt;p>NSLog(@&ldquo;After modified, global: %d, block local: %d, static local: %d\n&rdquo;, global, blockLocal, staticLocal);&lt;br/></span></code></pre></td></tr></table></div></figure></notextile></div></p>

<p>相似的情况，我们也可以引用 static block 或 __block block。比如我们可以用他们来实现 block 递归：</p>

<p><div class='bogus-wrapper'><notextile><figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
<span class='line-number'>11</span>
<span class='line-number'>12</span>
<span class='line-number'>13</span>
<span class='line-number'>14</span>
<span class='line-number'>15</span>
<span class='line-number'>16</span>
<span class='line-number'>17</span>
<span class='line-number'>18</span>
<span class='line-number'>19</span>
<span class='line-number'>20</span>
<span class='line-number'>21</span>
<span class='line-number'>22</span>
<span class='line-number'>23</span>
<span class='line-number'>24</span>
<span class='line-number'>25</span>
<span class='line-number'>26</span>
<span class='line-number'>27</span>
<span class='line-number'>28</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>// 1&lt;br/>
</span><span class='line'>void (^aBlock)(int) = 0;&lt;br/>
</span><span class='line'>static void (^ const staticBlock)(int) = ^(int i) {&lt;/p>
</span><span class='line'>
</span><span class='line'>&lt;pre>&lt;code>if (i &gt; 0) {  
</span><span class='line'>    NSLog(@" &gt;&gt; static %d", i);  
</span><span class='line'>    staticBlock(i - 1);  
</span><span class='line'>}  
</span><span class='line'>&lt;/code>&lt;/pre>
</span><span class='line'>
</span><span class='line'>&lt;p>};&lt;/p>
</span><span class='line'>
</span><span class='line'>&lt;p>aBlock = staticBlock;&lt;br/>
</span><span class='line'>aBlock(5);&lt;/p>
</span><span class='line'>
</span><span class='line'>&lt;p>// 2&lt;br/>
</span><span class='line'>__block void (^blockBlock)(int);&lt;br/>
</span><span class='line'>blockBlock = ^(int i) {&lt;/p>
</span><span class='line'>
</span><span class='line'>&lt;pre>&lt;code>if (i &gt; 0) {  
</span><span class='line'>    NSLog(@" &gt;&gt; block %d", i);  
</span><span class='line'>    blockBlock(i - 1);  
</span><span class='line'>}  
</span><span class='line'>&lt;/code>&lt;/pre>
</span><span class='line'>
</span><span class='line'>&lt;p>};&lt;/p>
</span><span class='line'>
</span><span class='line'>&lt;p>blockBlock(5);&lt;br/></span></code></pre></td></tr></table></div></figure></notextile></div></p>

<h3>4，上面我们介绍了 block 及其基本用法，但还没有涉及并行编程。 block 与 Dispatch Queue 分发队列结合起来使用，是 iOS 中并行编程的利器。请看代码：</h3>

<p><div class='bogus-wrapper'><notextile><figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
<span class='line-number'>11</span>
<span class='line-number'>12</span>
<span class='line-number'>13</span>
<span class='line-number'>14</span>
<span class='line-number'>15</span>
<span class='line-number'>16</span>
<span class='line-number'>17</span>
<span class='line-number'>18</span>
<span class='line-number'>19</span>
<span class='line-number'>20</span>
<span class='line-number'>21</span>
<span class='line-number'>22</span>
<span class='line-number'>23</span>
<span class='line-number'>24</span>
<span class='line-number'>25</span>
<span class='line-number'>26</span>
<span class='line-number'>27</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>NSAutoreleasePool * pool = [[NSAutoreleasePool alloc] init];&lt;/p>
</span><span class='line'>
</span><span class='line'>&lt;p>initData();&lt;/p>
</span><span class='line'>
</span><span class='line'>&lt;p>// create dispatch queue&lt;br/>
</span><span class='line'>//&lt;br/>
</span><span class='line'>dispatch_queue_t queue = dispatch_queue_create(&ldquo;StudyBlocks&rdquo;, NULL);&lt;/p>
</span><span class='line'>
</span><span class='line'>&lt;p>dispatch_async(queue, ^(void) {&lt;/p>
</span><span class='line'>
</span><span class='line'>&lt;pre>&lt;code>int sum = 0;  
</span><span class='line'>for(int i = 0; i &lt; Length; i++)  
</span><span class='line'>    sum += data[i];  
</span><span class='line'>
</span><span class='line'>NSLog(@" &gt;&gt; Sum: %d", sum);  
</span><span class='line'>
</span><span class='line'>flag = YES;  
</span><span class='line'>&lt;/code>&lt;/pre>
</span><span class='line'>
</span><span class='line'>&lt;p>});&lt;/p>
</span><span class='line'>
</span><span class='line'>&lt;p>// wait util work is done.&lt;br/>
</span><span class='line'>//&lt;br/>
</span><span class='line'>while (!flag);&lt;br/>
</span><span class='line'>dispatch_release(queue);&lt;/p>
</span><span class='line'>
</span><span class='line'>&lt;p>[pool drain];&lt;br/></span></code></pre></td></tr></table></div></figure></notextile></div></p>

<p>上面的 block 仅仅是将数组求和。</p>

<p>首先，我们创建一个串行分发队列，然后将一个 block 任务加入到其中并行运行，这样 block 就会在新的线程中运行，直到结束返回主线程。在这里要注意 flag 的使用。flag 是 static 的，所以我们可以 block 中修改它。 语句 while (!flag); 的目的是保证主线程不会 blcok 所在线程之前结束。</p>

<p>dispatch_queue_t 的定义如下：
typedef void (^dispatch_block_t)( void);
这意味着加入 dispatch_queue 中的 block 必须是无参数也无返回值的。</p>

<p>dispatch_queue_create 的定义如下：</p>

<p><code>
dispatch_queue_t dispatch_queue_create(const char *label, dispatch_queue_attr_t attr);
</code></p>

<p>这个函数带有两个参数：一个用于标识 dispatch_queue 的字符串；一个是保留的 dispatch_queue 属性，将其设置为 NULL 即可。</p>

<p>我们也可以使用</p>

<p><code>
dispatch_queue_t dispatch_get_global_queue(long priority, unsigned long flags);
</code></p>

<p>来获得全局的 dispatch_queue，参数 priority 表示优先级，值得注意的是：我们不能修改该函数返回的 dispatch_queue。</p>

<p>dispatch_async 函数的定义如下：</p>

<p><code>
void dispatch_async(dispatch_queue_t queue, dispatch_block_t block);
</code></p>

<p>它是将一个 block 加入一个 dispatch_queue，这个 block 会再其后得到调度时，并行运行。
相应的 dispatch_sync 函数就是同步执行了，一般很少用到。比如上面的代码如果我们修改为 dispatch_sync，那么就无需编写 flag 同步代码了。</p>

<h3>5，dispatch_queue 的运作机制及线程间同步</h3>

<p>我们可以将许多 blocks 用 dispatch_async 函数提交到到 dispatch_queue 串行运行。这些 blocks 是按照 FIFO(先入先出)规则调度的，也就是说，先加入的先执行，后加入的一定后执行，但在某一个时刻，可能有多个 block 同时在执行。</p>

<p>在上面的例子中，我们的主线程一直在轮询 flag 以便知晓 block 线程是否执行完毕，这样做的效率是很低的，严重浪费 CPU 资源。我们可以使用一些通信机制来解决这个问题，如：semaphore（信号量）。 semaphore 的原理很简单，就是生产-消费模式，必须生产一些资源才能消费，没有资源的时候，那我就啥也不干，直到资源就绪。下面来看代码：</p>

<p><div class='bogus-wrapper'><notextile><figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
<span class='line-number'>11</span>
<span class='line-number'>12</span>
<span class='line-number'>13</span>
<span class='line-number'>14</span>
<span class='line-number'>15</span>
<span class='line-number'>16</span>
<span class='line-number'>17</span>
<span class='line-number'>18</span>
<span class='line-number'>19</span>
<span class='line-number'>20</span>
<span class='line-number'>21</span>
<span class='line-number'>22</span>
<span class='line-number'>23</span>
<span class='line-number'>24</span>
<span class='line-number'>25</span>
<span class='line-number'>26</span>
<span class='line-number'>27</span>
<span class='line-number'>28</span>
<span class='line-number'>29</span>
<span class='line-number'>30</span>
<span class='line-number'>31</span>
<span class='line-number'>32</span>
<span class='line-number'>33</span>
<span class='line-number'>34</span>
<span class='line-number'>35</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>NSAutoreleasePool * pool = [[NSAutoreleasePool alloc] init];&lt;/p>
</span><span class='line'>
</span><span class='line'>&lt;p>initData();&lt;/p>
</span><span class='line'>
</span><span class='line'>&lt;p>// Create a semaphore with 0 resource&lt;br/>
</span><span class='line'>//&lt;br/>
</span><span class='line'>__block dispatch_semaphore_t sem = dispatch_semaphore_create(0);&lt;/p>
</span><span class='line'>
</span><span class='line'>&lt;p>// create dispatch semaphore&lt;br/>
</span><span class='line'>//&lt;br/>
</span><span class='line'>dispatch_queue_t queue = dispatch_queue_create(&ldquo;StudyBlocks&rdquo;, NULL);&lt;/p>
</span><span class='line'>
</span><span class='line'>&lt;p>dispatch_async(queue, ^(void) {&lt;/p>
</span><span class='line'>
</span><span class='line'>&lt;pre>&lt;code>int sum = 0;  
</span><span class='line'>for(int i = 0; i &lt; Length; i++)  
</span><span class='line'>    sum += data[i];  
</span><span class='line'>
</span><span class='line'>NSLog(@" &gt;&gt; Sum: %d", sum);  
</span><span class='line'>
</span><span class='line'>// signal the semaphore: add 1 resource  
</span><span class='line'>//  
</span><span class='line'>dispatch_semaphore_signal(sem);  
</span><span class='line'>&lt;/code>&lt;/pre>
</span><span class='line'>
</span><span class='line'>&lt;p>});&lt;/p>
</span><span class='line'>
</span><span class='line'>&lt;p>// wait for the semaphore: wait until resource is ready.&lt;br/>
</span><span class='line'>//&lt;br/>
</span><span class='line'>dispatch_semaphore_wait(sem, DISPATCH_TIME_FOREVER);&lt;/p>
</span><span class='line'>
</span><span class='line'>&lt;p>dispatch_release(sem);&lt;br/>
</span><span class='line'>dispatch_release(queue);&lt;/p>
</span><span class='line'>
</span><span class='line'>&lt;p>[pool drain];&lt;br/></span></code></pre></td></tr></table></div></figure></notextile></div></p>

<p>首先我们创建一个 <code>__block semaphore</code>，并将其资源初始值设置为 0 (不能少于 0)，在这里表示任务还没有完成，没有资源可用主线程不要做事情。然后在 block 任务完成之后，使用 dispatch_semaphore_signal 增加 semaphore 计数（可理解为资源数），表明任务完成，有资源可用主线程可以做事情了。而主线程中的 dispatch_semaphore_wait 就是减少 semaphore 的计数，如果资源数少于 0，则表明资源还可不得，我得按照FIFO（先等先得）的规则等待资源就绪，一旦资源就绪并且得到调度了，我再执行。</p>

<h3>6 示例：</h3>

<p>下面我们来看一个按照 FIFO 顺序执行并用 semaphore 同步的例子：先将数组求和再依次减去数组。</p>

<p><div class='bogus-wrapper'><notextile><figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
<span class='line-number'>11</span>
<span class='line-number'>12</span>
<span class='line-number'>13</span>
<span class='line-number'>14</span>
<span class='line-number'>15</span>
<span class='line-number'>16</span>
<span class='line-number'>17</span>
<span class='line-number'>18</span>
<span class='line-number'>19</span>
<span class='line-number'>20</span>
<span class='line-number'>21</span>
<span class='line-number'>22</span>
<span class='line-number'>23</span>
<span class='line-number'>24</span>
<span class='line-number'>25</span>
<span class='line-number'>26</span>
<span class='line-number'>27</span>
<span class='line-number'>28</span>
<span class='line-number'>29</span>
<span class='line-number'>30</span>
<span class='line-number'>31</span>
<span class='line-number'>32</span>
<span class='line-number'>33</span>
<span class='line-number'>34</span>
<span class='line-number'>35</span>
<span class='line-number'>36</span>
<span class='line-number'>37</span>
<span class='line-number'>38</span>
<span class='line-number'>39</span>
<span class='line-number'>40</span>
<span class='line-number'>41</span>
<span class='line-number'>42</span>
<span class='line-number'>43</span>
<span class='line-number'>44</span>
<span class='line-number'>45</span>
<span class='line-number'>46</span>
<span class='line-number'>47</span>
<span class='line-number'>48</span>
<span class='line-number'>49</span>
<span class='line-number'>50</span>
<span class='line-number'>51</span>
<span class='line-number'>52</span>
<span class='line-number'>53</span>
<span class='line-number'>54</span>
<span class='line-number'>55</span>
<span class='line-number'>56</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>NSAutoreleasePool * pool = [[NSAutoreleasePool alloc] init];&lt;/p>
</span><span class='line'>
</span><span class='line'>&lt;p>initData();&lt;/p>
</span><span class='line'>
</span><span class='line'>&lt;p>__block int sum = 0;&lt;/p>
</span><span class='line'>
</span><span class='line'>&lt;p>// Create a semaphore with 0 resource&lt;br/>
</span><span class='line'>//&lt;br/>
</span><span class='line'>&lt;strong>block dispatch_semaphore_t sem = dispatch_semaphore_create(0);&lt;br/>
</span><span class='line'>&lt;/strong>block dispatch_semaphore_t taskSem = dispatch_semaphore_create(0);&lt;/p>
</span><span class='line'>
</span><span class='line'>&lt;p>// create dispatch semaphore&lt;br/>
</span><span class='line'>//&lt;br/>
</span><span class='line'>dispatch_queue_t queue = dispatch_queue_create(&ldquo;StudyBlocks&rdquo;, NULL);&lt;/p>
</span><span class='line'>
</span><span class='line'>&lt;p>dispatch_block_t task1 = ^(void) {&lt;/p>
</span><span class='line'>
</span><span class='line'>&lt;pre>&lt;code>int s = 0;  
</span><span class='line'>for (int i = 0; i &lt; Length; i++)  
</span><span class='line'>    s += data[i];  
</span><span class='line'>sum = s;  
</span><span class='line'>
</span><span class='line'>NSLog(@" &gt;&gt; after add: %d", sum);  
</span><span class='line'>
</span><span class='line'>dispatch_semaphore_signal(taskSem);  
</span><span class='line'>&lt;/code>&lt;/pre>
</span><span class='line'>
</span><span class='line'>&lt;p>};&lt;/p>
</span><span class='line'>
</span><span class='line'>&lt;p>dispatch_block_t task2 = ^(void) {&lt;/p>
</span><span class='line'>
</span><span class='line'>&lt;pre>&lt;code>dispatch_semaphore_wait(taskSem, DISPATCH_TIME_FOREVER);  
</span><span class='line'>
</span><span class='line'>int s = sum;  
</span><span class='line'>for (int i = 0; i &lt; Length; i++)  
</span><span class='line'>    s -= data[i];  
</span><span class='line'>sum = s;  
</span><span class='line'>
</span><span class='line'>NSLog(@" &gt;&gt; after subtract: %d", sum);  
</span><span class='line'>dispatch_semaphore_signal(sem);  
</span><span class='line'>&lt;/code>&lt;/pre>
</span><span class='line'>
</span><span class='line'>&lt;p>};&lt;/p>
</span><span class='line'>
</span><span class='line'>&lt;p>dispatch_async(queue, task1);&lt;br/>
</span><span class='line'>dispatch_async(queue, task2);&lt;/p>
</span><span class='line'>
</span><span class='line'>&lt;p>// wait for the semaphore: wait until resource is ready.&lt;br/>
</span><span class='line'>//&lt;br/>
</span><span class='line'>dispatch_semaphore_wait(sem, DISPATCH_TIME_FOREVER);&lt;/p>
</span><span class='line'>
</span><span class='line'>&lt;p>dispatch_release(taskSem);&lt;br/>
</span><span class='line'>dispatch_release(sem);&lt;br/>
</span><span class='line'>dispatch_release(queue);&lt;/p>
</span><span class='line'>
</span><span class='line'>&lt;p>[pool drain];&lt;br/></span></code></pre></td></tr></table></div></figure></notextile></div></p>

<p>在上面的代码中，我们利用了 dispatch_queue 的 FIFO 特性，确保 task1 先于 task2 执行，而 task2 必须等待直到 task1 执行完毕才开始干正事，主线程又必须等待 task2 才能干正事。 这样我们就可以保证先求和，再相减，然后再让主线程运行结束这个顺序。</p>

<h3>7，使用 dispatch_apply 进行并发迭代：</h3>

<p>对于上面的求和操作，我们也可以使用 dispatch_apply 来简化代码的编写：</p>

<p><div class='bogus-wrapper'><notextile><figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
<span class='line-number'>11</span>
<span class='line-number'>12</span>
<span class='line-number'>13</span>
<span class='line-number'>14</span>
<span class='line-number'>15</span>
<span class='line-number'>16</span>
<span class='line-number'>17</span>
<span class='line-number'>18</span>
<span class='line-number'>19</span>
<span class='line-number'>20</span>
<span class='line-number'>21</span>
<span class='line-number'>22</span>
<span class='line-number'>23</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>NSAutoreleasePool * pool = [[NSAutoreleasePool alloc] init];&lt;/p>
</span><span class='line'>
</span><span class='line'>&lt;p>initData();&lt;/p>
</span><span class='line'>
</span><span class='line'>&lt;p>dispatch_queue_t queue = dispatch_get_global_queue(DISPATCH_QUEUE_PRIORITY_DEFAULT, 0);&lt;/p>
</span><span class='line'>
</span><span class='line'>&lt;p>&lt;strong>block int sum = 0;&lt;br/>
</span><span class='line'>&lt;/strong>block int *pArray = data;&lt;/p>
</span><span class='line'>
</span><span class='line'>&lt;p>// iterations&lt;br/>
</span><span class='line'>//&lt;br/>
</span><span class='line'>dispatch_apply(Length, queue, ^(size_t i) {&lt;/p>
</span><span class='line'>
</span><span class='line'>&lt;pre>&lt;code>sum += pArray[i];  
</span><span class='line'>&lt;/code>&lt;/pre>
</span><span class='line'>
</span><span class='line'>&lt;p>});&lt;/p>
</span><span class='line'>
</span><span class='line'>&lt;p>NSLog(@&ldquo; >> sum: %d&rdquo;, sum);&lt;/p>
</span><span class='line'>
</span><span class='line'>&lt;p>dispatch_release(queue);&lt;/p>
</span><span class='line'>
</span><span class='line'>&lt;p>[pool drain];&lt;br/></span></code></pre></td></tr></table></div></figure></notextile></div></p>

<p>注意这里使用了全局 dispatch_queue。</p>

<p>dispatch_apply 的定义如下：</p>

<p><code>
dispatch_apply(size_t iterations, dispatch_queue_t queue, void (^block)(size_t));
</code></p>

<p>参数 iterations 表示迭代的次数，void (^block)(size_t) 是 block 循环体。这么做与 for 循环相比有什么好处呢？答案是：并行，这里的求和是并行的，并不是按照顺序依次执行求和的。</p>

<h3>8, dispatch group</h3>

<p>我们可以将完成一组相关任务的 block 添加到一个 dispatch group 中去，这样可以在 group 中所有 block 任务都完成之后，再做其他事情。比如 6 中的示例也可以使用 dispatch group 实现：</p>

<p><div class='bogus-wrapper'><notextile><figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
<span class='line-number'>11</span>
<span class='line-number'>12</span>
<span class='line-number'>13</span>
<span class='line-number'>14</span>
<span class='line-number'>15</span>
<span class='line-number'>16</span>
<span class='line-number'>17</span>
<span class='line-number'>18</span>
<span class='line-number'>19</span>
<span class='line-number'>20</span>
<span class='line-number'>21</span>
<span class='line-number'>22</span>
<span class='line-number'>23</span>
<span class='line-number'>24</span>
<span class='line-number'>25</span>
<span class='line-number'>26</span>
<span class='line-number'>27</span>
<span class='line-number'>28</span>
<span class='line-number'>29</span>
<span class='line-number'>30</span>
<span class='line-number'>31</span>
<span class='line-number'>32</span>
<span class='line-number'>33</span>
<span class='line-number'>34</span>
<span class='line-number'>35</span>
<span class='line-number'>36</span>
<span class='line-number'>37</span>
<span class='line-number'>38</span>
<span class='line-number'>39</span>
<span class='line-number'>40</span>
<span class='line-number'>41</span>
<span class='line-number'>42</span>
<span class='line-number'>43</span>
<span class='line-number'>44</span>
<span class='line-number'>45</span>
<span class='line-number'>46</span>
<span class='line-number'>47</span>
<span class='line-number'>48</span>
<span class='line-number'>49</span>
<span class='line-number'>50</span>
<span class='line-number'>51</span>
<span class='line-number'>52</span>
<span class='line-number'>53</span>
<span class='line-number'>54</span>
<span class='line-number'>55</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>NSAutoreleasePool * pool = [[NSAutoreleasePool alloc] init];&lt;/p>
</span><span class='line'>
</span><span class='line'>&lt;p>initData();&lt;/p>
</span><span class='line'>
</span><span class='line'>&lt;p>__block int sum = 0;&lt;/p>
</span><span class='line'>
</span><span class='line'>&lt;p>// Create a semaphore with 0 resource&lt;br/>
</span><span class='line'>//&lt;br/>
</span><span class='line'>__block dispatch_semaphore_t taskSem = dispatch_semaphore_create(0);&lt;/p>
</span><span class='line'>
</span><span class='line'>&lt;p>// create dispatch semaphore&lt;br/>
</span><span class='line'>//&lt;br/>
</span><span class='line'>dispatch_queue_t queue = dispatch_queue_create(&ldquo;StudyBlocks&rdquo;, NULL);&lt;br/>
</span><span class='line'>dispatch_group_t group = dispatch_group_create();&lt;/p>
</span><span class='line'>
</span><span class='line'>&lt;p>dispatch_block_t task1 = ^(void) {&lt;/p>
</span><span class='line'>
</span><span class='line'>&lt;pre>&lt;code>int s = 0;  
</span><span class='line'>for (int i = 0; i &lt; Length; i++)  
</span><span class='line'>    s += data[i];  
</span><span class='line'>sum = s;  
</span><span class='line'>
</span><span class='line'>NSLog(@" &gt;&gt; after add: %d", sum);  
</span><span class='line'>
</span><span class='line'>dispatch_semaphore_signal(taskSem);  
</span><span class='line'>&lt;/code>&lt;/pre>
</span><span class='line'>
</span><span class='line'>&lt;p>};&lt;/p>
</span><span class='line'>
</span><span class='line'>&lt;p>dispatch_block_t task2 = ^(void) {&lt;/p>
</span><span class='line'>
</span><span class='line'>&lt;pre>&lt;code>dispatch_semaphore_wait(taskSem, DISPATCH_TIME_FOREVER);  
</span><span class='line'>
</span><span class='line'>int s = sum;  
</span><span class='line'>for (int i = 0; i &lt; Length; i++)  
</span><span class='line'>    s -= data[i];  
</span><span class='line'>sum = s;  
</span><span class='line'>
</span><span class='line'>NSLog(@" &gt;&gt; after subtract: %d", sum);  
</span><span class='line'>&lt;/code>&lt;/pre>
</span><span class='line'>
</span><span class='line'>&lt;p>};&lt;/p>
</span><span class='line'>
</span><span class='line'>&lt;p>// Fork&lt;br/>
</span><span class='line'>dispatch_group_async(group, queue, task1);&lt;br/>
</span><span class='line'>dispatch_group_async(group, queue, task2);&lt;/p>
</span><span class='line'>
</span><span class='line'>&lt;p>// Join&lt;br/>
</span><span class='line'>dispatch_group_wait(group, DISPATCH_TIME_FOREVER);&lt;/p>
</span><span class='line'>
</span><span class='line'>&lt;p>dispatch_release(taskSem);&lt;br/>
</span><span class='line'>dispatch_release(queue);&lt;br/>
</span><span class='line'>dispatch_release(group);&lt;/p>
</span><span class='line'>
</span><span class='line'>&lt;p>[pool drain];&lt;br/></span></code></pre></td></tr></table></div></figure></notextile></div></p>

<p>在上面的代码中，我们使用 dispatch_group_create 创建一个 dispatch_group_t，然后使用语句：dispatch_group_async(group, queue, task1); 将 block 任务加入队列中，并与组关联，这样我们就可以使用 dispatch_group_wait(group, DISPATCH_TIME_FOREVER); 来等待组中所有的 block 任务完成再继续执行。</p>

<p>至此我们了解了 dispatch queue 以及 block 并行编程相关基本知识，开始在项目中运用它们吧，</p>

<p><em>参考资料：</em>
Concurrency Programming Guide：
<a href="http://developer.apple.com/library/ios/#documentation/General/Conceptual/ConcurrencyProgrammingGuide/Introduction/Introduction.html">http://developer.apple.com/library/ios/#documentation/General/Conceptual/ConcurrencyProgrammingGuide/Introduction/Introduction.html</a></p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[iOS多线程编程之Grand Central Dispatch(GCD)介绍和使用]]></title>
    <link href="http://saick.net/blog/2013/11/06/iosduo-xian-cheng-bian-cheng-zhi-grand-central-dispatch-gcd-jie-shao-he-shi-yong/"/>
    <updated>2013-11-06T23:14:00+08:00</updated>
    <id>http://saick.net/blog/2013/11/06/iosduo-xian-cheng-bian-cheng-zhi-grand-central-dispatch-gcd-jie-shao-he-shi-yong</id>
    <content type="html"><![CDATA[<h3>介绍：</h3>

<p>Grand Central Dispatch 简称（GCD）是苹果公司开发的技术，以优化的应用程序支持多核心处理器和其他的对称多处理系统的系统。这建立在任务并行执行的线程池模式的基础上的。它首次发布在Mac OS X 10.6 ，iOS 4及以上也可用。</p>

<h4>设计：</h4>

<p>GCD的工作原理是：让程序平行排队的特定任务，根据可用的处理资源，安排他们在任何可用的处理器核心上执行任务。</p>

<p>一个任务可以是一个函数(function)或者是一个block。 GCD的底层依然是用线程实现，不过这样可以让程序员不用关注实现的细节。</p>

<p>GCD中的FIFO队列称为dispatch queue，它可以保证先进来的任务先得到执行</p>

<p>dispatch queue分为下面三种：</p>

<h4>Serial</h4>

<p>又称为private dispatch queues，同时只执行一个任务。Serial queue通常用于同步访问特定的资源或数据。当你创建多个Serial queue时，虽然它们各自是同步执行的，但Serial queue与Serial queue之间是并发执行的。</p>

<h4>Concurrent</h4>

<p>又称为global dispatch queue，可以并发地执行多个任务，但是执行完成的顺序是随机的。</p>

<h4>Main dispatch queue</h4>

<p>它是全局可用的serial queue，它是在应用程序主线程上执行任务的。</p>

<!--more-->


<h3>我们看看dispatch queue如何使用</h3>

<h4>1、常用的方法dispatch_async</h4>

<p>为了避免界面在处理耗时的操作时卡死，比如读取网络数据，IO,数据库读写等，我们会在另外一个线程中处理这些操作，然后通知主线程更新界面。<br/>
用GCD实现这个流程的操作比前面介绍的NSThread  NSOperation的方法都要简单。代码框架结构如下：</p>

<p>```
dispatch_async(dispatch_get_global_queue(DISPATCH_QUEUE_PRIORITY_DEFAULT, 0), ^{</p>

<pre><code>// 耗时的操作  
dispatch_async(dispatch_get_main_queue(), ^{  
    // 更新界面  
});  
</code></pre>

<p>});
```</p>

<p>如果这样还不清晰的话，那我们还是用上两篇博客中的下载图片为例子，代码如下：
```
dispatch_async(dispatch_get_global_queue(DISPATCH_QUEUE_PRIORITY_DEFAULT, 0), ^{</p>

<pre><code>NSURL * url = [NSURL URLWithString:@"http://avatar.csdn.net/2/C/D/1_totogo2010.jpg"];  
NSData * data = [[NSData alloc]initWithContentsOfURL:url];  
UIImage *image = [[UIImage alloc]initWithData:data];  
if (data != nil) {  
    dispatch_async(dispatch_get_main_queue(), ^{  
        self.imageView.image = image;  
     });  
}  
</code></pre>

<p>});<br/>
```</p>

<p>运行显示：</p>

<p>是不是代码比NSThread  NSOperation简洁很多，而且GCD会自动根据任务在多核处理器上分配资源，优化程序。
系统给每一个应用程序提供了三个concurrent dispatch queues。这三个并发调度队列是全局的，它们只有优先级的不同。因为是全局的，我们不需要去创建。我们只需要通过使用函数dispath_get_global_queue去得到队列，如下：</p>

<p><code>
dispatch_queue_t globalQ = dispatch_get_global_queue(DISPATCH_QUEUE_PRIORITY_DEFAULT, 0);    
</code></p>

<p>这里也用到了系统默认就有一个串行队列main_queue</p>

<p><code>
dispatch_queue_t mainQ = dispatch_get_main_queue();    
</code></p>

<p>虽然dispatch queue是引用计数的对象，但是以上两个都是全局的队列，不用retain或release。</p>

<h4>2、dispatch_group_async的使用</h4>

<p>dispatch_group_async可以实现监听一组任务是否完成，完成后得到通知执行其他的操作。这个方法很有用，比如你执行三个下载任务，当三个任务都下载完成后你才通知界面说完成的了。下面是一段例子代码：</p>

<p>```
dispatch_queue_t queue = dispatch_get_global_queue(DISPATCH_QUEUE_PRIORITY_DEFAULT, 0);<br/>
dispatch_group_t group = dispatch_group_create();<br/>
dispatch_group_async(group, queue, ^{</p>

<pre><code>[NSThread sleepForTimeInterval:1];  
NSLog(@"group1");  
</code></pre>

<p>});<br/>
dispatch_group_async(group, queue, ^{</p>

<pre><code>[NSThread sleepForTimeInterval:2];  
NSLog(@"group2");  
</code></pre>

<p>});<br/>
dispatch_group_async(group, queue, ^{</p>

<pre><code>[NSThread sleepForTimeInterval:3];  
NSLog(@"group3");  
</code></pre>

<p>});<br/>
dispatch_group_notify(group, dispatch_get_main_queue(), ^{</p>

<pre><code>NSLog(@"updateUi");  
</code></pre>

<p>});<br/>
dispatch_release(group);<br/>
```</p>

<p>dispatch_group_async是异步的方法，运行后可以看到打印结果：</p>

<p><code>
2012-09-25 16:04:16.737 gcdTest[43328:11303] group1
2012-09-25 16:04:17.738 gcdTest[43328:12a1b] group2
2012-09-25 16:04:18.738 gcdTest[43328:13003] group3
2012-09-25 16:04:18.739 gcdTest[43328:f803] updateUi
</code></p>

<p>每个一秒打印一个，当第三个任务执行后，upadteUi被打印。</p>

<h4>3、dispatch_barrier_async的使用</h4>

<p>dispatch_barrier_async是在前面的任务执行结束后它才执行，而且它后面的任务等它执行完成之后才会执行
例子代码如下：</p>

<p><div class='bogus-wrapper'><notextile><figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
<span class='line-number'>11</span>
<span class='line-number'>12</span>
<span class='line-number'>13</span>
<span class='line-number'>14</span>
<span class='line-number'>15</span>
<span class='line-number'>16</span>
<span class='line-number'>17</span>
<span class='line-number'>18</span>
<span class='line-number'>19</span>
<span class='line-number'>20</span>
<span class='line-number'>21</span>
<span class='line-number'>22</span>
<span class='line-number'>23</span>
<span class='line-number'>24</span>
<span class='line-number'>25</span>
<span class='line-number'>26</span>
<span class='line-number'>27</span>
<span class='line-number'>28</span>
<span class='line-number'>29</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>dispatch_queue_t queue = dispatch_queue_create(&ldquo;gcdtest.rongfzh.yc&rdquo;, DISPATCH_QUEUE_CONCURRENT);&lt;br/>
</span><span class='line'>dispatch_async(queue, ^{&lt;/p>
</span><span class='line'>
</span><span class='line'>&lt;pre>&lt;code>[NSThread sleepForTimeInterval:2];  
</span><span class='line'>NSLog(@"dispatch_async1");  
</span><span class='line'>&lt;/code>&lt;/pre>
</span><span class='line'>
</span><span class='line'>&lt;p>});&lt;br/>
</span><span class='line'>dispatch_async(queue, ^{&lt;/p>
</span><span class='line'>
</span><span class='line'>&lt;pre>&lt;code>[NSThread sleepForTimeInterval:4];  
</span><span class='line'>NSLog(@"dispatch_async2");  
</span><span class='line'>&lt;/code>&lt;/pre>
</span><span class='line'>
</span><span class='line'>&lt;p>});&lt;br/>
</span><span class='line'>dispatch_barrier_async(queue, ^{&lt;/p>
</span><span class='line'>
</span><span class='line'>&lt;pre>&lt;code>NSLog(@"dispatch_barrier_async");  
</span><span class='line'>[NSThread sleepForTimeInterval:4];
</span><span class='line'>&lt;/code>&lt;/pre>
</span><span class='line'>
</span><span class='line'>&lt;p>});&lt;br/>
</span><span class='line'>dispatch_async(queue, ^{&lt;/p>
</span><span class='line'>
</span><span class='line'>&lt;pre>&lt;code>[NSThread sleepForTimeInterval:1];  
</span><span class='line'>NSLog(@"dispatch_async3");  
</span><span class='line'>&lt;/code>&lt;/pre>
</span><span class='line'>
</span><span class='line'>&lt;p>});&lt;br/></span></code></pre></td></tr></table></div></figure></notextile></div></p>

<p>打印结果：</p>

<p><code>
2012-09-25 16:20:33.967 gcdTest[45547:11203] dispatch_async1
2012-09-25 16:20:35.967 gcdTest[45547:11303] dispatch_async2
2012-09-25 16:20:35.967 gcdTest[45547:11303] dispatch_barrier_async
2012-09-25 16:20:40.970 gcdTest[45547:11303] dispatch_async3
</code></p>

<p>请注意执行的时间，可以看到执行的顺序如上所述。</p>

<h4>4、dispatch_apply</h4>

<p>执行某个代码片段N次。</p>

<p>```
dispatch_apply(5, globalQ, ^(size_t index) {</p>

<pre><code>// 执行5次
</code></pre>

<p>});
```</p>

<p>本篇使用的到的例子代码：<a href="http://download.csdn.net/detail/totogo2010/4596471">http://download.csdn.net/detail/totogo2010/4596471</a></p>

<p>GCD还有很多其他用法，可以参考官方文档<br/>
参考的文档还有：<a href="http://en.wikipedia.org/wiki/Grand_Central_Dispatch  ">http://en.wikipedia.org/wiki/Grand_Central_Dispatch  </a>
著作权声明：本文由<a href="http://blog.csdn.net/totogo2010/">http://blog.csdn.net/totogo2010/</a> 原创，欢迎转载分享。请尊重作者劳动，转载时保留该声明和作者博客链接，谢谢!</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Dash：程序员的的好帮手]]></title>
    <link href="http://saick.net/blog/2013/10/27/dashcheng-xu-yuan-de-de-hao-bang-shou/"/>
    <updated>2013-10-27T20:08:00+08:00</updated>
    <id>http://saick.net/blog/2013/10/27/dashcheng-xu-yuan-de-de-hao-bang-shou</id>
    <content type="html"><![CDATA[<p>现在最新版UI比以前好一些，不过总体差异不大。</p>

<p>转自：<a href="http://blog.csdn.net/meegomeego/article/details/8798665">http://blog.csdn.net/meegomeego/article/details/8798665</a></p>

<p>作为一Coder，每天最常见的动作就是查看各种API文档，你一定也有过同时打开N个窗口（HTML、PDF、CHM），不停的在编辑器与文档之间切换的感受吧？怎么说呢，其实我很讨厌这种枯燥无味的动作，那么如何才能提高效率，减少无用功呢？下面就给大家介绍一款非常好用的Mac小工具：<em>Dash</em>，相比这个英文名，我跟喜欢叫它“叮当猫”，嘿嘿。</p>

<p><a href="http://itunes.apple.com/cn/app/dash-docs-snippets/id458034879?mt=12">点我直达AppStore介绍页面</a></p>

<h3>功能简介</h3>

<p>官方用一句话就概括了它的用途：Dash是一个API文档浏览器（ API Documentation Browser），以及代码片段管理工具（Code Snippet Manager）。你没看错，它就只有这两个功能，但确实是程序员（至少对于我来说）最为关心的特性，自己之前也用过了不少类似的工具，可以毫不夸张地说，Dash是它们之中做的最好的一个！</p>

<!-- more -->


<h4>强悍的API文档浏览、搜索功能</h4>

<p>想必这个功能是大家最常用的了吧，每天要反复查看、搜索那么多的API细节，没有一个好工具，单靠自己的双手如何应付得来？窗口不停的切来切去，很烦啊！Dash采用集成单一窗口的方式，很好的解决了这个问题。看下面的截图：</p>

<p><a href="http://www.flickr.com/photos/105999540@N03/10511272486/" title="2013-10-27-1 by EricShj, on Flickr"><img src="http://farm4.staticflickr.com/3789/10511272486_dc57f954a1.jpg" width="500" height="300" alt="2013-10-27-1"></a></p>

<p>上图便是Dash的API浏览器主界面：左侧边栏是各种编程语言以及框架（取决于你下载安装了多少文档集合）的导航大纲，点击某个节点，右边的内容区域就是文档的详细信息啦，非常直观。也可以在左上方的搜索框内通过输入关键字，查找相关的API文档，非常类似全文检索的实现方式，Dash的响应速度非常快！关键是可以同时查询不同的语言、框架内容，实在是太方便了。看到这里你也许要问了，这跟我们平常切换到特定的文档窗口（比如一个PDF或者一个CHM文件），再ctrl + f查找有什么区别，不是多此一举吗？其实你错了，Dash可以通过快捷键来显示、隐藏文档窗口，它提供了配置界面以便用户自行设置（我比较习惯alt+space，因为其他软件很少用到这个组合键）：</p>

<p><a href="http://www.flickr.com/photos/105999540@N03/10511306334/" title="2013-10-27-2 by EricShj, on Flickr"><img src="http://farm8.staticflickr.com/7356/10511306334_106b3b2151.jpg" width="423" height="234" alt="2013-10-27-2"></a></p>

<h4>Dash自带了丰富的API文档，涉及各种主流的编程语言和框架，全列出来很吓人的：</h4>

<p>ActionScript, Android, C++, Cappuccino, Cocos2D, Cocos3D, Corona, CSS, Django, Groovy, HTML, Java, JavaFX, JavaScript, jQuery, Kobold2D, Lua, MySQL, Node.js, Man Pages, Perl, PHP, Python, Ruby, Ruby on Rails, Scala, Sparrow, SQLite, Unity 3D, WordPress, XSLT, XUL</p>

<p>而且它的文档库采用了docset格式，高级用户基于网站提供的教程，很容易就能自行添加其他的扩充文档，其实Dash在最初发布的时候，只支持很少的几个文档浏览，好像只有Java、HTML、CSS这些，是后来通过用户不断贡献，以及作者及时的反馈（Rails API就是我通过Email与作者联系，请求添加的，作者非常nice），逐步壮大，才具备了如此广泛的语言、框架支持。要添加API文档，打开软件配置界面，切换到Docset选项卡即可看到所有内置的文档列表，按需要自行下载即可（如果是自己制作的docset，双击即可导入Dash）：</p>

<p><a href="http://www.flickr.com/photos/105999540@N03/10511306294/" title="2013-10-27-3 by EricShj, on Flickr"><img src="http://farm3.staticflickr.com/2845/10511306294_444ab45252.jpg" width="448" height="413" alt="2013-10-27-3"></a></p>

<h3>牛逼、好用的代码片段管理功能</h3>

<p>前面说完了Dash的文档查询功能，下面再来看一看它带给我们的另一个惊喜：代码片段管理。说到这里，之前的版本其实有个很不好的地方，就是如果不仔细琢磨一下，或者去看官方的帮助文档的话，用户是很难一眼就知道怎么用这个功能，新手引导做得确实不怎么样，不过最新版已经改善了这个问题，在主界面的导航边栏明确地给出了分类提示，创建或者修改代码片段都方便了许多。来看下面这个例子：</p>

<p><a href="http://www.flickr.com/photos/105999540@N03/10511306354/" title="2013-10-27-4 by EricShj, on Flickr"><img src="http://farm3.staticflickr.com/2856/10511306354_5e64bc1f92.jpg" width="500" height="427" alt="2013-10-27-4"></a></p>

<p>利用Dash的代码片段管理功能，我们可以把日常使用频繁（也就是你经常需要复制粘贴）的代码保存起来，然后为其设置一个独一无二的缩写，这样一来原本需要一遍又一遍的敲击键盘重复录入的繁琐工作，就可以交给Dash来帮你搞定啦。比如上面截图中的例子，就是ExtJS中发起Ajax请求的代码片段，哪怕是copy &amp; paste，时间长了也会很烦的，我给它设置了一个缩写（ajax），以后在需要编写这段代码的时候，就只需要敲击这几个字母，它就会魔法般的出现在光标所在位置啦！很神奇吧？嘿嘿，其实这种扩展缩写的功能，还有很多软件都能做到，比如TextExpander（这个我也买了，半价14刀的时候，但是现在已经打入冷宫了，比较后悔），不过就用户体验和各种细节，诸如界面UI，特别是扩展占位符的处理上，目前还没有哪一个能比得过Dash的（Dash is the best!）。来看看使用代码片段的截图吧：</p>

<p><a href="http://www.flickr.com/photos/105999540@N03/10511306264/" title="2013-10-27-5 by EricShj, on Flickr"><img src="http://farm3.staticflickr.com/2885/10511306264_3e3709bce1.jpg" width="500" height="364" alt="2013-10-27-5"></a></p>

<p>Dash的缩写扩展功能很强大，比方说上面那个例子，在保存代码片段的时候，你可以使用双下划线标明占位符，在执行扩展的时候就可以通过tab键来在各个占位符之间切换，根据需要输入实际的值，最后回车即可把片段粘贴到光标所在之处。除了占位符，它还支持下面这些变量符号：</p>

<ul>
<li> @clipboard 自动插入当前剪贴板中的内容</li>
<li> @cursor 代码片段粘贴完毕之后，自动将光标定位到此处</li>
<li> @date 自动插入当前日期</li>
<li> @time 自动插入当前时间</li>
</ul>


<p>介绍到这里，各位看官，你应该已经深深滴爱上Dash了吧？每个苦逼的程序员，都应该有这么一只可爱贴心的叮当猫，您说是不是？其实个人不是很喜欢它的图标，实在是有点太诡异了，嘿嘿……</p>

<p>最后再说一句，Dash在Mac App Store里面免费提供下载，不过作者包含了一个IAP（应用程序内购买）插件，作者挺幽默的，看介绍是说的Dash的双胞胎伙伴Pinky比较调皮，会时不时的跳出来打扰你一下，囧……反正我运行了一晚上，还没见到这只传说中的猫呢。其实这只不过是给你提供了赞助作者的机会，毕竟这么好的软件，如果经济条件允许，支持一下也无可厚非，同是软件开发者，其中的辛酸你我都懂的。</p>
]]></content>
  </entry>
  
</feed>
