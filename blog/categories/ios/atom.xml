<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">

  <title><![CDATA[Category: iOS | Saick Blog - 专注技术，乐在其中]]></title>
  <link href="http://saick.net/blog/categories/ios/atom.xml" rel="self"/>
  <link href="http://saick.net/"/>
  <updated>2013-11-23T17:21:19+08:00</updated>
  <id>http://saick.net/</id>
  <author>
    <name><![CDATA[Eric Shi]]></name>
    
  </author>
  <generator uri="http://octopress.org/">Octopress</generator>

  
  <entry>
    <title type="html"><![CDATA[iOS Quick Tip: 7 Tips to Speed Up Your Development]]></title>
    <link href="http://saick.net/blog/2013/11/23/ios-quick-tip-7-tips-to-speed-up-your-development/"/>
    <updated>2013-11-23T16:18:00+08:00</updated>
    <id>http://saick.net/blog/2013/11/23/ios-quick-tip-7-tips-to-speed-up-your-development</id>
    <content type="html"><![CDATA[<p><a href="http://mobile.tutsplus.com/tutorials/iphone/ios-quick-tip-7-tips-to-speed-up-your-development/">origin</a></p>

<p>Most developers are always looking for ways to improve or automate their workflow being it with a simple script to automate a common task or by learning every possible keyboard shortcut of their favorite text editor. In this article, I will show you seven tips that will speed up and streamline your workflow in Xcode.</p>

<!-- more -->


<h3>1. Keyboard Shortcuts</h3>

<p>Virtually every Xcode command has a keyboard shortcut that you can learn and even customize. Investing the time to learn keyboard shortcuts will increase your efficiency tremendously. If you are like me, and a lot of other developers, you prefer to keep your hands on the keyboard when you’re writing code and that is exactly what most key bindings are for.</p>

<p>If you don’t like the default keyboard shortcuts, then you’ll be happy to learn that you can customize Xcode’s default keyboard shortcuts in the <strong>Preferences</strong> window under the <strong>Key Bindings</strong> tab.</p>

<p><a href="http://www.flickr.com/photos/105999540@N03/11006344093/" title="2013-11-23-1 by EricShj, on Flickr"><img src="http://farm4.staticflickr.com/3817/11006344093_814a28a77f.jpg" width="500" height="367" alt="2013-11-23-1"></a>
iOS Quick Tip: 5 Tips to Speed Up Your Development &ndash; Managing Key Bindings in Xcode&rsquo;s Preferences Window</p>

<p>If you don’t want to scroll through the long list of keyboard shortcuts to learn the most important ones, then I recommend browsing through this <a href="http://stackoverflow.com/questions/146297/hidden-features-of-xcode">question on Stack Overflow</a>. It lists the most important key bindings in Xcode and also includes a number of other neat tips and tricks.</p>

<h3>2. Cocoapods</h3>

<p>Cocoapods, a great project started by Eloy Durán, has gained significant traction in the Cocoa community. What is Cocoapods? Cocoapods is a tool for managing dependencies in Xcode projects. Due to Cocoapods’ popularity, hundreds of third party libraries have been updated to support Cocoapods. Even though Cocoapods is distributed as a Ruby gem, you don’t need to understand Ruby to benefit from Cocoapods.</p>

<p>If you are tired of manually managing third party libraries in your iOS or OS X projects, or you’re looking for a solution that makes updating third party libraries easier, then Cocoapods is the best solution available. If you want to learn about Cocoapods, then I recommend reading <a href="http://mobile.tutsplus.com/tutorials/iphone/streamlining-cocoa-development-with-cocoapods/">a post about Cocoapods</a> that I wrote earlier this year. It will get you up and running in minutes.</p>

<h3>3. Code Snippets</h3>

<p>Chances are that you use a text or code snippet manager, such as <strong>TextExpander</strong> or <strong>CodeBox</strong>. I use TextExpander all the time and it has saved me countless keystrokes over the years. <em>I use Dash to manage my document sets and code snippets.</em> However, Xcode also has a snippet manager. It lives in Xcode’s right sidebar next to the Object Library.</p>

<p>Why should you use Xcode’s snippet manager instead of the alternatives I mentioned earlier? In Xcode, each snippet has a number of additional attributes that really make snippets powerful and flexible. Each snippet has a Platform and Language attribute as well as a completion scope. A snippet’s completion scope is especially useful and integrates neatly with Xcode’s editor. Did I mention that each snippet can have multiple placeholders?</p>

<p><a href="http://www.flickr.com/photos/105999540@N03/11006222706/" title="2013-11-23-2 by EricShj, on Flickr"><img src="http://farm8.staticflickr.com/7364/11006222706_6e4d20315d.jpg" width="500" height="212" alt="2013-11-23-2"></a></p>

<p>iOS Quick Tip: 5 Tips to Speed Up Your Development &ndash; Creating and Managing Code Snippets is Very Easy in Xcode</p>

<h3>4. Learn Git</h3>

<p>If you’ve just started to learn how to program and the concept source control is new to you, then I strongly recommend that you take some time to learn the basics of Git. Git is <a href="http://en.wikipedia.org/wiki/Git_(software">a distributed version control and source code management system</a>). Euh … what? In short, Git helps you manage your source code easily and efficiently. Combine Git with GitHub or BitBucket and you are starting to look like a professional programmer. The added benefit is that Xcode integrates nicely with Git and this integration will only improve over time.</p>

<p>Once you’ve learned the basics of Git, it is recommended to include a proper .gitignore file in your Xcode project. A good place to start is this question on Stack Overflow.</p>

<p>Even though Git is commonly used through the command line, there are a number of applications that provide a GUI (Graphical User Interface). My favorite is <a href="http://www.git-tower.com/">Tower</a>, developed by Fournova, which recently reached version 1.5. Atlassian‘s <a href="https://www.atlassian.com/software/sourcetree/overview">SourceTree</a> is another great and free alternative.</p>

<h3>5. Xcode Behaviors</h3>

<p>Xcode is an incredibly powerful editor and it only gets better over the years. One of the aspects that I use frequently is Xcode’s <strong>Behaviors</strong> feature. By defining behaviors, you can tell Xcode what it should do when a particular event occurs, such as when a crash occurs while debugging or when you’ve successfully archived an application.</p>

<p>You can configure these behaviors in Xcode’s Preferences Window. If you don’t like it when Xcode shows the console when output is generated, you can disable this behavior in the <strong>Behaviors</strong> panel. Do you want Xcode to show the <strong>Issues Navigator</strong> when one or more tests fail? This is all possible with Xcode Behaviors.</p>

<p><a href="http://www.flickr.com/photos/105999540@N03/11006291054/" title="2013-11-23-3 by EricShj, on Flickr"><img src="http://farm4.staticflickr.com/3812/11006291054_0794190295.jpg" width="500" height="367" alt="2013-11-23-3"></a></p>

<p>iOS Quick Tip: 5 Tips to Speed Up Your Development &ndash; Managing Behaviors in Xcode&rsquo;s Preferences Window</p>

<p>Xcode predefines a number of common behaviors for you, such as Build, Testing, and Running. However, you can also define custom behaviors and assign a keyboard shortcut to it. This is a convenient way to set up Xcode the way you want with a single key binding.</p>

<h3>6. Tabs and Windows</h3>

<p>I really like the unified look of Xcode 4 and the integration of Interface Builder. However, it is sometimes useful to have more than one window at hand, for example, when you are working in the console and the editor at the same time or you use multiple monitors. In Xcode 4, it is still possible to work with multiple windows. You can create a new window using the keyboard shortcut <code>Shift + Cmd + T</code> or use the menu, <strong>File > New > Window</strong>.</p>

<p>Even more useful are tabs. Almost every code editor has tabs these days and Xcode is no exception. I rarely find myself in an Xcode window that has no, or one, tab. What few people know is that Xcode tabs can be named. You can even tie named tabs and Xcode behaviors together, which is especially useful during debugging.</p>

<h3>7. Documentation</h3>

<p>Even if you’ve been developing Cocoa applications for years, the documentation should never be more than a click away. There are a number of ways to quickly access Xcode’s documentation browser. The solution I use most often is holding the option key and clicking a method in Xcode’s code editor. This presents you with a summary of the particular method. If you want to read more or open the documentation browser, you can click one of the links in the pop up window.</p>

<p><a href="http://www.flickr.com/photos/105999540@N03/11006118705/" title="2013-11-23-4 by EricShj, on Flickr"><img src="http://farm8.staticflickr.com/7341/11006118705_ee2259bfdf.jpg" width="500" height="309" alt="2013-11-23-4"></a></p>

<p>iOS Quick Tip: 5 Tips to Speed Up Your Development &ndash; The Documentation is Your Friend</p>

<p>You can achieve the same by opening Xcode’s right sidebar and open the Quick Help Inspector tab. The help inspector updates as the cursor moves. As with the pop up window, clicking on one of the links in the help inspector takes you to the respective section in the documentation in the documentation browser.</p>

<p><a href="http://www.flickr.com/photos/105999540@N03/11006118685/" title="2013-11-23-5 by EricShj, on Flickr"><img src="http://farm4.staticflickr.com/3782/11006118685_ec1975ac10.jpg" width="500" height="422" alt="2013-11-23-5"></a></p>

<p>iOS Quick Tip: 5 Tips to Speed Up Your Development &ndash; The Quick Help Inspector</p>

<p>One of the downsides of Xcode’s documentation browser is that it can be slow at times. For this reason, I frequently use Dash, a dedicated documentation and snippet manager. Dash is very fast and provides support for more than eighty languages, libraries, frameworks, and APIs. It is well worth checking out.</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[深入浅出 Cocoa 多线程编程之 block 与 dispatch quene]]></title>
    <link href="http://saick.net/blog/2013/11/12/shen-ru-qian-chu-cocoa-duo-xian-cheng-bian-cheng-zhi-block-yu-dispatch-quene/"/>
    <updated>2013-11-12T22:20:00+08:00</updated>
    <id>http://saick.net/blog/2013/11/12/shen-ru-qian-chu-cocoa-duo-xian-cheng-bian-cheng-zhi-block-yu-dispatch-quene</id>
    <content type="html"><![CDATA[<p>深入浅出 Cocoa 多线程编程之 block 与 dispatch quene
罗朝辉(<a href="http://blog.csdn.net/kesalin">http://blog.csdn.net/kesalin</a>)
CC 许可，转载请注明出处</p>

<p>block 是 Apple 在 GCC 4.2 中扩充的新语法特性，其目的是支持多核并行编程。我们可以将
dispatch_queue 与 block 结合起来使用，方便进行多线程编程。</p>

<!-- more -->


<p>本文源代码下载：<a href="http://www.cppblog.com/Files/kesalin/StudyBlocks.zip">点击下载</a></p>

<h3>1，实验工程准备</h3>

<p>在 XCode 4.0 中，我们建立一个 Mac OS X Application 类型的 Command Line Tool，在 Type 里面我们选择 Foundation 就好，工程名字暂且为 StudyBlocks.默认生成的工程代码 main.m 内容如下：</p>

<p><div class='bogus-wrapper'><notextile><figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
<span class='line-number'>11</span>
<span class='line-number'>12</span>
<span class='line-number'>13</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>int main (int argc, const char * argv[])&lt;br/>
</span><span class='line'>{&lt;/p>
</span><span class='line'>
</span><span class='line'>&lt;pre>&lt;code>NSAutoreleasePool * pool = [[NSAutoreleasePool alloc] init];  
</span><span class='line'>
</span><span class='line'>// insert code here...  
</span><span class='line'>NSLog(@"Hello, World!");  
</span><span class='line'>
</span><span class='line'>[pool drain];  
</span><span class='line'>return 0;  
</span><span class='line'>&lt;/code>&lt;/pre>
</span><span class='line'>
</span><span class='line'>&lt;p>}&lt;br/></span></code></pre></td></tr></table></div></figure></notextile></div></p>

<h3>2，如何编写 block</h3>

<p>在自动生成的工程代码中，默认打印一条语句"Hello, World!&ldquo;，这个任务可以不可以用 block 语法来实现呢？答案是肯定的，请看：</p>

<p><code>
void (^aBlock)(void) = ^(void){ NSLog(@"Hello, World!"); };  
aBlock();  
</code></p>

<p>用上面的这两行语句替换 main.m 中的 NSLog(@&ldquo;Hello, World!&rdquo;); 语句，编译运行，结果是一样的。</p>

<p>这两行语句是什么意思呢？首先，等号左边的 void (^aBlock)(void) 表示声明了一个 block，这个 block 不带参数(void)且也无返回参数(void)；等号右边的 ^(void){ } 结构表示一个 block 的实现体，至于这个 block 具体要做的事情就都在 {} 之间了。在这里我们仅仅是打印一条语句。整个语句就是声明一个 block，并对其赋值。第二个语句就是调用这个 block 做实际的事情，就像我们调用函数一样。block 很有点像 C++0X 中的 Lambda 表达式。</p>

<p>我们也可以这么写：</p>

<p>```
void (^aBlock)(void) = 0;<br/>
aBlock = ^(void){</p>

<pre><code>NSLog(@" &gt;&gt; Hello, World!");  
</code></pre>

<p>};<br/>
aBlock();<br/>
```</p>

<p>现在我们知道了一个 block 该如何编写了，那么 block 数组呢？也很简单，请看：</p>

<p>```
void (^blocks[2])(void) = {</p>

<pre><code>^(void){ NSLog(@" &gt;&gt; This is block 1!"); },  
^(void){ NSLog(@" &gt;&gt; This is block 2!"); }  
</code></pre>

<p>};
blocks<a href="">0</a>;<br/>
blocks<a href="">1</a>;<br/>
```</p>

<p><strong>谨记！</strong></p>

<p>block 是分配在 <em>stack</em> 上的，这意味着我们必须小心里处理 block 的生命周期。
比如如下的做法是不对的，因为 stack 分配的 block 在 if 或 else 内是有效的，但是到大括号 } 退出时就可能无效了：</p>

<p><div class='bogus-wrapper'><notextile><figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
<span class='line-number'>11</span>
<span class='line-number'>12</span>
<span class='line-number'>13</span>
<span class='line-number'>14</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>dispatch_block_t block;&lt;/p>
</span><span class='line'>
</span><span class='line'>&lt;p>if (x) {&lt;/p>
</span><span class='line'>
</span><span class='line'>&lt;pre>&lt;code>block = ^{ printf("true\n"); };  
</span><span class='line'>&lt;/code>&lt;/pre>
</span><span class='line'>
</span><span class='line'>&lt;p>} else {&lt;/p>
</span><span class='line'>
</span><span class='line'>&lt;pre>&lt;code>block = ^{ printf("false\n"); };  
</span><span class='line'>&lt;/code>&lt;/pre>
</span><span class='line'>
</span><span class='line'>&lt;p>}&lt;br/>
</span><span class='line'>block();</span></code></pre></td></tr></table></div></figure></notextile></div></p>

<p>上面的代码就相当于下面这样的 unsafe 代码：</p>

<p>```
if (x) {</p>

<pre><code>struct Block __tmp_1 = ...; // setup details  
block = &amp;__tmp_1;  
</code></pre>

<p>} else {</p>

<pre><code>struct Block __tmp_2 = ...; // setup details  
block = &amp;__tmp_2;  
</code></pre>

<p>}
```</p>

<h3>3，如何在 block 中修改外部变量</h3>

<p>考虑到 block 的目的是为了支持并行编程，对于普通的 local 变量，我们就不能在 block 里面随意修改（原因很简单，block 可以被多个线程并行运行，会有问题的），而且如果你在 block 中修改普通的 local 变量，编译器也会报错。那么该如何修改外部变量呢？有两种办法，第一种是可以修改 static 全局变量；第二种是可以修改用新关键字 __block 修饰的变量。请看：</p>

<p><div class='bogus-wrapper'><notextile><figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
<span class='line-number'>11</span>
<span class='line-number'>12</span>
<span class='line-number'>13</span>
<span class='line-number'>14</span>
<span class='line-number'>15</span>
<span class='line-number'>16</span>
<span class='line-number'>17</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>__block int blockLocal  = 100;&lt;br/>
</span><span class='line'>static int staticLocal  = 100;&lt;/p>
</span><span class='line'>
</span><span class='line'>&lt;p>void (^aBlock)(void) = ^(void){&lt;/p>
</span><span class='line'>
</span><span class='line'>&lt;pre>&lt;code>NSLog(@" &gt;&gt; Sum: %d\n", global + staticLocal);  
</span><span class='line'>
</span><span class='line'>global++;  
</span><span class='line'>blockLocal++;  
</span><span class='line'>staticLocal++;  
</span><span class='line'>&lt;/code>&lt;/pre>
</span><span class='line'>
</span><span class='line'>&lt;p>};&lt;/p>
</span><span class='line'>
</span><span class='line'>&lt;p>aBlock();&lt;/p>
</span><span class='line'>
</span><span class='line'>&lt;p>NSLog(@&ldquo;After modified, global: %d, block local: %d, static local: %d\n&rdquo;, global, blockLocal, staticLocal);&lt;br/></span></code></pre></td></tr></table></div></figure></notextile></div></p>

<p>相似的情况，我们也可以引用 static block 或 __block block。比如我们可以用他们来实现 block 递归：</p>

<p><div class='bogus-wrapper'><notextile><figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
<span class='line-number'>11</span>
<span class='line-number'>12</span>
<span class='line-number'>13</span>
<span class='line-number'>14</span>
<span class='line-number'>15</span>
<span class='line-number'>16</span>
<span class='line-number'>17</span>
<span class='line-number'>18</span>
<span class='line-number'>19</span>
<span class='line-number'>20</span>
<span class='line-number'>21</span>
<span class='line-number'>22</span>
<span class='line-number'>23</span>
<span class='line-number'>24</span>
<span class='line-number'>25</span>
<span class='line-number'>26</span>
<span class='line-number'>27</span>
<span class='line-number'>28</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>// 1&lt;br/>
</span><span class='line'>void (^aBlock)(int) = 0;&lt;br/>
</span><span class='line'>static void (^ const staticBlock)(int) = ^(int i) {&lt;/p>
</span><span class='line'>
</span><span class='line'>&lt;pre>&lt;code>if (i &gt; 0) {  
</span><span class='line'>    NSLog(@" &gt;&gt; static %d", i);  
</span><span class='line'>    staticBlock(i - 1);  
</span><span class='line'>}  
</span><span class='line'>&lt;/code>&lt;/pre>
</span><span class='line'>
</span><span class='line'>&lt;p>};&lt;/p>
</span><span class='line'>
</span><span class='line'>&lt;p>aBlock = staticBlock;&lt;br/>
</span><span class='line'>aBlock(5);&lt;/p>
</span><span class='line'>
</span><span class='line'>&lt;p>// 2&lt;br/>
</span><span class='line'>__block void (^blockBlock)(int);&lt;br/>
</span><span class='line'>blockBlock = ^(int i) {&lt;/p>
</span><span class='line'>
</span><span class='line'>&lt;pre>&lt;code>if (i &gt; 0) {  
</span><span class='line'>    NSLog(@" &gt;&gt; block %d", i);  
</span><span class='line'>    blockBlock(i - 1);  
</span><span class='line'>}  
</span><span class='line'>&lt;/code>&lt;/pre>
</span><span class='line'>
</span><span class='line'>&lt;p>};&lt;/p>
</span><span class='line'>
</span><span class='line'>&lt;p>blockBlock(5);&lt;br/></span></code></pre></td></tr></table></div></figure></notextile></div></p>

<h3>4，上面我们介绍了 block 及其基本用法，但还没有涉及并行编程。 block 与 Dispatch Queue 分发队列结合起来使用，是 iOS 中并行编程的利器。请看代码：</h3>

<p><div class='bogus-wrapper'><notextile><figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
<span class='line-number'>11</span>
<span class='line-number'>12</span>
<span class='line-number'>13</span>
<span class='line-number'>14</span>
<span class='line-number'>15</span>
<span class='line-number'>16</span>
<span class='line-number'>17</span>
<span class='line-number'>18</span>
<span class='line-number'>19</span>
<span class='line-number'>20</span>
<span class='line-number'>21</span>
<span class='line-number'>22</span>
<span class='line-number'>23</span>
<span class='line-number'>24</span>
<span class='line-number'>25</span>
<span class='line-number'>26</span>
<span class='line-number'>27</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>NSAutoreleasePool * pool = [[NSAutoreleasePool alloc] init];&lt;/p>
</span><span class='line'>
</span><span class='line'>&lt;p>initData();&lt;/p>
</span><span class='line'>
</span><span class='line'>&lt;p>// create dispatch queue&lt;br/>
</span><span class='line'>//&lt;br/>
</span><span class='line'>dispatch_queue_t queue = dispatch_queue_create(&ldquo;StudyBlocks&rdquo;, NULL);&lt;/p>
</span><span class='line'>
</span><span class='line'>&lt;p>dispatch_async(queue, ^(void) {&lt;/p>
</span><span class='line'>
</span><span class='line'>&lt;pre>&lt;code>int sum = 0;  
</span><span class='line'>for(int i = 0; i &lt; Length; i++)  
</span><span class='line'>    sum += data[i];  
</span><span class='line'>
</span><span class='line'>NSLog(@" &gt;&gt; Sum: %d", sum);  
</span><span class='line'>
</span><span class='line'>flag = YES;  
</span><span class='line'>&lt;/code>&lt;/pre>
</span><span class='line'>
</span><span class='line'>&lt;p>});&lt;/p>
</span><span class='line'>
</span><span class='line'>&lt;p>// wait util work is done.&lt;br/>
</span><span class='line'>//&lt;br/>
</span><span class='line'>while (!flag);&lt;br/>
</span><span class='line'>dispatch_release(queue);&lt;/p>
</span><span class='line'>
</span><span class='line'>&lt;p>[pool drain];&lt;br/></span></code></pre></td></tr></table></div></figure></notextile></div></p>

<p>上面的 block 仅仅是将数组求和。</p>

<p>首先，我们创建一个串行分发队列，然后将一个 block 任务加入到其中并行运行，这样 block 就会在新的线程中运行，直到结束返回主线程。在这里要注意 flag 的使用。flag 是 static 的，所以我们可以 block 中修改它。 语句 while (!flag); 的目的是保证主线程不会 blcok 所在线程之前结束。</p>

<p>dispatch_queue_t 的定义如下：
typedef void (^dispatch_block_t)( void);
这意味着加入 dispatch_queue 中的 block 必须是无参数也无返回值的。</p>

<p>dispatch_queue_create 的定义如下：</p>

<p><code>
dispatch_queue_t dispatch_queue_create(const char *label, dispatch_queue_attr_t attr);
</code></p>

<p>这个函数带有两个参数：一个用于标识 dispatch_queue 的字符串；一个是保留的 dispatch_queue 属性，将其设置为 NULL 即可。</p>

<p>我们也可以使用</p>

<p><code>
dispatch_queue_t dispatch_get_global_queue(long priority, unsigned long flags);
</code></p>

<p>来获得全局的 dispatch_queue，参数 priority 表示优先级，值得注意的是：我们不能修改该函数返回的 dispatch_queue。</p>

<p>dispatch_async 函数的定义如下：</p>

<p><code>
void dispatch_async(dispatch_queue_t queue, dispatch_block_t block);
</code></p>

<p>它是将一个 block 加入一个 dispatch_queue，这个 block 会再其后得到调度时，并行运行。
相应的 dispatch_sync 函数就是同步执行了，一般很少用到。比如上面的代码如果我们修改为 dispatch_sync，那么就无需编写 flag 同步代码了。</p>

<h3>5，dispatch_queue 的运作机制及线程间同步</h3>

<p>我们可以将许多 blocks 用 dispatch_async 函数提交到到 dispatch_queue 串行运行。这些 blocks 是按照 FIFO(先入先出)规则调度的，也就是说，先加入的先执行，后加入的一定后执行，但在某一个时刻，可能有多个 block 同时在执行。</p>

<p>在上面的例子中，我们的主线程一直在轮询 flag 以便知晓 block 线程是否执行完毕，这样做的效率是很低的，严重浪费 CPU 资源。我们可以使用一些通信机制来解决这个问题，如：semaphore（信号量）。 semaphore 的原理很简单，就是生产-消费模式，必须生产一些资源才能消费，没有资源的时候，那我就啥也不干，直到资源就绪。下面来看代码：</p>

<p><div class='bogus-wrapper'><notextile><figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
<span class='line-number'>11</span>
<span class='line-number'>12</span>
<span class='line-number'>13</span>
<span class='line-number'>14</span>
<span class='line-number'>15</span>
<span class='line-number'>16</span>
<span class='line-number'>17</span>
<span class='line-number'>18</span>
<span class='line-number'>19</span>
<span class='line-number'>20</span>
<span class='line-number'>21</span>
<span class='line-number'>22</span>
<span class='line-number'>23</span>
<span class='line-number'>24</span>
<span class='line-number'>25</span>
<span class='line-number'>26</span>
<span class='line-number'>27</span>
<span class='line-number'>28</span>
<span class='line-number'>29</span>
<span class='line-number'>30</span>
<span class='line-number'>31</span>
<span class='line-number'>32</span>
<span class='line-number'>33</span>
<span class='line-number'>34</span>
<span class='line-number'>35</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>NSAutoreleasePool * pool = [[NSAutoreleasePool alloc] init];&lt;/p>
</span><span class='line'>
</span><span class='line'>&lt;p>initData();&lt;/p>
</span><span class='line'>
</span><span class='line'>&lt;p>// Create a semaphore with 0 resource&lt;br/>
</span><span class='line'>//&lt;br/>
</span><span class='line'>__block dispatch_semaphore_t sem = dispatch_semaphore_create(0);&lt;/p>
</span><span class='line'>
</span><span class='line'>&lt;p>// create dispatch semaphore&lt;br/>
</span><span class='line'>//&lt;br/>
</span><span class='line'>dispatch_queue_t queue = dispatch_queue_create(&ldquo;StudyBlocks&rdquo;, NULL);&lt;/p>
</span><span class='line'>
</span><span class='line'>&lt;p>dispatch_async(queue, ^(void) {&lt;/p>
</span><span class='line'>
</span><span class='line'>&lt;pre>&lt;code>int sum = 0;  
</span><span class='line'>for(int i = 0; i &lt; Length; i++)  
</span><span class='line'>    sum += data[i];  
</span><span class='line'>
</span><span class='line'>NSLog(@" &gt;&gt; Sum: %d", sum);  
</span><span class='line'>
</span><span class='line'>// signal the semaphore: add 1 resource  
</span><span class='line'>//  
</span><span class='line'>dispatch_semaphore_signal(sem);  
</span><span class='line'>&lt;/code>&lt;/pre>
</span><span class='line'>
</span><span class='line'>&lt;p>});&lt;/p>
</span><span class='line'>
</span><span class='line'>&lt;p>// wait for the semaphore: wait until resource is ready.&lt;br/>
</span><span class='line'>//&lt;br/>
</span><span class='line'>dispatch_semaphore_wait(sem, DISPATCH_TIME_FOREVER);&lt;/p>
</span><span class='line'>
</span><span class='line'>&lt;p>dispatch_release(sem);&lt;br/>
</span><span class='line'>dispatch_release(queue);&lt;/p>
</span><span class='line'>
</span><span class='line'>&lt;p>[pool drain];&lt;br/></span></code></pre></td></tr></table></div></figure></notextile></div></p>

<p>首先我们创建一个 <code>__block semaphore</code>，并将其资源初始值设置为 0 (不能少于 0)，在这里表示任务还没有完成，没有资源可用主线程不要做事情。然后在 block 任务完成之后，使用 dispatch_semaphore_signal 增加 semaphore 计数（可理解为资源数），表明任务完成，有资源可用主线程可以做事情了。而主线程中的 dispatch_semaphore_wait 就是减少 semaphore 的计数，如果资源数少于 0，则表明资源还可不得，我得按照FIFO（先等先得）的规则等待资源就绪，一旦资源就绪并且得到调度了，我再执行。</p>

<h3>6 示例：</h3>

<p>下面我们来看一个按照 FIFO 顺序执行并用 semaphore 同步的例子：先将数组求和再依次减去数组。</p>

<p><div class='bogus-wrapper'><notextile><figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
<span class='line-number'>11</span>
<span class='line-number'>12</span>
<span class='line-number'>13</span>
<span class='line-number'>14</span>
<span class='line-number'>15</span>
<span class='line-number'>16</span>
<span class='line-number'>17</span>
<span class='line-number'>18</span>
<span class='line-number'>19</span>
<span class='line-number'>20</span>
<span class='line-number'>21</span>
<span class='line-number'>22</span>
<span class='line-number'>23</span>
<span class='line-number'>24</span>
<span class='line-number'>25</span>
<span class='line-number'>26</span>
<span class='line-number'>27</span>
<span class='line-number'>28</span>
<span class='line-number'>29</span>
<span class='line-number'>30</span>
<span class='line-number'>31</span>
<span class='line-number'>32</span>
<span class='line-number'>33</span>
<span class='line-number'>34</span>
<span class='line-number'>35</span>
<span class='line-number'>36</span>
<span class='line-number'>37</span>
<span class='line-number'>38</span>
<span class='line-number'>39</span>
<span class='line-number'>40</span>
<span class='line-number'>41</span>
<span class='line-number'>42</span>
<span class='line-number'>43</span>
<span class='line-number'>44</span>
<span class='line-number'>45</span>
<span class='line-number'>46</span>
<span class='line-number'>47</span>
<span class='line-number'>48</span>
<span class='line-number'>49</span>
<span class='line-number'>50</span>
<span class='line-number'>51</span>
<span class='line-number'>52</span>
<span class='line-number'>53</span>
<span class='line-number'>54</span>
<span class='line-number'>55</span>
<span class='line-number'>56</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>NSAutoreleasePool * pool = [[NSAutoreleasePool alloc] init];&lt;/p>
</span><span class='line'>
</span><span class='line'>&lt;p>initData();&lt;/p>
</span><span class='line'>
</span><span class='line'>&lt;p>__block int sum = 0;&lt;/p>
</span><span class='line'>
</span><span class='line'>&lt;p>// Create a semaphore with 0 resource&lt;br/>
</span><span class='line'>//&lt;br/>
</span><span class='line'>&lt;strong>block dispatch_semaphore_t sem = dispatch_semaphore_create(0);&lt;br/>
</span><span class='line'>&lt;/strong>block dispatch_semaphore_t taskSem = dispatch_semaphore_create(0);&lt;/p>
</span><span class='line'>
</span><span class='line'>&lt;p>// create dispatch semaphore&lt;br/>
</span><span class='line'>//&lt;br/>
</span><span class='line'>dispatch_queue_t queue = dispatch_queue_create(&ldquo;StudyBlocks&rdquo;, NULL);&lt;/p>
</span><span class='line'>
</span><span class='line'>&lt;p>dispatch_block_t task1 = ^(void) {&lt;/p>
</span><span class='line'>
</span><span class='line'>&lt;pre>&lt;code>int s = 0;  
</span><span class='line'>for (int i = 0; i &lt; Length; i++)  
</span><span class='line'>    s += data[i];  
</span><span class='line'>sum = s;  
</span><span class='line'>
</span><span class='line'>NSLog(@" &gt;&gt; after add: %d", sum);  
</span><span class='line'>
</span><span class='line'>dispatch_semaphore_signal(taskSem);  
</span><span class='line'>&lt;/code>&lt;/pre>
</span><span class='line'>
</span><span class='line'>&lt;p>};&lt;/p>
</span><span class='line'>
</span><span class='line'>&lt;p>dispatch_block_t task2 = ^(void) {&lt;/p>
</span><span class='line'>
</span><span class='line'>&lt;pre>&lt;code>dispatch_semaphore_wait(taskSem, DISPATCH_TIME_FOREVER);  
</span><span class='line'>
</span><span class='line'>int s = sum;  
</span><span class='line'>for (int i = 0; i &lt; Length; i++)  
</span><span class='line'>    s -= data[i];  
</span><span class='line'>sum = s;  
</span><span class='line'>
</span><span class='line'>NSLog(@" &gt;&gt; after subtract: %d", sum);  
</span><span class='line'>dispatch_semaphore_signal(sem);  
</span><span class='line'>&lt;/code>&lt;/pre>
</span><span class='line'>
</span><span class='line'>&lt;p>};&lt;/p>
</span><span class='line'>
</span><span class='line'>&lt;p>dispatch_async(queue, task1);&lt;br/>
</span><span class='line'>dispatch_async(queue, task2);&lt;/p>
</span><span class='line'>
</span><span class='line'>&lt;p>// wait for the semaphore: wait until resource is ready.&lt;br/>
</span><span class='line'>//&lt;br/>
</span><span class='line'>dispatch_semaphore_wait(sem, DISPATCH_TIME_FOREVER);&lt;/p>
</span><span class='line'>
</span><span class='line'>&lt;p>dispatch_release(taskSem);&lt;br/>
</span><span class='line'>dispatch_release(sem);&lt;br/>
</span><span class='line'>dispatch_release(queue);&lt;/p>
</span><span class='line'>
</span><span class='line'>&lt;p>[pool drain];&lt;br/></span></code></pre></td></tr></table></div></figure></notextile></div></p>

<p>在上面的代码中，我们利用了 dispatch_queue 的 FIFO 特性，确保 task1 先于 task2 执行，而 task2 必须等待直到 task1 执行完毕才开始干正事，主线程又必须等待 task2 才能干正事。 这样我们就可以保证先求和，再相减，然后再让主线程运行结束这个顺序。</p>

<h3>7，使用 dispatch_apply 进行并发迭代：</h3>

<p>对于上面的求和操作，我们也可以使用 dispatch_apply 来简化代码的编写：</p>

<p><div class='bogus-wrapper'><notextile><figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
<span class='line-number'>11</span>
<span class='line-number'>12</span>
<span class='line-number'>13</span>
<span class='line-number'>14</span>
<span class='line-number'>15</span>
<span class='line-number'>16</span>
<span class='line-number'>17</span>
<span class='line-number'>18</span>
<span class='line-number'>19</span>
<span class='line-number'>20</span>
<span class='line-number'>21</span>
<span class='line-number'>22</span>
<span class='line-number'>23</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>NSAutoreleasePool * pool = [[NSAutoreleasePool alloc] init];&lt;/p>
</span><span class='line'>
</span><span class='line'>&lt;p>initData();&lt;/p>
</span><span class='line'>
</span><span class='line'>&lt;p>dispatch_queue_t queue = dispatch_get_global_queue(DISPATCH_QUEUE_PRIORITY_DEFAULT, 0);&lt;/p>
</span><span class='line'>
</span><span class='line'>&lt;p>&lt;strong>block int sum = 0;&lt;br/>
</span><span class='line'>&lt;/strong>block int *pArray = data;&lt;/p>
</span><span class='line'>
</span><span class='line'>&lt;p>// iterations&lt;br/>
</span><span class='line'>//&lt;br/>
</span><span class='line'>dispatch_apply(Length, queue, ^(size_t i) {&lt;/p>
</span><span class='line'>
</span><span class='line'>&lt;pre>&lt;code>sum += pArray[i];  
</span><span class='line'>&lt;/code>&lt;/pre>
</span><span class='line'>
</span><span class='line'>&lt;p>});&lt;/p>
</span><span class='line'>
</span><span class='line'>&lt;p>NSLog(@&ldquo; >> sum: %d&rdquo;, sum);&lt;/p>
</span><span class='line'>
</span><span class='line'>&lt;p>dispatch_release(queue);&lt;/p>
</span><span class='line'>
</span><span class='line'>&lt;p>[pool drain];&lt;br/></span></code></pre></td></tr></table></div></figure></notextile></div></p>

<p>注意这里使用了全局 dispatch_queue。</p>

<p>dispatch_apply 的定义如下：</p>

<p><code>
dispatch_apply(size_t iterations, dispatch_queue_t queue, void (^block)(size_t));
</code></p>

<p>参数 iterations 表示迭代的次数，void (^block)(size_t) 是 block 循环体。这么做与 for 循环相比有什么好处呢？答案是：并行，这里的求和是并行的，并不是按照顺序依次执行求和的。</p>

<h3>8, dispatch group</h3>

<p>我们可以将完成一组相关任务的 block 添加到一个 dispatch group 中去，这样可以在 group 中所有 block 任务都完成之后，再做其他事情。比如 6 中的示例也可以使用 dispatch group 实现：</p>

<p><div class='bogus-wrapper'><notextile><figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
<span class='line-number'>11</span>
<span class='line-number'>12</span>
<span class='line-number'>13</span>
<span class='line-number'>14</span>
<span class='line-number'>15</span>
<span class='line-number'>16</span>
<span class='line-number'>17</span>
<span class='line-number'>18</span>
<span class='line-number'>19</span>
<span class='line-number'>20</span>
<span class='line-number'>21</span>
<span class='line-number'>22</span>
<span class='line-number'>23</span>
<span class='line-number'>24</span>
<span class='line-number'>25</span>
<span class='line-number'>26</span>
<span class='line-number'>27</span>
<span class='line-number'>28</span>
<span class='line-number'>29</span>
<span class='line-number'>30</span>
<span class='line-number'>31</span>
<span class='line-number'>32</span>
<span class='line-number'>33</span>
<span class='line-number'>34</span>
<span class='line-number'>35</span>
<span class='line-number'>36</span>
<span class='line-number'>37</span>
<span class='line-number'>38</span>
<span class='line-number'>39</span>
<span class='line-number'>40</span>
<span class='line-number'>41</span>
<span class='line-number'>42</span>
<span class='line-number'>43</span>
<span class='line-number'>44</span>
<span class='line-number'>45</span>
<span class='line-number'>46</span>
<span class='line-number'>47</span>
<span class='line-number'>48</span>
<span class='line-number'>49</span>
<span class='line-number'>50</span>
<span class='line-number'>51</span>
<span class='line-number'>52</span>
<span class='line-number'>53</span>
<span class='line-number'>54</span>
<span class='line-number'>55</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>NSAutoreleasePool * pool = [[NSAutoreleasePool alloc] init];&lt;/p>
</span><span class='line'>
</span><span class='line'>&lt;p>initData();&lt;/p>
</span><span class='line'>
</span><span class='line'>&lt;p>__block int sum = 0;&lt;/p>
</span><span class='line'>
</span><span class='line'>&lt;p>// Create a semaphore with 0 resource&lt;br/>
</span><span class='line'>//&lt;br/>
</span><span class='line'>__block dispatch_semaphore_t taskSem = dispatch_semaphore_create(0);&lt;/p>
</span><span class='line'>
</span><span class='line'>&lt;p>// create dispatch semaphore&lt;br/>
</span><span class='line'>//&lt;br/>
</span><span class='line'>dispatch_queue_t queue = dispatch_queue_create(&ldquo;StudyBlocks&rdquo;, NULL);&lt;br/>
</span><span class='line'>dispatch_group_t group = dispatch_group_create();&lt;/p>
</span><span class='line'>
</span><span class='line'>&lt;p>dispatch_block_t task1 = ^(void) {&lt;/p>
</span><span class='line'>
</span><span class='line'>&lt;pre>&lt;code>int s = 0;  
</span><span class='line'>for (int i = 0; i &lt; Length; i++)  
</span><span class='line'>    s += data[i];  
</span><span class='line'>sum = s;  
</span><span class='line'>
</span><span class='line'>NSLog(@" &gt;&gt; after add: %d", sum);  
</span><span class='line'>
</span><span class='line'>dispatch_semaphore_signal(taskSem);  
</span><span class='line'>&lt;/code>&lt;/pre>
</span><span class='line'>
</span><span class='line'>&lt;p>};&lt;/p>
</span><span class='line'>
</span><span class='line'>&lt;p>dispatch_block_t task2 = ^(void) {&lt;/p>
</span><span class='line'>
</span><span class='line'>&lt;pre>&lt;code>dispatch_semaphore_wait(taskSem, DISPATCH_TIME_FOREVER);  
</span><span class='line'>
</span><span class='line'>int s = sum;  
</span><span class='line'>for (int i = 0; i &lt; Length; i++)  
</span><span class='line'>    s -= data[i];  
</span><span class='line'>sum = s;  
</span><span class='line'>
</span><span class='line'>NSLog(@" &gt;&gt; after subtract: %d", sum);  
</span><span class='line'>&lt;/code>&lt;/pre>
</span><span class='line'>
</span><span class='line'>&lt;p>};&lt;/p>
</span><span class='line'>
</span><span class='line'>&lt;p>// Fork&lt;br/>
</span><span class='line'>dispatch_group_async(group, queue, task1);&lt;br/>
</span><span class='line'>dispatch_group_async(group, queue, task2);&lt;/p>
</span><span class='line'>
</span><span class='line'>&lt;p>// Join&lt;br/>
</span><span class='line'>dispatch_group_wait(group, DISPATCH_TIME_FOREVER);&lt;/p>
</span><span class='line'>
</span><span class='line'>&lt;p>dispatch_release(taskSem);&lt;br/>
</span><span class='line'>dispatch_release(queue);&lt;br/>
</span><span class='line'>dispatch_release(group);&lt;/p>
</span><span class='line'>
</span><span class='line'>&lt;p>[pool drain];&lt;br/></span></code></pre></td></tr></table></div></figure></notextile></div></p>

<p>在上面的代码中，我们使用 dispatch_group_create 创建一个 dispatch_group_t，然后使用语句：dispatch_group_async(group, queue, task1); 将 block 任务加入队列中，并与组关联，这样我们就可以使用 dispatch_group_wait(group, DISPATCH_TIME_FOREVER); 来等待组中所有的 block 任务完成再继续执行。</p>

<p>至此我们了解了 dispatch queue 以及 block 并行编程相关基本知识，开始在项目中运用它们吧，</p>

<p><em>参考资料：</em>
Concurrency Programming Guide：
<a href="http://developer.apple.com/library/ios/#documentation/General/Conceptual/ConcurrencyProgrammingGuide/Introduction/Introduction.html">http://developer.apple.com/library/ios/#documentation/General/Conceptual/ConcurrencyProgrammingGuide/Introduction/Introduction.html</a></p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[iOS多线程编程之Grand Central Dispatch(GCD)介绍和使用]]></title>
    <link href="http://saick.net/blog/2013/11/06/iosduo-xian-cheng-bian-cheng-zhi-grand-central-dispatch-gcd-jie-shao-he-shi-yong/"/>
    <updated>2013-11-06T23:14:00+08:00</updated>
    <id>http://saick.net/blog/2013/11/06/iosduo-xian-cheng-bian-cheng-zhi-grand-central-dispatch-gcd-jie-shao-he-shi-yong</id>
    <content type="html"><![CDATA[<h3>介绍：</h3>

<p>Grand Central Dispatch 简称（GCD）是苹果公司开发的技术，以优化的应用程序支持多核心处理器和其他的对称多处理系统的系统。这建立在任务并行执行的线程池模式的基础上的。它首次发布在Mac OS X 10.6 ，iOS 4及以上也可用。</p>

<h4>设计：</h4>

<p>GCD的工作原理是：让程序平行排队的特定任务，根据可用的处理资源，安排他们在任何可用的处理器核心上执行任务。</p>

<p>一个任务可以是一个函数(function)或者是一个block。 GCD的底层依然是用线程实现，不过这样可以让程序员不用关注实现的细节。</p>

<p>GCD中的FIFO队列称为dispatch queue，它可以保证先进来的任务先得到执行</p>

<p>dispatch queue分为下面三种：</p>

<h4>Serial</h4>

<p>又称为private dispatch queues，同时只执行一个任务。Serial queue通常用于同步访问特定的资源或数据。当你创建多个Serial queue时，虽然它们各自是同步执行的，但Serial queue与Serial queue之间是并发执行的。</p>

<h4>Concurrent</h4>

<p>又称为global dispatch queue，可以并发地执行多个任务，但是执行完成的顺序是随机的。</p>

<h4>Main dispatch queue</h4>

<p>它是全局可用的serial queue，它是在应用程序主线程上执行任务的。</p>

<!--more-->


<h3>我们看看dispatch queue如何使用</h3>

<h4>1、常用的方法dispatch_async</h4>

<p>为了避免界面在处理耗时的操作时卡死，比如读取网络数据，IO,数据库读写等，我们会在另外一个线程中处理这些操作，然后通知主线程更新界面。<br/>
用GCD实现这个流程的操作比前面介绍的NSThread  NSOperation的方法都要简单。代码框架结构如下：</p>

<p>```
dispatch_async(dispatch_get_global_queue(DISPATCH_QUEUE_PRIORITY_DEFAULT, 0), ^{</p>

<pre><code>// 耗时的操作  
dispatch_async(dispatch_get_main_queue(), ^{  
    // 更新界面  
});  
</code></pre>

<p>});
```</p>

<p>如果这样还不清晰的话，那我们还是用上两篇博客中的下载图片为例子，代码如下：
```
dispatch_async(dispatch_get_global_queue(DISPATCH_QUEUE_PRIORITY_DEFAULT, 0), ^{</p>

<pre><code>NSURL * url = [NSURL URLWithString:@"http://avatar.csdn.net/2/C/D/1_totogo2010.jpg"];  
NSData * data = [[NSData alloc]initWithContentsOfURL:url];  
UIImage *image = [[UIImage alloc]initWithData:data];  
if (data != nil) {  
    dispatch_async(dispatch_get_main_queue(), ^{  
        self.imageView.image = image;  
     });  
}  
</code></pre>

<p>});<br/>
```</p>

<p>运行显示：</p>

<p>是不是代码比NSThread  NSOperation简洁很多，而且GCD会自动根据任务在多核处理器上分配资源，优化程序。
系统给每一个应用程序提供了三个concurrent dispatch queues。这三个并发调度队列是全局的，它们只有优先级的不同。因为是全局的，我们不需要去创建。我们只需要通过使用函数dispath_get_global_queue去得到队列，如下：</p>

<p><code>
dispatch_queue_t globalQ = dispatch_get_global_queue(DISPATCH_QUEUE_PRIORITY_DEFAULT, 0);    
</code></p>

<p>这里也用到了系统默认就有一个串行队列main_queue</p>

<p><code>
dispatch_queue_t mainQ = dispatch_get_main_queue();    
</code></p>

<p>虽然dispatch queue是引用计数的对象，但是以上两个都是全局的队列，不用retain或release。</p>

<h4>2、dispatch_group_async的使用</h4>

<p>dispatch_group_async可以实现监听一组任务是否完成，完成后得到通知执行其他的操作。这个方法很有用，比如你执行三个下载任务，当三个任务都下载完成后你才通知界面说完成的了。下面是一段例子代码：</p>

<p>```
dispatch_queue_t queue = dispatch_get_global_queue(DISPATCH_QUEUE_PRIORITY_DEFAULT, 0);<br/>
dispatch_group_t group = dispatch_group_create();<br/>
dispatch_group_async(group, queue, ^{</p>

<pre><code>[NSThread sleepForTimeInterval:1];  
NSLog(@"group1");  
</code></pre>

<p>});<br/>
dispatch_group_async(group, queue, ^{</p>

<pre><code>[NSThread sleepForTimeInterval:2];  
NSLog(@"group2");  
</code></pre>

<p>});<br/>
dispatch_group_async(group, queue, ^{</p>

<pre><code>[NSThread sleepForTimeInterval:3];  
NSLog(@"group3");  
</code></pre>

<p>});<br/>
dispatch_group_notify(group, dispatch_get_main_queue(), ^{</p>

<pre><code>NSLog(@"updateUi");  
</code></pre>

<p>});<br/>
dispatch_release(group);<br/>
```</p>

<p>dispatch_group_async是异步的方法，运行后可以看到打印结果：</p>

<p><code>
2012-09-25 16:04:16.737 gcdTest[43328:11303] group1
2012-09-25 16:04:17.738 gcdTest[43328:12a1b] group2
2012-09-25 16:04:18.738 gcdTest[43328:13003] group3
2012-09-25 16:04:18.739 gcdTest[43328:f803] updateUi
</code></p>

<p>每个一秒打印一个，当第三个任务执行后，upadteUi被打印。</p>

<h4>3、dispatch_barrier_async的使用</h4>

<p>dispatch_barrier_async是在前面的任务执行结束后它才执行，而且它后面的任务等它执行完成之后才会执行
例子代码如下：</p>

<p><div class='bogus-wrapper'><notextile><figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
<span class='line-number'>11</span>
<span class='line-number'>12</span>
<span class='line-number'>13</span>
<span class='line-number'>14</span>
<span class='line-number'>15</span>
<span class='line-number'>16</span>
<span class='line-number'>17</span>
<span class='line-number'>18</span>
<span class='line-number'>19</span>
<span class='line-number'>20</span>
<span class='line-number'>21</span>
<span class='line-number'>22</span>
<span class='line-number'>23</span>
<span class='line-number'>24</span>
<span class='line-number'>25</span>
<span class='line-number'>26</span>
<span class='line-number'>27</span>
<span class='line-number'>28</span>
<span class='line-number'>29</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>dispatch_queue_t queue = dispatch_queue_create(&ldquo;gcdtest.rongfzh.yc&rdquo;, DISPATCH_QUEUE_CONCURRENT);&lt;br/>
</span><span class='line'>dispatch_async(queue, ^{&lt;/p>
</span><span class='line'>
</span><span class='line'>&lt;pre>&lt;code>[NSThread sleepForTimeInterval:2];  
</span><span class='line'>NSLog(@"dispatch_async1");  
</span><span class='line'>&lt;/code>&lt;/pre>
</span><span class='line'>
</span><span class='line'>&lt;p>});&lt;br/>
</span><span class='line'>dispatch_async(queue, ^{&lt;/p>
</span><span class='line'>
</span><span class='line'>&lt;pre>&lt;code>[NSThread sleepForTimeInterval:4];  
</span><span class='line'>NSLog(@"dispatch_async2");  
</span><span class='line'>&lt;/code>&lt;/pre>
</span><span class='line'>
</span><span class='line'>&lt;p>});&lt;br/>
</span><span class='line'>dispatch_barrier_async(queue, ^{&lt;/p>
</span><span class='line'>
</span><span class='line'>&lt;pre>&lt;code>NSLog(@"dispatch_barrier_async");  
</span><span class='line'>[NSThread sleepForTimeInterval:4];
</span><span class='line'>&lt;/code>&lt;/pre>
</span><span class='line'>
</span><span class='line'>&lt;p>});&lt;br/>
</span><span class='line'>dispatch_async(queue, ^{&lt;/p>
</span><span class='line'>
</span><span class='line'>&lt;pre>&lt;code>[NSThread sleepForTimeInterval:1];  
</span><span class='line'>NSLog(@"dispatch_async3");  
</span><span class='line'>&lt;/code>&lt;/pre>
</span><span class='line'>
</span><span class='line'>&lt;p>});&lt;br/></span></code></pre></td></tr></table></div></figure></notextile></div></p>

<p>打印结果：</p>

<p><code>
2012-09-25 16:20:33.967 gcdTest[45547:11203] dispatch_async1
2012-09-25 16:20:35.967 gcdTest[45547:11303] dispatch_async2
2012-09-25 16:20:35.967 gcdTest[45547:11303] dispatch_barrier_async
2012-09-25 16:20:40.970 gcdTest[45547:11303] dispatch_async3
</code></p>

<p>请注意执行的时间，可以看到执行的顺序如上所述。</p>

<h4>4、dispatch_apply</h4>

<p>执行某个代码片段N次。</p>

<p>```
dispatch_apply(5, globalQ, ^(size_t index) {</p>

<pre><code>// 执行5次
</code></pre>

<p>});
```</p>

<p>本篇使用的到的例子代码：<a href="http://download.csdn.net/detail/totogo2010/4596471">http://download.csdn.net/detail/totogo2010/4596471</a></p>

<p>GCD还有很多其他用法，可以参考官方文档<br/>
参考的文档还有：<a href="http://en.wikipedia.org/wiki/Grand_Central_Dispatch  ">http://en.wikipedia.org/wiki/Grand_Central_Dispatch  </a>
著作权声明：本文由<a href="http://blog.csdn.net/totogo2010/">http://blog.csdn.net/totogo2010/</a> 原创，欢迎转载分享。请尊重作者劳动，转载时保留该声明和作者博客链接，谢谢!</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Dash：程序员的的好帮手]]></title>
    <link href="http://saick.net/blog/2013/10/27/dashcheng-xu-yuan-de-de-hao-bang-shou/"/>
    <updated>2013-10-27T20:08:00+08:00</updated>
    <id>http://saick.net/blog/2013/10/27/dashcheng-xu-yuan-de-de-hao-bang-shou</id>
    <content type="html"><![CDATA[<p>现在最新版UI比以前好一些，不过总体差异不大。</p>

<p>转自：<a href="http://blog.csdn.net/meegomeego/article/details/8798665">http://blog.csdn.net/meegomeego/article/details/8798665</a></p>

<p>作为一Coder，每天最常见的动作就是查看各种API文档，你一定也有过同时打开N个窗口（HTML、PDF、CHM），不停的在编辑器与文档之间切换的感受吧？怎么说呢，其实我很讨厌这种枯燥无味的动作，那么如何才能提高效率，减少无用功呢？下面就给大家介绍一款非常好用的Mac小工具：<em>Dash</em>，相比这个英文名，我跟喜欢叫它“叮当猫”，嘿嘿。</p>

<p><a href="http://itunes.apple.com/cn/app/dash-docs-snippets/id458034879?mt=12">点我直达AppStore介绍页面</a></p>

<h3>功能简介</h3>

<p>官方用一句话就概括了它的用途：Dash是一个API文档浏览器（ API Documentation Browser），以及代码片段管理工具（Code Snippet Manager）。你没看错，它就只有这两个功能，但确实是程序员（至少对于我来说）最为关心的特性，自己之前也用过了不少类似的工具，可以毫不夸张地说，Dash是它们之中做的最好的一个！</p>

<!-- more -->


<h4>强悍的API文档浏览、搜索功能</h4>

<p>想必这个功能是大家最常用的了吧，每天要反复查看、搜索那么多的API细节，没有一个好工具，单靠自己的双手如何应付得来？窗口不停的切来切去，很烦啊！Dash采用集成单一窗口的方式，很好的解决了这个问题。看下面的截图：</p>

<p><a href="http://www.flickr.com/photos/105999540@N03/10511272486/" title="2013-10-27-1 by EricShj, on Flickr"><img src="http://farm4.staticflickr.com/3789/10511272486_dc57f954a1.jpg" width="500" height="300" alt="2013-10-27-1"></a></p>

<p>上图便是Dash的API浏览器主界面：左侧边栏是各种编程语言以及框架（取决于你下载安装了多少文档集合）的导航大纲，点击某个节点，右边的内容区域就是文档的详细信息啦，非常直观。也可以在左上方的搜索框内通过输入关键字，查找相关的API文档，非常类似全文检索的实现方式，Dash的响应速度非常快！关键是可以同时查询不同的语言、框架内容，实在是太方便了。看到这里你也许要问了，这跟我们平常切换到特定的文档窗口（比如一个PDF或者一个CHM文件），再ctrl + f查找有什么区别，不是多此一举吗？其实你错了，Dash可以通过快捷键来显示、隐藏文档窗口，它提供了配置界面以便用户自行设置（我比较习惯alt+space，因为其他软件很少用到这个组合键）：</p>

<p><a href="http://www.flickr.com/photos/105999540@N03/10511306334/" title="2013-10-27-2 by EricShj, on Flickr"><img src="http://farm8.staticflickr.com/7356/10511306334_106b3b2151.jpg" width="423" height="234" alt="2013-10-27-2"></a></p>

<h4>Dash自带了丰富的API文档，涉及各种主流的编程语言和框架，全列出来很吓人的：</h4>

<p>ActionScript, Android, C++, Cappuccino, Cocos2D, Cocos3D, Corona, CSS, Django, Groovy, HTML, Java, JavaFX, JavaScript, jQuery, Kobold2D, Lua, MySQL, Node.js, Man Pages, Perl, PHP, Python, Ruby, Ruby on Rails, Scala, Sparrow, SQLite, Unity 3D, WordPress, XSLT, XUL</p>

<p>而且它的文档库采用了docset格式，高级用户基于网站提供的教程，很容易就能自行添加其他的扩充文档，其实Dash在最初发布的时候，只支持很少的几个文档浏览，好像只有Java、HTML、CSS这些，是后来通过用户不断贡献，以及作者及时的反馈（Rails API就是我通过Email与作者联系，请求添加的，作者非常nice），逐步壮大，才具备了如此广泛的语言、框架支持。要添加API文档，打开软件配置界面，切换到Docset选项卡即可看到所有内置的文档列表，按需要自行下载即可（如果是自己制作的docset，双击即可导入Dash）：</p>

<p><a href="http://www.flickr.com/photos/105999540@N03/10511306294/" title="2013-10-27-3 by EricShj, on Flickr"><img src="http://farm3.staticflickr.com/2845/10511306294_444ab45252.jpg" width="448" height="413" alt="2013-10-27-3"></a></p>

<h3>牛逼、好用的代码片段管理功能</h3>

<p>前面说完了Dash的文档查询功能，下面再来看一看它带给我们的另一个惊喜：代码片段管理。说到这里，之前的版本其实有个很不好的地方，就是如果不仔细琢磨一下，或者去看官方的帮助文档的话，用户是很难一眼就知道怎么用这个功能，新手引导做得确实不怎么样，不过最新版已经改善了这个问题，在主界面的导航边栏明确地给出了分类提示，创建或者修改代码片段都方便了许多。来看下面这个例子：</p>

<p><a href="http://www.flickr.com/photos/105999540@N03/10511306354/" title="2013-10-27-4 by EricShj, on Flickr"><img src="http://farm3.staticflickr.com/2856/10511306354_5e64bc1f92.jpg" width="500" height="427" alt="2013-10-27-4"></a></p>

<p>利用Dash的代码片段管理功能，我们可以把日常使用频繁（也就是你经常需要复制粘贴）的代码保存起来，然后为其设置一个独一无二的缩写，这样一来原本需要一遍又一遍的敲击键盘重复录入的繁琐工作，就可以交给Dash来帮你搞定啦。比如上面截图中的例子，就是ExtJS中发起Ajax请求的代码片段，哪怕是copy &amp; paste，时间长了也会很烦的，我给它设置了一个缩写（ajax），以后在需要编写这段代码的时候，就只需要敲击这几个字母，它就会魔法般的出现在光标所在位置啦！很神奇吧？嘿嘿，其实这种扩展缩写的功能，还有很多软件都能做到，比如TextExpander（这个我也买了，半价14刀的时候，但是现在已经打入冷宫了，比较后悔），不过就用户体验和各种细节，诸如界面UI，特别是扩展占位符的处理上，目前还没有哪一个能比得过Dash的（Dash is the best!）。来看看使用代码片段的截图吧：</p>

<p><a href="http://www.flickr.com/photos/105999540@N03/10511306264/" title="2013-10-27-5 by EricShj, on Flickr"><img src="http://farm3.staticflickr.com/2885/10511306264_3e3709bce1.jpg" width="500" height="364" alt="2013-10-27-5"></a></p>

<p>Dash的缩写扩展功能很强大，比方说上面那个例子，在保存代码片段的时候，你可以使用双下划线标明占位符，在执行扩展的时候就可以通过tab键来在各个占位符之间切换，根据需要输入实际的值，最后回车即可把片段粘贴到光标所在之处。除了占位符，它还支持下面这些变量符号：</p>

<ul>
<li> @clipboard 自动插入当前剪贴板中的内容</li>
<li> @cursor 代码片段粘贴完毕之后，自动将光标定位到此处</li>
<li> @date 自动插入当前日期</li>
<li> @time 自动插入当前时间</li>
</ul>


<p>介绍到这里，各位看官，你应该已经深深滴爱上Dash了吧？每个苦逼的程序员，都应该有这么一只可爱贴心的叮当猫，您说是不是？其实个人不是很喜欢它的图标，实在是有点太诡异了，嘿嘿……</p>

<p>最后再说一句，Dash在Mac App Store里面免费提供下载，不过作者包含了一个IAP（应用程序内购买）插件，作者挺幽默的，看介绍是说的Dash的双胞胎伙伴Pinky比较调皮，会时不时的跳出来打扰你一下，囧……反正我运行了一晚上，还没见到这只传说中的猫呢。其实这只不过是给你提供了赞助作者的机会，毕竟这么好的软件，如果经济条件允许，支持一下也无可厚非，同是软件开发者，其中的辛酸你我都懂的。</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[对比iOS网络组件：AFNetworking VS ASIHTTPRequest]]></title>
    <link href="http://saick.net/blog/2013/10/20/dui-bi-ioswang-luo-zu-jian-%3Aafnetworking-vs-asihttprequest/"/>
    <updated>2013-10-20T22:55:00+08:00</updated>
    <id>http://saick.net/blog/2013/10/20/dui-bi-ioswang-luo-zu-jian-:afnetworking-vs-asihttprequest</id>
    <content type="html"><![CDATA[<p>在开发iOS应用过程中，如何高效的与服务端API进行数据交换，是一个常见问题。一般开发者都会选择一个第三方的网络组件作为服务，以提高开发效率和稳定性。这些组件把复杂的网络底层操作封装成友好的类和方法，并且加入异常处理等。</p>

<p>那么，大家最常用的组件是什么？这些组件是如何提升开发效率和稳定性的？哪一款组件适合自己，是 AFNetworking（AFN）还是 ASIHTTPRequest（ASI）？几乎每一个iOS互联网应用开发者都会面对这样的选择题，要从这两个最常用的组件里选出一个好的还真不是那么容易。</p>

<p>单单从两个控件版本提交的时间节点来看，AFN的第一个提交是2011年的1月1日，那个时候ASI早已是1.8+的版本了；而当AFN发布1.0版，2012年10月份的时候，ASI早早的已经停止更新了。这样看起来，AFN是ASI的继任者，似乎不存在之前提到的选择困难的问题，而事实并非如此。本文将从用法、功能、性能和原理几个方面对二者进行简单对比，看看二者之间到底存在着怎样的区别，到底应该如何选择。</p>

<!-- more -->


<ul>
<li>首先，从推荐用法上就可以看出二者设计理念上大有不同。</li>
</ul>


<h3>1、用法对比</h3>

<p><a href="http://www.flickr.com/photos/105999540@N03/10382705763/" title="2013-10-20-5 by EricShj, on Flickr"><img src="http://farm3.staticflickr.com/2867/10382705763_25114b14ed.jpg" width="464" height="309" alt="2013-10-20-5"></a></p>

<p>图1，AFN的示例代码，发起请求（出自：Posts.m）</p>

<p>AFN官方推荐的使用方法是，为一系列相关的请求定义一个HTTPClient，共用一个BaseURL。每次请求把URL中除BaseURL的Path部分做为参数传给HTTPClient的静态方法，并注册一个Block用于回调。</p>

<p><a href="http://www.flickr.com/photos/105999540@N03/10382705703/" title="2013-10-20-6 by EricShj, on Flickr"><img src="http://farm4.staticflickr.com/3724/10382705703_90269d2bbe.jpg" width="464" height="143" alt="2013-10-20-6"></a></p>

<p>图2，ASI示例代码，发起异步请求（出自：ASIHTTPRequestTests.m）</p>

<p>ASI推荐使用方法就非常传统，每一个请求都由构造方法初始化一个（共享）实例，通过这个实例配置参数并发起请求。ASI最初使用delegate模式回调，在iOS SDK支持Block之后也提供了注册Block的实例方法。</p>

<p>以上引用的两段代码都出自各自项目的示例工程。对比两段代码可以很清楚的看出，同样是发起一个最普通的异步请求，使用AFN只需要调用一个静态方法，但代码可读性较差；而ASI的示例看起来更清晰，但需要调用多个实例方法才能完成一次请求。AFN的设计更加工程化，或者说对使用者更友好，而ASI的设计更经典，典型的OOP。
除了初级用法上的区别，二者的高级功能和对扩展的支持也颇有不同。</p>

<h3>2、高级功能</h3>

<p>AFN只封装了一些常用功能，满足基本需求，而直接忽略了很多扩展功能。例如：AFN默认没有封装同步请求，如果开发者需要使用同步请求，则需要重写getPath:parameters:success:failure方法，对AFHTTPRequestOperation进行同步处理；而ASI则是直接通过调用一个startSynchronous方法。
此外AFN针对JSON、XML、PList和Image四种数据结构封装了各自处理器，开发者可以把处理器注册到操作队列中，直接在回调方法中获得格式化以后的数据。在示例工程中就使用了JSON处理器：把AFJSONRequestOperation注册到操作队列里。</p>

<p><a href="http://www.flickr.com/photos/105999540@N03/10382500994/" title="2013-10-20-7 by EricShj, on Flickr"><img src="http://farm8.staticflickr.com/7419/10382500994_16a83e90d4.jpg" width="464" height="192" alt="2013-10-20-7"></a></p>

<p>图3，AFN示例代码，初始化自定义的HTTPClient（出自：AFAppDotNetAPIClient.m）</p>

<p>而ASI在这方面显得更原始，没有针对任何数据类型做特别封装，只是预留了各种接口和工具供开发者自行扩展。ASI比AFN提供更多扩展功能还有一个原因，它把许多内部用到的功能也抽象成类和方法。例如：
ASIHTTPRequestDataCompressor和ASIHTTPRequestDataDecompressor两个类，只用于压缩本地文件，构造POST Body和解压缩返回数据，但这两个类仍然被设计为独立功能，提供了对多种数据结构进行压缩和解压缩的方法。</p>

<p>对比二者的高级功能和对扩展的支持后，可以看出AFN把初级功能（或者叫常用功能）做到了90分。调用方式够简单，处理器够丰富，使用者用起来可以算是轻松加愉快。但它放弃了对高级功能的支持，要满足较复杂的需求，就要大费周折了，在这方面最多只有40分。而ASI显然不满足于做好初级功能，但为了提供更丰富的可扩展接口，导致初级功能用起来也要花上一些力气。虽然ASI单独提供了支持Amazon S3和Rackspace Cloud Files的控件，但对于生在红旗下的我朝开发者来说基本没用，所以在初级功能的支持上ASI能得个70分，牺牲了初级功能的易用性，换来的是良好的扩展性，在高级功能的使用上远远好于AFN，也能得个70分。</p>

<p>从使用角度对比过后，基本上对这两个项目有一个整体上的认识，再深入下去看看二者的性能如何。</p>

<h3>3、性能对比</h3>

<p>我分别用AFN和ASI进行了测试，测试环境如下：iPhone5，联通3G信号全满，室内静止状态，请求国内双线机房独立服务器的静态文件，1~20K共20个文件，每个文件请求20次，记录从创建请求到完全下载文件的耗时，结果如下：</p>

<p><a href="http://www.flickr.com/photos/105999540@N03/10382705653/" title="2013-10-20-8 by EricShj, on Flickr"><img src="http://farm4.staticflickr.com/3715/10382705653_fa58c22d18.jpg" width="464" height="146" alt="2013-10-20-8"></a></p>

<p>图4，AFN连续访问1 ~ 20K文件耗时</p>

<p><a href="http://www.flickr.com/photos/105999540@N03/10382545196/" title="2013-10-20-9 by EricShj, on Flickr"><img src="http://farm8.staticflickr.com/7296/10382545196_4c6f799013.jpg" width="464" height="146" alt="2013-10-20-9"></a></p>

<p>图5，ASI连续访问1 ~ 20K文件耗时</p>

<p>图4是AFN的记录图，绿色为20次请求中耗时最久的一次，蓝色为耗时最短的一次，黄色为去除最大值和最小值的18次平均值。从这个图可以看出，AFN最开始创建对象耗时近2.5秒，随后稳定下来，在3K、7K、15K和20K时出现了抖动。图5是ASI做相同测试的结果，首次创建对象近2.25秒，略优于AFN，同样在5K、11K、13K、14K和16K发生了一些抖动，但抖动幅度似乎小于AFN，可见稳定性更好一些。
下边是把二者的测试结果放在一起的对比图，可以更直观的比较二者的区别。</p>

<p><a href="http://www.flickr.com/photos/105999540@N03/10382500714/" title="2013-10-20-10 by EricShj, on Flickr"><img src="http://farm8.staticflickr.com/7317/10382500714_0725ae4480.jpg" width="464" height="147" alt="2013-10-20-10"></a></p>

<p>图6，ASI和AFN耗时最大值对比</p>

<p>图6的最大值对比可以更明显的看出二者的抖动对比，ASI略好一些。</p>

<p><a href="http://www.flickr.com/photos/105999540@N03/10382525995/" title="2013-10-20-11 by EricShj, on Flickr"><img src="http://farm6.staticflickr.com/5476/10382525995_1a6cd98274.jpg" width="464" height="146" alt="2013-10-20-11"></a></p>

<p>图7，ASI和AFN耗时最小值对比</p>

<p>图7的最小值对比可以看出，在每一个大小的测试中ASI的最佳性能似乎都要优于AFN。</p>

<p><a href="http://www.flickr.com/photos/105999540@N03/10382705193/" title="2013-10-20-12 by EricShj, on Flickr"><img src="http://farm3.staticflickr.com/2880/10382705193_25f55ba5b3.jpg" width="464" height="147" alt="2013-10-20-12"></a></p>

<p>图8，ASI和AFN耗时平均值对比</p>

<p>图8是耗时平均值的对比，更能够说明问题。文件小于12K的测试中ASI的性能优势并没有非常明显，超过12K以后，ASI优势开始明显起来，每一次请求都要比AFN节约20% ~ 30%，近0.1秒。同时从这张图上还可以看出，随着下载文件变大，请求耗时并不是线形增长的，这是由于一次请求大部分时间都消耗在建立连接上，而真正接收数据只占用了极少时间，这个问题不在本篇文章的讨论范围，所以不多说，有兴趣的读者可以<a href="http://segmentfault.com/t/ios">移步</a>进一步讨论。</p>

<h3>4、原理分析</h3>

<p>ASI的性能似乎全面优于AFN，那下边从二者的实现原理上看一下到底是什么原因造成这种差距。ASI基于CFNetwork框架开发，而AFN基于NSURL，底层的区别是导致二者性能差距的重要原因之一。</p>

<p><a href="http://www.flickr.com/photos/105999540@N03/10382544986/" title="2013-10-20-13 by EricShj, on Flickr"><img src="http://farm8.staticflickr.com/7325/10382544986_92a3d7bf99.jpg" width="464" height="289" alt="2013-10-20-13"></a></p>

<p>图9，ASI和AFN以及底层框架的关系</p>

<p>我们知道所有网络通信的基础是Socket，一个Socket与另一个连接并传送数据。BSD Socket是一类最常见的Socket抽象接口。</p>

<p>Core Foundation框架中的CFSocket就是基于BSD Socket开发的。它几乎涵盖了BSD Socket的全部功能，更重要的是把Socket整合到事件的处理循环中。Core Founda-tion中较高层的CFStream是基于CFSocket开发的读写流支持。</p>

<p>CFNetwork是基于Core Foundation中CFStream的一个底层高性能网络框架，它由提供基础服务的CFSocketStream，支持HTTP协议的CFHTTP，基于CFHTTP用于身份认证的CFHTTPAuthentication和支持FTP协议的CFFTP组成。</p>

<p>正如图9所示，ASI是基于CFHTTP开发的一个组件；而AFN的基础——NSURL，也是基于CFNetwork开发的。也就是说ASI相比AFN更加底层，这就从一定程度上造成二者的性能差距。
另一个方面，虽然二者都使用NSOperation和NSOperationQueue实现但底层的区别也导致实现方式上有非常大的差别。</p>

<p>ASI的直接操作对象ASIHTTPRequest是NSOperation的子类，实现了NSCopying协议。在initialize和initWithURL:方法中初始化相关属性并配置一系列请求相关参数默认值。此外，ASIHTTPRequest还提供了一系列的实例方法用来配置请求对象。在异步请求的处理上，ASIHTTPRequest对象初始化结束后，在startAsynchronous方法中把对象加入共享操作队列。此后，包括创建CFHTTPMessageRef，也就是处理网络请求的主要对象（事实上是一个指向__CFHTTPMessage结构的指针），在内的所有操作都在ASIHTTPRequest对象所属的子线程中完成。</p>

<p>AFN的直接操作对象AFHTTPClient不同于ASI，是一个实现了NSCoding和NSCopying协议的NSObject子类。AFHTTPClient是一个封装了一系列操作方法的“工具类”，处理请求的操作类是一系列单独的，基于NSOperation封装的，AFURLConnectionOperation的子类。AFN的示例代码中通过一个静态方法，使用dispatch_once()的方式创建AFHTTPClient的共享实例，这也是官方建议的使用方法。在创建AFHTTPClient的初始化方法中，创建了OperationQueue并设置一系列参数默认值。在getPath:parameters:success:failure方法中创建NSURLRequest，以NSURLRequest对象实例作为参数，创建一个NSOperation，并加入在初始化发方中创建的NSOperationQueue。以上操作都是在主线程中完成的。在NSOperation的start方法中，以此前创建的NSURLRequest对象为参数创建NSURLConnection并开启连结。</p>

<p>在异步回调的处理上二者也有区别，ASI采取的是CFHTTP请求完成，直接回调ASIHTTPRequest的实例方法，通过储存的实例对象记录的信息完成Delegate模式或Block模式的回调。而AFN则直接使用了NSOperation的completionBlock属性。</p>

<p>这些实现方式也可以看出，ASI显得更加底层，并没有过多使用Cocoa框架中已经封装的API，而AFN则更加实用主义，逻辑简单清晰，大量使用了框架API。这一点也是造成二者性能差别的原因之一。</p>

<h3>总结</h3>

<p>通过以上的对比，基本可以这样评价：AFN适合逻辑简单的应用，或者更适合开发资源尚不丰富的团队，因为AFN的易用性要比ASI好很多，而这样的应用（或团队）对底层网络控件的定制化要求也非常低。ASI更适合已经发展了一段时间的应用，或者开发资源相对丰富的团队，因为往往这些团队（或他们的应用）已经积累了一定的经验，无论是产品上还是技术上的。需求复杂度就是在这种时候高起来，而且底层订制的需求也越来越多，此时AFN就很难满足需求，需要牺牲一定的易用性，使用ASI作为网络底层控件。SegmentFault开源客户端现在被设计为一款简单的阅读客户端，几乎没有定制要求，因此，目前我选择了AFN作为网络控件。
以上对ASI和AFN两款最常用的iOS底层网络控件做了初步的介绍，要更深入的了解两款控件，还需要大家继续研究各自的源码。大家遇到任何关于iOS的技术问题都可以在<a href="http://segmentfault.com/t/ios">这里</a>进行讨论。另外大家也可以持续关注SegmentFault的开源客户端，与更多的开发者共同探讨iOS开发技术。</p>

<p>作者简介</p>

<p>高嘉峻（微博：@gaosboy），SegmentFault.com联合创始人，杭州iOS开发者沙龙发起人，资深iOS开发者。</p>

<p><a href="http://www.infoq.com/cn/articles/afn_vs_asi">http://www.infoq.com/cn/articles/afn_vs_asi</a></p>
]]></content>
  </entry>
  
</feed>
