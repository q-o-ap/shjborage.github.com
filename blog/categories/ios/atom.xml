<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">

  <title><![CDATA[Category: iOS | Saick Blog]]></title>
  <link href="http://saick.net/blog/categories/ios/atom.xml" rel="self"/>
  <link href="http://saick.net/"/>
  <updated>2014-03-24T23:08:32+08:00</updated>
  <id>http://saick.net/</id>
  <author>
    <name><![CDATA[Eric Shi]]></name>
    
  </author>
  <generator uri="http://octopress.org/">Octopress</generator>

  
  <entry>
    <title type="html"><![CDATA[性能提升-是否缓存图片-imageNamed与imageWithContentsOfFile的区别]]></title>
    <link href="http://saick.net/blog/2014/03/15/xing-neng-ti-sheng-shi-fou-huan-cun-tu-pian-imagenamedyu-imagewithcontentsoffilede-qu-bie/"/>
    <updated>2014-03-15T01:01:00+08:00</updated>
    <id>http://saick.net/blog/2014/03/15/xing-neng-ti-sheng-shi-fou-huan-cun-tu-pian-imagenamedyu-imagewithcontentsoffilede-qu-bie</id>
    <content type="html"><![CDATA[<p>常见的从bundle中加载图片的方式有两种，一个是用<code>imageNamed</code>，二是用<code>imageWithContentsOfFile</code>，第一种比较常见一点。</p>

<p>既然有两种类似的方法来实现相同的目的，那么他们之间的差别是什么呢？</p>

<p><code>imageNamed</code>的优点是当加载时会缓存图片。<code>imageNamed</code>的文档中这么说:
这个方法用一个指定的名字在系统缓存中查找并返回一个图片对象如果它存在的话。如果缓存中没有找到相应的图片，这个方法从指定的文档中加载然后缓存并返回这个对象。</p>

<p>相反的，<code>imageWithContentsOfFile</code>仅加载图片。</p>

<p>下面的代码说明了这两种方法的用法:</p>

<p><code>
UIImage *img = [UIImage imageNamed:@"myImage"];              // caching
// or
UIImage *img = [UIImage imageWithContentsOfFile:@"myImage"]; // no caching
</code>
那么我们应该如何选择呢？</p>

<p>如果你要加载一个大图片而且是一次性使用，那么就没必要缓存这个图片，用<code>imageWithContentsOfFile</code>足矣，这样不会浪费内存来缓存它。</p>

<p>然而，在图片反复重用的情况下<code>imageNamed</code>是一个好得多的选择。</p>

<p>更多阅读：<a href="http://blog.jobbole.com/37984/">iOS应用性能调优的25个建议和技巧</a></p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[UITableView的常见优化方式总结]]></title>
    <link href="http://saick.net/blog/2014/03/15/uitableviewde-chang-jian-you-hua-fang-shi-zong-jie/"/>
    <updated>2014-03-15T00:07:00+08:00</updated>
    <id>http://saick.net/blog/2014/03/15/uitableviewde-chang-jian-you-hua-fang-shi-zong-jie</id>
    <content type="html"><![CDATA[<p>众所周知，我们在iOS开发过程中与面试中，常见的问题就包括UITableView的滚动性能，足以见得这个功能的重要性。
为了保证table view平滑滚动，确保你采取了以下的措施:</p>

<ul>
<li>正确使用<code>reuseIdentifier</code>来重用cells</li>
<li>尽量使所有的view opaque，包括cell自身</li>
<li>避免渐变，图片缩放，后台选人</li>
<li>缓存行高</li>
<li>如果cell内现实的内容来自web，使用异步加载，缓存请求结果</li>
<li>使用<code>shadowPath</code>来画阴影</li>
<li>减少subviews的数量</li>
<li>尽量不适用<code>cellForRowAtIndexPath:</code>，如果你需要用到它，只用一次然后缓存结果</li>
<li>使用正确的数据结构来存储数据</li>
<li>使用<code>rowHeight</code>, <code>sectionFooterHeight</code> 和 <code>sectionHeaderHeight</code>来设定固定的高，不要请求delegate</li>
</ul>


<p>更多阅读：<a href="http://blog.jobbole.com/37984/">iOS应用性能调优的25个建议和技巧</a></p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[GCD的坑]]></title>
    <link href="http://saick.net/blog/2014/02/19/gcdde-keng/"/>
    <updated>2014-02-19T22:22:00+08:00</updated>
    <id>http://saick.net/blog/2014/02/19/gcdde-keng</id>
    <content type="html"><![CDATA[<p>最近用不少GCD的东西，相信很多童鞋也会被GCD的简便给吸引过来。
但是这玩意使用起来，还是有不少的坑，列举出来，希望能对遇到的有用。</p>

<!-- more -->


<p>大多数时间没啥事，但是有时这样使用，就会带来问题了。见测试代码：</p>

<p>```
//  dispatch_async(dispatch_get_global_queue(DISPATCH_QUEUE_PRIORITY_DEFAULT, 0), ^{</p>

<pre><code>for (int i=0; i&lt;=100; i++) {
</code></pre>

<p>//    for (int i=0; i&lt;=62; i++) {</p>

<pre><code>  dispatch_async(dispatch_get_global_queue(DISPATCH_QUEUE_PRIORITY_DEFAULT, 0), ^{
    NSString *key = [NSString stringWithFormat:@"key%d", i];
    NSMutableDictionary *value = [NSMutableDictionary dictionary];
    for (int j=0; j&lt;1/*10000*/; j++) {
      NSString *subKey = [NSString stringWithFormat:@"subkey%d", j];
      int random = arc4random();
      [value setObject:[NSString stringWithFormat:@"%d", random] forKey:subKey];
    }
</code></pre>

<p>//        int j=100;
//        while (&mdash;j>0) {
//          dispatch_async(dispatch_get_global_queue(DISPATCH_QUEUE_PRIORITY_DEFAULT, 0), ^{
//            NSLog(@&ldquo;sub&rdquo;);
//          });
//        }</p>

<p>//        [[TMCache sharedCache] setObject:value forKey:key];</p>

<pre><code>    [[TMCache sharedCache] setObject:value forKey:key block:NULL];
</code></pre>

<p>//        TMDiskCache *cache = [[TMDiskCache alloc] initWithName:@&ldquo;test.diskCache&rdquo;];
//        [cache setObject:value forKey:key block:NULL];</p>

<pre><code>    NSLog(@"%@", key);
  });
}
</code></pre>

<p>//  });
```</p>

<p><em>TMCache setObject:forKey:</em></p>

<p>```
&ndash; (void)setObject:(id <NSCoding>)object forKey:(NSString *)key
{</p>

<pre><code>if (!object || !key)
    return;

dispatch_semaphore_t semaphore = dispatch_semaphore_create(0);

[self setObject:object forKey:key block:^(TMCache *cache, NSString *key, id object) {
    dispatch_semaphore_signal(semaphore);
}];

dispatch_semaphore_wait(semaphore, DISPATCH_TIME_FOREVER);

#if !OS_OBJECT_USE_OBJC
dispatch_release(semaphore);
#endif
</code></pre>

<p>}
```</p>

<p><em>TMDiskCache 定义</em>
```
//#if <strong>IPHONE_OS_VERSION_MIN_REQUIRED >= </strong>IPHONE_4_0 //这个是默认值</p>

<h1>if 0</h1>

<pre><code>#define TMCacheStartBackgroundTask() UIBackgroundTaskIdentifier taskID = UIBackgroundTaskInvalid; \
        taskID = [[UIApplication sharedApplication] beginBackgroundTaskWithExpirationHandler:^{ \
        [[UIApplication sharedApplication] endBackgroundTask:taskID]; }];
#define TMCacheEndBackgroundTask() [[UIApplication sharedApplication] endBackgroundTask:taskID];
</code></pre>

<h1>else</h1>

<pre><code>#define TMCacheStartBackgroundTask()
#define TMCacheEndBackgroundTask()
</code></pre>

<h1>endif</h1>

<p>```</p>

<p><em>TMDiskCache 使用</em>
```
&ndash; (void)setObject:(id <NSCoding>)object forKey:(NSString *)key block:(TMDiskCacheObjectBlock)block
{</p>

<pre><code>NSDate *now = [[NSDate alloc] init];

if (!key || !object)
    return;

TMCacheStartBackgroundTask();

__weak TMDiskCache *weakSelf = self;

dispatch_async(_queue, ^{
    TMDiskCache *strongSelf = weakSelf;
    if (!strongSelf) {
        TMCacheEndBackgroundTask();
        return;
    }

    ...

    TMCacheEndBackgroundTask();
});
</code></pre>

<p>}
```</p>

<p>这样一个for循环，次数超过63就卡死了，啥也执行不了。
还有，如果关掉<code>TMCacheStartBackgroundTask</code>，并且不使用<code>dispatch_semaphore_t</code>做异步转同步的处理（直接使用<code>[[TMCache sharedCache] setObject:value forKey:key block:NULL];</code>），就没啥问题了。</p>

<p>看详情，跑数据的在此<a href="https://www.dropbox.com/s/59kdkfc3sm2gx1q/test_GCD.zip">下载测试工程</a></p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Objective-C&amp;XCode注释的正确写法]]></title>
    <link href="http://saick.net/blog/2014/02/07/objective-c-and-xcodezhu-shi-de-zheng-que-xie-fa/"/>
    <updated>2014-02-07T18:02:00+08:00</updated>
    <id>http://saick.net/blog/2014/02/07/objective-c-and-xcodezhu-shi-de-zheng-que-xie-fa</id>
    <content type="html"><![CDATA[<p>注释对于C体系的同学来说还是不太规范，对于XCode的文档系统来说，规范还是有帮助的，能在QuickHelp等提示中反应出来。所以还是多注意下会比较好。</p>

<p>推荐以下两种写法(主是方法注释，其它的以后遇到再补充吧)</p>

<p><div class='bogus-wrapper'><notextile><figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
<span class='line-number'>11</span>
<span class='line-number'>12</span>
<span class='line-number'>13</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>/**
</span><span class='line'> *  @brief update table
</span><span class='line'> *
</span><span class='line'> *  @param  model   you want to update the entity
</span><span class='line'> *  @param  where   can use NSString or NSDictionary or nil&lt;/p>
</span><span class='line'>
</span><span class='line'>&lt;pre>&lt;code>                when "where" is nil : update the value based on rowid column or primary key column
</span><span class='line'>&lt;/code>&lt;/pre>
</span><span class='line'>
</span><span class='line'>&lt;p> *
</span><span class='line'> *  @return the updated was successful
</span><span class='line'> &lt;em>/
</span><span class='line'>&ndash;(BOOL)updateToDB:(NSObject &lt;/em>)model where:(id)where;</span></code></pre></td></tr></table></div></figure></notextile></div></p>

<p><div class='bogus-wrapper'><notextile><figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>/&lt;em>&lt;em>
</span><span class='line'> @brief   每个Section的高度，默认为 0
</span><span class='line'> @param   niDropDown: NIDropDown，用于区分不同的NI
</span><span class='line'> @param   indexPath:  定位Section
</span><span class='line'> @return  高度
</span><span class='line'> &lt;/em>/
</span><span class='line'>&ndash; (CGFloat)niDropDown:(NIDropDown &lt;/em>)niDropDown heightForHeaderInSection:(NSInteger)section;</span></code></pre></td></tr></table></div></figure></notextile></div></p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[iOS中签名相关-MD5-sha1-10进制与16进制互转]]></title>
    <link href="http://saick.net/blog/2014/01/21/ioszhong-qian-ming-xiang-guan-md5-sha1-10jin-zhi-yu-16jin-zhi-hu-zhuan/"/>
    <updated>2014-01-21T21:32:00+08:00</updated>
    <id>http://saick.net/blog/2014/01/21/ioszhong-qian-ming-xiang-guan-md5-sha1-10jin-zhi-yu-16jin-zhi-hu-zhuan</id>
    <content type="html"><![CDATA[<p>费话少说，直接上代码</p>

<h4>md5, sha1</h4>

<p>```
+ (NSString <em>)md5:(NSString </em>)str
{
  if ([str length] == 0)</p>

<pre><code>return @"";
</code></pre>

<p>  unsigned char result[CC_MD5_DIGEST_LENGTH];
  CC_MD5([str UTF8String], (CC_LONG)strlen([str UTF8String]) , result);
  NSMutableString *digest = [NSMutableString string];
  for (int i = 0; i &lt; CC_MD5_DIGEST_LENGTH; i++)</p>

<pre><code>[digest appendFormat:@"%02X", result[i]];
</code></pre>

<p>  return [digest lowercaseString];
}</p>

<ul>
<li><p>(NSString <em>)sha1:(NSString </em>)input
{
if ([input length] == 0)
  return @&ldquo;&rdquo;;</p>

<p>const char <em>cstr = [input cStringUsingEncoding:NSUTF8StringEncoding];
NSData </em>data = [NSData dataWithBytes:cstr length:input.length];</p>

<p>uint8_t digest[CC_SHA1_DIGEST_LENGTH];</p>

<p>CC_SHA1(data.bytes, data.length, digest);</p>

<p>NSMutableString *output = [NSMutableString stringWithCapacity:CC_SHA1_DIGEST_LENGTH * 2];</p>

<p>for(int i=0; i&lt;CC_SHA1_DIGEST_LENGTH; i++) {
  [output appendFormat:@&ldquo;%02X&rdquo;, digest[i]];
}</p>

<p>return output;
}
```</p></li>
</ul>


<h4>10进制转16进制</h4>

<p><code>
NSString *num16Str = [NSString stringWithFormat:@"%x", numBase10];
</code></p>

<h4>16进制转10进制</h4>

<p><code>
NSString *num10Str = [NSString stringWithFormat:@"%d", strtoul([numBase16 UTF8String], 0, 16)];
</code></p>
]]></content>
  </entry>
  
</feed>
