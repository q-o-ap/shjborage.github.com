<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">

  <title><![CDATA[Category: iOS | Saick Blog - 专注技术，乐在其中]]></title>
  <link href="http://saick.net/blog/categories/ios/atom.xml" rel="self"/>
  <link href="http://saick.net/"/>
  <updated>2013-11-30T23:01:36+08:00</updated>
  <id>http://saick.net/</id>
  <author>
    <name><![CDATA[Eric Shi]]></name>
    
  </author>
  <generator uri="http://octopress.org/">Octopress</generator>

  
  <entry>
    <title type="html"><![CDATA[iOS 7教程：浅析Text Kit]]></title>
    <link href="http://saick.net/blog/2013/11/23/ios-7jiao-cheng-qian-xi-text-kit/"/>
    <updated>2013-11-23T22:06:00+08:00</updated>
    <id>http://saick.net/blog/2013/11/23/ios-7jiao-cheng-qian-xi-text-kit</id>
    <content type="html"><![CDATA[<p>转自<a href="http://beyondvincent.com/blog/2013/11/12/121-brief-analysis-text-kit/">破船</a>的博客</p>

<p>Text Kit是iOS 7中引入的一个新功能，非常值得开发者使用，下面先看看本文的目录结构：</p>

<ul>
<li>什么是Text Kit</li>
<li>Text Kit架构</li>
<li>Text Kit特点</li>
<li>Text Kit功能概述</li>
<li>Text Kit中重要的一些对象</li>
<li>Text Kit示例</li>
<li>小结</li>
<li>推荐Text Kit学习资源</li>
</ul>


<!-- more -->


<h3>什么是Text Kit</h3>

<p>在iOS7中，苹果引入了Text Kit&mdash;Text Kit是一个快速而又现代化的文字排版和渲染引擎。Text Kit在UIKit framework中的定义了一些类和相关协议，它最主要的作用就是为程序提供文字排版和渲染的功能。在程序中，通过Text Kit可以对文字进行存储(store)、布局(lay out)，以及用最精细的排版方式(例如文字间距、换行和对齐等)来显示文本内容。 苹果引入Text Kit的目的并非要取代已有的Core Text，Core Text的主要作用也是用于文字的排版和渲染中，它是一种先进而又处于底层技术，如果我们需要将文本内容直接渲染到图形上下文(Graphics context)时，从性能和易用性来考虑，最佳方案就是使用Core Text。而如果我们直接利用苹果提供的一些控件(例如UITextView、UILabel和UITextField等)对文字进行排版，无疑就是借助于UIkit framework中Text Kit提供的API。</p>

<h3>Text Kit架构</h3>

<p>下面，我们通过图1(此图来自WWDC2013 Session 210)来了解一下Text Kit的架构。图1是基于iOS 7绘制的，从图中，我们可以看到Text Kit是基于Core Text构建的，它通过Core Text与Core Graphics进行交互。而UI控件(UILabel、UITextField和UITextView)则构建于Text Kit之上，可见这些文本控件可以利用Text Kit提供的API来对文字进行排版和渲染处理。 从图中我们也可以看到SDK提供的UIWebView是基于WebKit的，它不能使用Text Kit提供的功能。</p>

<p><a href="http://www.flickr.com/photos/105999540@N03/11028898935/" title="2013-11-24-1 by EricShj, on Flickr"><img src="http://farm8.staticflickr.com/7439/11028898935_e836a8c934.jpg" width="500" height="211" alt="2013-11-24-1"></a></p>

<p>图1 Text Kit在iOS 7 SDK中的位置</p>

<p>我们再来看看图1中的相关组件在iOS6里面是如何对应的，如图2所示，可以看出在iOS 6中是没有Text Kit，并且UILabel、UIText和UITextView是基于String Drawing和WebKit构建的。其中String Drawing是与Core Graphics直接通讯。</p>

<p><a href="http://www.flickr.com/photos/105999540@N03/11029000326/" title="2013-11-24-2 by EricShj, on Flickr"><img src="http://farm8.staticflickr.com/7430/11029000326_f1345af879.jpg" width="500" height="242" alt="2013-11-24-2"></a></p>

<p>图2 在iOS 6中并没有Text Kit</p>

<h3>Text Kit特点</h3>

<p>从上面的介绍中，我们可以了解到Text Kit在UIKit中的作用非常重要。Text Kit在实际开发中具有如下特点：</p>

<ul>
<li>1.在UI控件中Text Kit完全掌控着文字的排版和渲染</li>
<li>2.UITextView、UITextField和UILabel是构建于Text Kit之上的</li>
<li>3.能够与动画、UICollectionView和UITableView做到无缝集成</li>
<li>4.Text Kit具有这样一些能力：Subclassing、Delegation和Notifcation。</li>
</ul>


<h3>Text Kit功能概述</h3>

<p>下面我们看看通过Text Kit，都能实现那些功能(这里列出了是一些常用和重要功能)：</p>

<ul>
<li>1.对文字进行分页或多列排版</li>
<li>2.支持文字的换行、折叠和着色等处理</li>
<li>3.可以调整字与字之间的距离、行间距、文字大小、指定特定的字体</li>
<li>4.支持富文本编辑，可以自定义文字截断</li>
<li>5.支持凸版印刷效果(letterpress)</li>
<li>6.支持数据类型的检测(例如链接、附件等)</li>
</ul>


<p>如图3，是利用Text Kit对文字做的分页排版</p>

<p><a href="http://www.flickr.com/photos/105999540@N03/11028898985/" title="2013-11-24-3 by EricShj, on Flickr"><img src="http://farm8.staticflickr.com/7420/11028898985_e42af249cf.jpg" width="500" height="303" alt="2013-11-24-3"></a></p>

<p>图3 利用Text Kit做的分页排版效果</p>

<p>再看图4，是利用Text Kit做的换行处理，其中对某个路径范围做了排除。</p>

<p><a href="http://www.flickr.com/photos/105999540@N03/11029105983/" title="2013-11-24-4 by EricShj, on Flickr"><img src="http://farm6.staticflickr.com/5530/11029105983_dba9ffd9fb.jpg" width="500" height="359" alt="2013-11-24-4"></a></p>

<p>图4 利用Text Kit做的换行处理效果</p>

<p>再来看看利用Text Kit做的凸版印刷效果，如图5所示</p>

<p><a href="http://www.flickr.com/photos/105999540@N03/11029054444/" title="2013-11-24-5 by EricShj, on Flickr"><img src="http://farm3.staticflickr.com/2885/11029054444_fd67572185.jpg" width="500" height="365" alt="2013-11-24-5"></a></p>

<p>图5 利用Text Kit做的凸版印刷效果</p>

<h3>Text Kit中重要的一些对象</h3>

<p>下面我们来看看Text Kit中重要的几个对象。</p>

<p><a href="http://www.flickr.com/photos/105999540@N03/11029054134/" title="2013-11-24-6 by EricShj, on Flickr"><img src="http://farm3.staticflickr.com/2849/11029054134_87158b12d4.jpg" width="500" height="293" alt="2013-11-24-6"></a></p>

<p>图6 Text Kit中重要的几个对象</p>

<p>如图6所示，Text Kit中主要有4个重要的对象。</p>

<ul>
<li>1.Text View是用来显示文本内容的控件，主要包括UILabel、UITextView和UITextField。</li>
<li>2.Text containers对应着NSTextContainer类。NSTextContainer定义了文本可以排版的区域。一般来说，都是矩形区域，当然，也可以根据需求，通过子类化NSTextContainer来创建别的一些形状，例如圆形、不规则的形状等。NSTextContainer不仅可以创建文本可以填充的区域，它还维护着一个数组——该数组定义了一个区域，排版的时候文字不会填充该区域，因此，我们可以在排版文字的时候，填充非文本元素(例如图片，如图4所示)。</li>
<li>3.Layout manager对应着NSLayoutManager类。该类负责对文字进行编辑排版处理——通过将存储在NSTextStorage中的数据转换为可以在视图控件中显示的文本内容，并把统一的字符编码映射到对应的字形(glyphs)上，然后将字形排版到NSTextContainer定义的区域中。</li>
<li>4.Text storage对应着NSTextStorage类。该类定义了Text Kit扩展文本处理系统中的基本存储机制。NSTextStorage继承自NSmutableAttributedString，主要用来存储文本的字符和相关属性。另外，当NSTextStorage中的字符或属性发生了改变，会通知NSLayoutManager，进而做到文本内容的显示更新。</li>
</ul>


<p>通常情况下，NSTextStorage、NSLayoutManager和NSTextContainer是一一对应的。如图7所示关系：</p>

<p><a href="http://www.flickr.com/photos/105999540@N03/11028999346/" title="2013-11-24-7 by EricShj, on Flickr"><img src="http://farm4.staticflickr.com/3722/11028999346_3d78e9639e.jpg" width="500" height="41" alt="2013-11-24-7"></a></p>

<p>图7 普通排版</p>

<p>当然，如果需要将文字显示为多列，或多页，可以按照如图8所示关系——使用多个NSTextContainer。</p>

<p><a href="http://www.flickr.com/photos/105999540@N03/11029104793/" title="2013-11-24-8 by EricShj, on Flickr"><img src="http://farm6.staticflickr.com/5472/11029104793_ed7de38158.jpg" width="500" height="64" alt="2013-11-24-8"></a></p>

<p>图8 多页或者多列排版</p>

<p>如果针对不同的排版方式，则可以使用多个NSLayoutManager，如图9所示</p>

<p><a href="http://www.flickr.com/photos/105999540@N03/11029104933/" title="2013-11-24-9 by EricShj, on Flickr"><img src="http://farm4.staticflickr.com/3826/11029104933_824d194d5f.jpg" width="500" height="59" alt="2013-11-24-9"></a></p>

<p>图9 不同的排版方式</p>

<p>如图10所示，通过形象的方式，对UITextView的组成做了分解。通常，我们在设备上只能看到最右边的文本显示界面，而内部的NSTextStorage、NSLayoutManager和NSTextContainer是看不出来的。通常由NSLayoutManager从NSTextStorage中读取出文本数据，然后根据一定的排版方式，将文本排版到NSTextContainer中，再由NSTextContainer结合UITextView将最终效果显示出来。</p>

<p><a href="http://www.flickr.com/photos/105999540@N03/11029105053/" title="2013-11-24-10 by EricShj, on Flickr"><img src="http://farm8.staticflickr.com/7294/11029105053_875c954204.jpg" width="500" height="319" alt="2013-11-24-10"></a></p>

<p>图10 UITextView的分解</p>

<h3>Text Kit示例</h3>

<p>前面对Text Kit做了一些介绍，下面我们配合一个例子(图文排版)，来进一步加深对Text Kit的认识。具体实现步骤如下：</p>

<ul>
<li>1.打开Xcode 5，新建一个Single View Application模板的程序，将工程命名为ExclusionPath。</li>
<li>2.打开Main.storyboard文件，然后再默认View Controller的View里面分别添加一个UITextView和UIImageView。并将这两个控件连接到ViewController.h中(名称分别为textView何imageView)。然后给textView设置一些字符串，imageView设置一个图片。</li>
<li>3.打开ViewController.m文件，找到viewDidLoad方法，用如下代码替换该方法：</li>
</ul>


<p>```
&ndash; (void)viewDidLoad
{</p>

<pre><code>[super viewDidLoad]; 

//创建一个平移手势对象，该对象可以调用imagePanned：方法 
UIPanGestureRecognizer *panGes = [[UIPanGestureRecognizer alloc] initWithTarget:self action:@selector(imagePanned:)]; 
[self.imageView addGestureRecognizer:panGes]; 

self.textView.textContainer.exclusionPaths = @[[self translatedBezierPath]]; 
</code></pre>

<p>}
```</p>

<p>在上面的代码中，给imageView添加了一个平移手势。另外通过调用translatedBezierPath方法，给textView的textContainer设置exclusionPaths属性值。表示需要排除的区域（也就是图片在排版中显示的位置）。</p>

<ul>
<li>4.下面来看一下translatedBezierPath方法的实现，如下代码所示</li>
</ul>


<p>```
&ndash; (UIBezierPath *)translatedBezierPath
{</p>

<pre><code>CGRect butterflyImageRect = [self.textView convertRect:self.imageView.frame fromView:self.view]; 
UIBezierPath *newButterflyPath = [UIBezierPath bezierPathWithRect:butterflyImageRect]; 

return newButterflyPath; 
</code></pre>

<p>}
```</p>

<p>在上面的代码中，利用imageView的frame属性创建了一个UIBezierPath，然后将该值返回。</p>

<ul>
<li>5, 还记得第3步中创建的平移手势吗。里面有一个action需要实现imagePanned:，下面来看看这个方法的实现：</li>
</ul>


<p>```
&ndash; (void)imagePanned:(id)sender
{</p>

<pre><code>if ([sender isKindOfClass:[UIPanGestureRecognizer class]]) { 
    UIPanGestureRecognizer *localSender = sender; 

    if (localSender.state == UIGestureRecognizerStateBegan) { 
        self.gestureStartingPoint = [localSender translationInView:self.textView]; 
        self.gestureStartingCenter = self.imageView.center; 
    } else if (localSender.state == UIGestureRecognizerStateChanged) { 
        CGPoint currentPoint = [localSender translationInView:self.textView]; 

        CGFloat distanceX = currentPoint.x - self.gestureStartingPoint.x; 
        CGFloat distanceY = currentPoint.y - self.gestureStartingPoint.y; 

        CGPoint newCenter = self.gestureStartingCenter; 

        newCenter.x += distanceX; 
        newCenter.y += distanceY; 

        self.imageView.center = newCenter; 

        self.textView.textContainer.exclusionPaths = @[[self translatedBezierPath]]; 
    } else if (localSender.state == UIGestureRecognizerStateEnded) { 
        self.gestureStartingPoint = CGPointZero; 
        self.gestureStartingCenter = CGPointZero; 
    } 
} 
</code></pre>

<p>}
```</p>

<p>在上面的代码中首先根据平移的距离来设置imageView的位置，然后利用translatedBezierPath方法重新计算了一下排除区域。</p>

<ul>
<li>6, 至此代码编写完毕，下面来运行程序，看看实际效果。如图11所示：</li>
</ul>


<p><a href="http://www.flickr.com/photos/105999540@N03/11028998926/" title="2013-11-24-11 by EricShj, on Flickr"><img src="http://farm4.staticflickr.com/3709/11028998926_73393ee43a.jpg" width="332" height="500" alt="2013-11-24-11"></a></p>

<p>图11 运行效果</p>

<h3>小结</h3>

<p>实际上，上面的示例，只是揭秘了Text Kit功能的冰山一角。从iOS7及以后的版本中，Text Kit在UIKit framework里面占据重要的地位，Text Kit在文字处理方面，具有非常强大的功能，并且开发者可以对Text Kit进行定制和扩展。据悉，苹果利用了2年的时间来开发Text Kit，相信这对许多开发者来说都是福音。</p>

<p>推荐Text Kit学习资源
更多关于Text Kit的学习资料，请参考下面的内容：
wwdc视频:
Introducing Text Kit
Advanced Text Layouts and Effects with Text Kit
Using Fonts with Text Kit</p>

<p>苹果官方参考文档
Text Programming Guide for iOS.pdf
NSLayoutManager Class Reference for iOS.pdf
NSLayoutManagerDelegate Protocol Reference for iOS.pdf
NSTextContainer Class Reference for iOS.pdf
NSTextStorage Class Reference for iOS.pdf
NSTextStorageDelegate Protocol Reference for iOS.pdf</p>

<p>苹果官方示例：
IntroToTextKit</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Autolayout及VFL经验分享]]></title>
    <link href="http://saick.net/blog/2013/11/23/autolayoutji-vfljing-yan-fen-xiang/"/>
    <updated>2013-11-23T17:53:00+08:00</updated>
    <id>http://saick.net/blog/2013/11/23/autolayoutji-vfljing-yan-fen-xiang</id>
    <content type="html"><![CDATA[<p><a href="http://www.cocoachina.com/applenews/devnews/2013/1108/7322.html">Origin</a></p>

<p>这篇不是什么教程, Cocoa autolayout出来蛮久了。以前多次想去深入研究一下，每次都很蛋疼无序。这东西是在有些搞。尤其习惯了code写布局的。看到Visual format language，简直要掀桌子。搜教程，满世界都是，没有一个讲得透彻的。例子空洞。你们就只会３个控件横向布局对法？浑浑噩噩看了多篇。有了点总结。槽不多吐了。简单讲讲。</p>

<!--more-->


<h3>Autolayout，开始于iOS6.0</h3>

<h4>一.什么时候用autolayout比较适合</h4>

<ul>
<li>１.不负责任的骑墙派说法：apple的设备越来越多了，你的应用应该都使用al。（并且用sb）</li>
<li>２.要看应用内容决定。如果你的内容是信息众多，同时需要展示的类别也很多，尺寸动态不定，甚至这些是在列表中的。（如社交应用）。Al能给于很大的帮助。</li>
<li>３.Mac os的应用。现在都做iOS了。mac app的窗口，会有大小变化。al比较合适。</li>
<li>４.支持多向转屏的iPad应用。（有需要支持多方向iphone场景么？那么长，脑残了？）</li>
<li>５.其他业务不复杂,页面较少的应用，其实，cocoa程序员写了多年code都有自己的ui编程习惯，这些习惯对于他们来说是很高效的。就算是第一项所说，布局的坐标都是相对的。</li>
</ul>


<p>如果是习惯于code写布局的，建议可以继续沿用，同时也要学习al。自我感觉al和传统布局写法，工作量不会相差太多。但是VFL用熟练了以后会有很大的改善。</p>

<h4>二.autolayout的基础理论</h4>

<p>al的核心出发点是</p>

<ul>
<li>1.view具有自我计算尺寸，布局的能力。通过它自身的内容，能够得到尺寸。</li>
<li>2.view的布局位置，确定于它与superview及其他view的关系。</li>
<li>3.与传统的autoresizingmask自适应相比，al更精确，能绝对的确定view的布局。</li>
<li>4.view不一定需要一个初始的rect。al中，view如果有足够的constraint，便可以确定自己的尺寸和位置，并且知道自己和其他view的关系。即，想确定view的布局，就给它（们）添加constraint。</li>
</ul>


<h4>三.xib下的autolayout</h4>

<p>似乎al和xib布局模式生来就是要搞在一起的。用xib加al，view布局非常简单容易。编程工作立刻变成了美工的连线拼图游戏。</p>

<p>开启xib或者sb后，选择需要view(s)。选择menu的Editor，选择Pin。子菜单的项目就是可用的constraints。</p>

<p>Width:固定自身宽度</p>

<p>Height:。。。</p>

<p>H- Spacing: 固定两个view的水平间距</p>

<p>V- Spacing:。。。</p>

<p>下面４个分别是view相对于superview的左、右、上、下的间距</p>

<p>Widths Equally:两个view保持宽度相同</p>

<p>Heights Equally:。。。</p>

<p>xib界面右下角工具条也有可以编辑constraint的方式：</p>

<p>每个constraint添加后都是可以编辑的。选中某个constraint后开启右边栏选inspector。可以修改数值。（这个数值是view间的偏移量）和优先级。</p>

<p>自己慢慢拖着玩去。这不是傻瓜教程。点到位，自己研究。</p>

<p>xib下的al比较直观。可以基本看到效果和误差值。还有不正确的constraint的提示。少了constraint编译器会补，多了会提示报错。（不过都会引起界面布局不对，自己慢慢调吧，哥现在还是满篇alert，没有让编译器感觉矛盾费解的constraint，都是可以work的。）</p>

<p>还有resolve的方式解决constraint的问题，抱歉，我不会。</p>

<h4>四.编码方式使用autolayout</h4>

<p>对于页面不多，的普通应用。xib/sb加al。拖拖拽拽。娱乐中就可以完成UI的工作。al的确给于了不少方便。</p>

<p>不过多年的强迫症程序猿怎么会忍受这种很逊的方式。（拖积木？不敲代码？好像一天没做事。）</p>

<p>1.Visual format language　（应该不算语言）
Apple的工程师很有爱，发明了这种哭笑不得的象形文字。感觉它就是种解析方式。</p>

<p>Apple的官方文档给出了少之又少的文档和坑爹的例子。（视频我没看，不知道怎么样）网上的同学们也写了点不痛不痒的几句代码。你这是学了１＋１就让人搞微积分的节奏么？要写不写清楚，不如不写。</p>

<p>从厚道的老外那看了几篇。自己体会了些，分享给大家。只是个基本水平吧，会了这些，代码写al应该没有问题了。深入的我也还不会，希望遇到更有爱的牛人分享。</p>

<p>VFL在程序中由支持：</p>

<p><code>
+ (NSArray *)constraintsWithVisualFormat:(NSString *)format options:(NSLayoutFormatOptions)opts metrics:(NSDictionary *)metrics views:(NSDictionary *)views;   
</code></p>

<ul>
<li>它返回一组constraint.</li>
<li>format是你的VFL字串，等下讲。</li>
<li>opts自己点去头文件看。有些情况会用，等下有例子。</li>
<li>metrics是一个奇妙的字典，是你自己定义的。这个字典里面的key可以写在format字串中。编译器解析时，自动替换为metrics字典中的value。等下有例子。</li>
<li>views是需要constraint关系的所有view.(也可以是一个)</li>
</ul>


<p>2.VFL例子</p>

<p>写vfl字串的时候，脑海里要想象出画面的合理性。不合理的constraint会导致程序运行时报错或者直接崩溃。</p>

<p>随便写几个</p>

<p><code>
NSDictionary *dict1 = NSDictionaryOfVariableBindings(_boxV,_headerL,_imageV,_backBtn,_doneBtn);   
NSDictionary *metrics = @{@"hPadding":@5,@"vPadding":@5,@"imageEdge":@150.0};   
NSString *vfl = @"|-hPadding-[_boxV]-hPadding-|";   
NSString *vfl0 = @"V:|-25-[_boxV]";   
NSString *vfl3 = @"V:|-vPadding-[_headerL]-vPadding-[_imageV(imageEdge)]-vPadding-[_backBtn]-vPadding-|";   
</code></p>

<p>dict1就是api 中需要的最后一个参数views。由上述宏来完成。</p>

<p>metrics定义了一些vfl中要用的参数。
下面有些vfl字串，一看便知如何使用metrics。</p>

<p>看到：</p>

<p>1) &ldquo;|"表示superview. |-间距-[view1对象名]&ndash;(>=20)&ndash;[view2对象名] 不写H/V就表示横向，间距可以写固定值也可写>/&lt;。形象化的理解，&rdquo;|&ldquo;是用来确定view上、下、左、右关系的。 想要确定从上到下的关系，就加V:|。那么这个vfl字串就可以描述从上到下的view们的关系。</p>

<p>2) 看到vfl3里面，方括号表示view，圆括号表示尺寸数值。支持大小等于。或者另一个view　|&ndash;[view1(view2)]，v１的宽度等于v２。</p>

<p>3) 优先级用＠表示。如V:|-50@750-[view(55)]，或者写到metrics里面更好。 具体定义查看UILayoutPriority。有几个固定的数值。1000表示必须支持。</p>

<p>4) options，这个要看具体需要。如果是竖排V布局，可以添加NSLayoutFormatAlignAllLeft，让他们对齐。根据需要也可以添加按位或NSLayoutFormatAlignAllLeft | NSLayoutFormatAlignAllRight。（鬼知道什么需要，自己看经验吧）</p>

<p>5) 写好以后一般把constraint添加给superview：</p>

<p><code>
NSString *vfl1 = @"|-hPadding-[_headerL]-hPadding-|";   
[self.view addConstraints:[NSLayoutConstraint constraintsWithVisualFormat:vfl1 options:0 metrics:metrics views:dict1]];   
</code></p>

<p>6)还有一个api用于生成单个constaint</p>

<p><code>
+(id)constraintWithItem:(id)view1 attribute:(NSLayoutAttribute)attr1 relatedBy:(NSLayoutRelation)relation toItem:(id)view2 attribute:(NSLayoutAttribute)attr2 multiplier:(CGFloat)multiplier constant:(CGFloat)c;  
</code></p>

<p>对于参数，记得，view1.attr1 = view2.attr2 * multiplier + constant就好。
这个是不用VFL的，好理解，但是不方便。如果用这个写。工作两不会比传统布局少多少。</p>

<h4>五.实际操作中的问题</h4>

<p>上面都是理论，世界操作会有些奇怪的问题要注意。这节才是重点。</p>

<p>xib模式，没啥要注意的，xib里报warning就报吧，我也不知道怎么弄，一切正常就好。</p>

<p><strong>编码模式中，注意</strong></p>

<ul>
<li>1.addConstraint(s)前，view应该去部被addSubView上去了。</li>
<li>2.不必给views写frame</li>
<li>3.给必要的view关掉AutoresizeingMask。[_aView setTranslatesAutoresizingMaskIntoConstraints:NO];</li>
<li>4.UILabel换行要写linebreakMode,要写numberOfLines(iOS7.0默认好像是1，坑爹了)</li>
<li>5.UILabel要想换行，一定要添加preferredMaxLayoutWidth。否则没法初始化宽度。</li>
</ul>


<p>编码模式感受到的最大方便。label换行不用写行高计算了。完全自动适应。label所在的superview也会自动计算rect。这才是al的精华。</p>

<p>所以，可以不用写这些了：</p>

<p><div class='bogus-wrapper'><notextile><figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
<span class='line-number'>11</span>
<span class='line-number'>12</span>
<span class='line-number'>13</span>
<span class='line-number'>14</span>
<span class='line-number'>15</span>
<span class='line-number'>16</span>
<span class='line-number'>17</span>
<span class='line-number'>18</span>
<span class='line-number'>19</span>
<span class='line-number'>20</span>
<span class='line-number'>21</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>/*&lt;/p>
</span><span class='line'>
</span><span class='line'>&lt;pre>&lt;code>if([[UIDevice currentDevice].systemVersion floatValue]&lt;7.0){  
</span><span class='line'>    CGSize titleS = [title sizeWithFont:[_headerL font]  
</span><span class='line'>                       constrainedToSize:CGSizeMake(270.0, CGFLOAT_MAX)  
</span><span class='line'>                           lineBreakMode:NSLineBreakByWordWrapping];  
</span><span class='line'>
</span><span class='line'>    _headerL.frame = CGRectMake(_headerL.frame.origin.x, _headerL.frame.origin.y,  
</span><span class='line'>                                _headerL.frame.size.width, titleS.height);  
</span><span class='line'>}else{  
</span><span class='line'>    CGRect titleR = [title boundingRectWithSize:CGSizeMake(270.0, CGFLOAT_MAX)  
</span><span class='line'>                                        options:NSStringDrawingUsesLineFragmentOrigin  
</span><span class='line'>                                     attributes:nil  
</span><span class='line'>                                        context:nil];  
</span><span class='line'>    headerL.frame = CGRectMake(_headerL.frame.origin.x, _headerL.frame.origin.y,  
</span><span class='line'>                               _headerL.frame.size.width, titleR.size.height);  
</span><span class='line'>}  
</span><span class='line'>*/
</span><span class='line'>&lt;/code>&lt;/pre>
</span><span class='line'>
</span><span class='line'>&lt;p></span></code></pre></td></tr></table></div></figure></notextile></div></p>

<p>我遇到了些问题，至今没有解决：</p>

<p>纯代码写的Viewcontroller 无法正常显示al布局。用空白的xib做了vc后，其余再用code写，就正常了。怀疑自己写的self.view，还需要针对autolayout做什么处理。至此，al，基本功能已经可以为你服务了。的确方便很多，建议还是使用VFL代码模式，熟练后能够提高很多效率。</p>

<p>引用别的同学的评论：</p>

<p><em>最后一个问题：可以试一下self.view=自定义的视图； 不要用[self.view addSubview:&hellip;];</em></p>

<p><a href="https://www.dropbox.com/s/vizq53ig4e1z7io/20131123_AutoLayoutTest.zip">demo</a></p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[iOS开发：从新手到专家的一些建议]]></title>
    <link href="http://saick.net/blog/2013/11/23/ioskai-fa-cong-xin-shou-dao-zhuan-jia-de-xie-jian-yi/"/>
    <updated>2013-11-23T17:32:00+08:00</updated>
    <id>http://saick.net/blog/2013/11/23/ioskai-fa-cong-xin-shou-dao-zhuan-jia-de-xie-jian-yi</id>
    <content type="html"><![CDATA[<p><a href="http://www.cocoachina.com/applenews/devnews/2013/1118/7371.html">Origin</a></p>

<p>虽然你有可能在一周内学习到iOS开发的本质，但想要精通iOS开发需则要花费更长的时间。问题是你如何从新手变成专家？在这篇文章中，我们主要就这个主题给出一些建议（如果你有好的建议和相关文章欢迎分享给更多开发者）</p>

<!-- more -->


<h3>1.练习，练习还是练习</h3>

<p>iOS开发没有捷径可走。这是我在继续这个话题之前需要强调的东西，因为摆脱任何常常浮现于你脑海的幻想很重要。如果你仅仅在星期天的4PM和5PM之间学习/练习编程，那么你不会成为一个熟练的iOS开发者。不要误会我的意思，这么做可能会很有趣，但是它很难让你成为一个老练的专业的iOS开发者。除了极少数的人，大部分人都需要不断的练习和实践。如果你还没有准备好投入大量时间，这时候最好重新审视你的目标和理想。</p>

<h3>2.向其他人学习</h3>

<p>提升开发技能和采用最佳实践的最好策略之一是学习别人的代码。这不仅仅意味着浏览Stack Overflow，但更重要的是其他开发者的各种开源类库和代码片段。</p>

<p>不管何时你一头扎进各种类库的学习，比如AFNetworking或者Magical Record，很关键的一点是不要被各种代码淹没。有可能你不理解各种库中的代码，但这不是真正的关键，重点是从一个更高的层次来看源码和尽可能多地学习，比如<em>命名规范</em>、<em>最佳实践</em>&amp;以及<em>设计模式</em>等。</p>

<p>除了学习别人的代码外，创建你自己的类库是一个最好的学习方法。不久前，我用Core Data作为数据层开发了一款app，我没有使用Magical Record，我决定通过学习Magical Record创建自己的库，并重新创建了我需要的功能。这种方法不仅帮我创建了一个更加灵活的库，也让我学习到很多Magical Record内部的工作原理。</p>

<h3>3. 不要仅仅复制和粘贴</h3>

<p>这一点让我看到了正确学习方式的另一个关键面：不要不动脑子简单地复制和粘贴。我们常常会使用我们在Stack Overflow或者苹果开发者论坛找到的各种代码片段，但是不要为了偷懒简单地复制粘贴你从网络上找到的代码，这样你很难彻底理解它。最大的危险在于这可能会导致意外的行为，以致于你的代码以后都很难调试和修复。</p>

<p>有时候，复制别人的代码片段看着可能已经解决了你遇到的问题，但是我强烈建议不要这么做。阅读代码，理解你往代码库添加的东西，可能的话定制你需要的解决方案。不用说，这并不适用于开发者积极维护的库或框架。在项目中使用Magical Record前，如果你需要仔细检查它，那么我确信你已经理解了不同之处。使用你自己的常识。</p>

<h3>4. 模式</h3>

<p>Cocoa和Objective-C在很多方面都不同于其他编程语言和环境。这意味着他们有自己独特的模式和最佳实践。我确信你已经熟悉了一些常见的模式，比如委托和通知。但还有很多模式可以开发过程中帮助你，比如单例模式、观察者模式以及通用模式等。Cocoa Fundamentals Guide很好地概述了Cocoa中大部分常用模式。</p>

<h3>5.了解你的工具</h3>

<p>作为一个开发者并不仅仅是理解语言和框架，理解你每天使用的工具同样重要。对于iOS开发来说，这意味着你需要很好地理解Xcode和其他可能用到的工具，比如PonyDebugger和Charles。如果你想学习一些额外的技巧，你可能会对我此前的一篇文章（iOS Quick Tip: 7 Tips to Speed Up Your Development）感兴趣。</p>

<h3>6.与时俱进</h3>

<p>即使你不能参加苹果一年一度的开发者大会&mdash;WWDC，但浏览大量的会议视频是个很好的学习方法，你可以观看你感兴趣的专题视频，它们都是由在某方面擅长的工程师演讲，他们可以告诉你一些细节信息以及相关使用说明。另外，你还可以多关注优秀的开发者，他们会定期写一些技术文章，比如比如Matt Gemmell、 Aaron Hillegass以及Mike Ash，你可以在我为Mobiletuts+写的这篇“Where To Go Next”文章中找到更多学习资源。</p>

<h3>7.学习其他语言</h3>

<p>我已经注意到学习新语言或者使用新框架让我对软件开发的整体理解有了明显提高。这种方法的优点在于不会限制你对最熟悉语言的认知和它潜在可能性的理解。我最近在研究Ember.js，并了解到它的创建者 Yehuda Katz和Tom Dale是从Cocoa获得的灵感。Ember.js对mvc的实现并没有遵循JavaScript framework，不过如果你熟悉cocoa的话，就不会感觉到奇怪了。</p>

<p>对于软件开发来说，没有最好的语言，每种语言都有自己的优势和劣势。但是好的一面在于或多或少他们都有所不同，这使得学习新语言变得更加有趣和更有启发性。比如对我来说，Ruby在写DRY (Don’t Repeat Yourself)、易读的、干净的代码方面让我大开眼界。</p>

<h3>总结</h3>

<p>如果你不想花费时间成为一个更好的程序员，那么你可能要重新考虑下为什么你把成为一个程序员摆在首位。但如果你会因为一个可以帮你的新类库或者开发工具而兴奋，那么随着时间的流逝，你在提高自身技能方面可能不会有什么问题。你真的必须热爱你所做的事情，并在这面擅长，这一点尤其适用于编程。不管什么人告诉你，你不会在一夜之间成为一个老练的开发者，但如果你保持不间断的学习，并细心打磨自己的“手艺”，我想你的技术会有很好的提高。</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[iOS Quick Tip: 7 Tips to Speed Up Your Development]]></title>
    <link href="http://saick.net/blog/2013/11/23/ios-quick-tip-7-tips-to-speed-up-your-development/"/>
    <updated>2013-11-23T16:18:00+08:00</updated>
    <id>http://saick.net/blog/2013/11/23/ios-quick-tip-7-tips-to-speed-up-your-development</id>
    <content type="html"><![CDATA[<p><a href="http://mobile.tutsplus.com/tutorials/iphone/ios-quick-tip-7-tips-to-speed-up-your-development/">origin</a></p>

<p>Most developers are always looking for ways to improve or automate their workflow being it with a simple script to automate a common task or by learning every possible keyboard shortcut of their favorite text editor. In this article, I will show you seven tips that will speed up and streamline your workflow in Xcode.</p>

<!-- more -->


<h3>1. Keyboard Shortcuts</h3>

<p>Virtually every Xcode command has a keyboard shortcut that you can learn and even customize. Investing the time to learn keyboard shortcuts will increase your efficiency tremendously. If you are like me, and a lot of other developers, you prefer to keep your hands on the keyboard when you’re writing code and that is exactly what most key bindings are for.</p>

<p>If you don’t like the default keyboard shortcuts, then you’ll be happy to learn that you can customize Xcode’s default keyboard shortcuts in the <strong>Preferences</strong> window under the <strong>Key Bindings</strong> tab.</p>

<p><a href="http://www.flickr.com/photos/105999540@N03/11006344093/" title="2013-11-23-1 by EricShj, on Flickr"><img src="http://farm4.staticflickr.com/3817/11006344093_814a28a77f.jpg" width="500" height="367" alt="2013-11-23-1"></a>
iOS Quick Tip: 5 Tips to Speed Up Your Development &ndash; Managing Key Bindings in Xcode&rsquo;s Preferences Window</p>

<p>If you don’t want to scroll through the long list of keyboard shortcuts to learn the most important ones, then I recommend browsing through this <a href="http://stackoverflow.com/questions/146297/hidden-features-of-xcode">question on Stack Overflow</a>. It lists the most important key bindings in Xcode and also includes a number of other neat tips and tricks.</p>

<h3>2. Cocoapods</h3>

<p>Cocoapods, a great project started by Eloy Durán, has gained significant traction in the Cocoa community. What is Cocoapods? Cocoapods is a tool for managing dependencies in Xcode projects. Due to Cocoapods’ popularity, hundreds of third party libraries have been updated to support Cocoapods. Even though Cocoapods is distributed as a Ruby gem, you don’t need to understand Ruby to benefit from Cocoapods.</p>

<p>If you are tired of manually managing third party libraries in your iOS or OS X projects, or you’re looking for a solution that makes updating third party libraries easier, then Cocoapods is the best solution available. If you want to learn about Cocoapods, then I recommend reading <a href="http://mobile.tutsplus.com/tutorials/iphone/streamlining-cocoa-development-with-cocoapods/">a post about Cocoapods</a> that I wrote earlier this year. It will get you up and running in minutes.</p>

<h3>3. Code Snippets</h3>

<p>Chances are that you use a text or code snippet manager, such as <strong>TextExpander</strong> or <strong>CodeBox</strong>. I use TextExpander all the time and it has saved me countless keystrokes over the years. <em>I use Dash to manage my document sets and code snippets.</em> However, Xcode also has a snippet manager. It lives in Xcode’s right sidebar next to the Object Library.</p>

<p>Why should you use Xcode’s snippet manager instead of the alternatives I mentioned earlier? In Xcode, each snippet has a number of additional attributes that really make snippets powerful and flexible. Each snippet has a Platform and Language attribute as well as a completion scope. A snippet’s completion scope is especially useful and integrates neatly with Xcode’s editor. Did I mention that each snippet can have multiple placeholders?</p>

<p><a href="http://www.flickr.com/photos/105999540@N03/11006222706/" title="2013-11-23-2 by EricShj, on Flickr"><img src="http://farm8.staticflickr.com/7364/11006222706_6e4d20315d.jpg" width="500" height="212" alt="2013-11-23-2"></a></p>

<p>iOS Quick Tip: 5 Tips to Speed Up Your Development &ndash; Creating and Managing Code Snippets is Very Easy in Xcode</p>

<h3>4. Learn Git</h3>

<p>If you’ve just started to learn how to program and the concept source control is new to you, then I strongly recommend that you take some time to learn the basics of Git. Git is <a href="http://en.wikipedia.org/wiki/Git_(software">a distributed version control and source code management system</a>). Euh … what? In short, Git helps you manage your source code easily and efficiently. Combine Git with GitHub or BitBucket and you are starting to look like a professional programmer. The added benefit is that Xcode integrates nicely with Git and this integration will only improve over time.</p>

<p>Once you’ve learned the basics of Git, it is recommended to include a proper .gitignore file in your Xcode project. A good place to start is this question on Stack Overflow.</p>

<p>Even though Git is commonly used through the command line, there are a number of applications that provide a GUI (Graphical User Interface). My favorite is <a href="http://www.git-tower.com/">Tower</a>, developed by Fournova, which recently reached version 1.5. Atlassian‘s <a href="https://www.atlassian.com/software/sourcetree/overview">SourceTree</a> is another great and free alternative.</p>

<h3>5. Xcode Behaviors</h3>

<p>Xcode is an incredibly powerful editor and it only gets better over the years. One of the aspects that I use frequently is Xcode’s <strong>Behaviors</strong> feature. By defining behaviors, you can tell Xcode what it should do when a particular event occurs, such as when a crash occurs while debugging or when you’ve successfully archived an application.</p>

<p>You can configure these behaviors in Xcode’s Preferences Window. If you don’t like it when Xcode shows the console when output is generated, you can disable this behavior in the <strong>Behaviors</strong> panel. Do you want Xcode to show the <strong>Issues Navigator</strong> when one or more tests fail? This is all possible with Xcode Behaviors.</p>

<p><a href="http://www.flickr.com/photos/105999540@N03/11006291054/" title="2013-11-23-3 by EricShj, on Flickr"><img src="http://farm4.staticflickr.com/3812/11006291054_0794190295.jpg" width="500" height="367" alt="2013-11-23-3"></a></p>

<p>iOS Quick Tip: 5 Tips to Speed Up Your Development &ndash; Managing Behaviors in Xcode&rsquo;s Preferences Window</p>

<p>Xcode predefines a number of common behaviors for you, such as Build, Testing, and Running. However, you can also define custom behaviors and assign a keyboard shortcut to it. This is a convenient way to set up Xcode the way you want with a single key binding.</p>

<h3>6. Tabs and Windows</h3>

<p>I really like the unified look of Xcode 4 and the integration of Interface Builder. However, it is sometimes useful to have more than one window at hand, for example, when you are working in the console and the editor at the same time or you use multiple monitors. In Xcode 4, it is still possible to work with multiple windows. You can create a new window using the keyboard shortcut <code>Shift + Cmd + T</code> or use the menu, <strong>File > New > Window</strong>.</p>

<p>Even more useful are tabs. Almost every code editor has tabs these days and Xcode is no exception. I rarely find myself in an Xcode window that has no, or one, tab. What few people know is that Xcode tabs can be named. You can even tie named tabs and Xcode behaviors together, which is especially useful during debugging.</p>

<h3>7. Documentation</h3>

<p>Even if you’ve been developing Cocoa applications for years, the documentation should never be more than a click away. There are a number of ways to quickly access Xcode’s documentation browser. The solution I use most often is holding the option key and clicking a method in Xcode’s code editor. This presents you with a summary of the particular method. If you want to read more or open the documentation browser, you can click one of the links in the pop up window.</p>

<p><a href="http://www.flickr.com/photos/105999540@N03/11006118705/" title="2013-11-23-4 by EricShj, on Flickr"><img src="http://farm8.staticflickr.com/7341/11006118705_ee2259bfdf.jpg" width="500" height="309" alt="2013-11-23-4"></a></p>

<p>iOS Quick Tip: 5 Tips to Speed Up Your Development &ndash; The Documentation is Your Friend</p>

<p>You can achieve the same by opening Xcode’s right sidebar and open the Quick Help Inspector tab. The help inspector updates as the cursor moves. As with the pop up window, clicking on one of the links in the help inspector takes you to the respective section in the documentation in the documentation browser.</p>

<p><a href="http://www.flickr.com/photos/105999540@N03/11006118685/" title="2013-11-23-5 by EricShj, on Flickr"><img src="http://farm4.staticflickr.com/3782/11006118685_ec1975ac10.jpg" width="500" height="422" alt="2013-11-23-5"></a></p>

<p>iOS Quick Tip: 5 Tips to Speed Up Your Development &ndash; The Quick Help Inspector</p>

<p>One of the downsides of Xcode’s documentation browser is that it can be slow at times. For this reason, I frequently use Dash, a dedicated documentation and snippet manager. Dash is very fast and provides support for more than eighty languages, libraries, frameworks, and APIs. It is well worth checking out.</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[深入浅出 Cocoa 多线程编程之 block 与 dispatch quene]]></title>
    <link href="http://saick.net/blog/2013/11/12/shen-ru-qian-chu-cocoa-duo-xian-cheng-bian-cheng-zhi-block-yu-dispatch-quene/"/>
    <updated>2013-11-12T22:20:00+08:00</updated>
    <id>http://saick.net/blog/2013/11/12/shen-ru-qian-chu-cocoa-duo-xian-cheng-bian-cheng-zhi-block-yu-dispatch-quene</id>
    <content type="html"><![CDATA[<p>深入浅出 Cocoa 多线程编程之 block 与 dispatch quene
罗朝辉(<a href="http://blog.csdn.net/kesalin">http://blog.csdn.net/kesalin</a>)
CC 许可，转载请注明出处</p>

<p>block 是 Apple 在 GCC 4.2 中扩充的新语法特性，其目的是支持多核并行编程。我们可以将
dispatch_queue 与 block 结合起来使用，方便进行多线程编程。</p>

<!-- more -->


<p>本文源代码下载：<a href="http://www.cppblog.com/Files/kesalin/StudyBlocks.zip">点击下载</a></p>

<h3>1，实验工程准备</h3>

<p>在 XCode 4.0 中，我们建立一个 Mac OS X Application 类型的 Command Line Tool，在 Type 里面我们选择 Foundation 就好，工程名字暂且为 StudyBlocks.默认生成的工程代码 main.m 内容如下：</p>

<p><div class='bogus-wrapper'><notextile><figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
<span class='line-number'>11</span>
<span class='line-number'>12</span>
<span class='line-number'>13</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>int main (int argc, const char * argv[])&lt;br/>
</span><span class='line'>{&lt;/p>
</span><span class='line'>
</span><span class='line'>&lt;pre>&lt;code>NSAutoreleasePool * pool = [[NSAutoreleasePool alloc] init];  
</span><span class='line'>
</span><span class='line'>// insert code here...  
</span><span class='line'>NSLog(@"Hello, World!");  
</span><span class='line'>
</span><span class='line'>[pool drain];  
</span><span class='line'>return 0;  
</span><span class='line'>&lt;/code>&lt;/pre>
</span><span class='line'>
</span><span class='line'>&lt;p>}&lt;br/></span></code></pre></td></tr></table></div></figure></notextile></div></p>

<h3>2，如何编写 block</h3>

<p>在自动生成的工程代码中，默认打印一条语句"Hello, World!&ldquo;，这个任务可以不可以用 block 语法来实现呢？答案是肯定的，请看：</p>

<p><code>
void (^aBlock)(void) = ^(void){ NSLog(@"Hello, World!"); };  
aBlock();  
</code></p>

<p>用上面的这两行语句替换 main.m 中的 NSLog(@&ldquo;Hello, World!&rdquo;); 语句，编译运行，结果是一样的。</p>

<p>这两行语句是什么意思呢？首先，等号左边的 void (^aBlock)(void) 表示声明了一个 block，这个 block 不带参数(void)且也无返回参数(void)；等号右边的 ^(void){ } 结构表示一个 block 的实现体，至于这个 block 具体要做的事情就都在 {} 之间了。在这里我们仅仅是打印一条语句。整个语句就是声明一个 block，并对其赋值。第二个语句就是调用这个 block 做实际的事情，就像我们调用函数一样。block 很有点像 C++0X 中的 Lambda 表达式。</p>

<p>我们也可以这么写：</p>

<p>```
void (^aBlock)(void) = 0;<br/>
aBlock = ^(void){</p>

<pre><code>NSLog(@" &gt;&gt; Hello, World!");  
</code></pre>

<p>};<br/>
aBlock();<br/>
```</p>

<p>现在我们知道了一个 block 该如何编写了，那么 block 数组呢？也很简单，请看：</p>

<p>```
void (^blocks[2])(void) = {</p>

<pre><code>^(void){ NSLog(@" &gt;&gt; This is block 1!"); },  
^(void){ NSLog(@" &gt;&gt; This is block 2!"); }  
</code></pre>

<p>};
blocks<a href="">0</a>;<br/>
blocks<a href="">1</a>;<br/>
```</p>

<p><strong>谨记！</strong></p>

<p>block 是分配在 <em>stack</em> 上的，这意味着我们必须小心里处理 block 的生命周期。
比如如下的做法是不对的，因为 stack 分配的 block 在 if 或 else 内是有效的，但是到大括号 } 退出时就可能无效了：</p>

<p><div class='bogus-wrapper'><notextile><figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
<span class='line-number'>11</span>
<span class='line-number'>12</span>
<span class='line-number'>13</span>
<span class='line-number'>14</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>dispatch_block_t block;&lt;/p>
</span><span class='line'>
</span><span class='line'>&lt;p>if (x) {&lt;/p>
</span><span class='line'>
</span><span class='line'>&lt;pre>&lt;code>block = ^{ printf("true\n"); };  
</span><span class='line'>&lt;/code>&lt;/pre>
</span><span class='line'>
</span><span class='line'>&lt;p>} else {&lt;/p>
</span><span class='line'>
</span><span class='line'>&lt;pre>&lt;code>block = ^{ printf("false\n"); };  
</span><span class='line'>&lt;/code>&lt;/pre>
</span><span class='line'>
</span><span class='line'>&lt;p>}&lt;br/>
</span><span class='line'>block();</span></code></pre></td></tr></table></div></figure></notextile></div></p>

<p>上面的代码就相当于下面这样的 unsafe 代码：</p>

<p>```
if (x) {</p>

<pre><code>struct Block __tmp_1 = ...; // setup details  
block = &amp;__tmp_1;  
</code></pre>

<p>} else {</p>

<pre><code>struct Block __tmp_2 = ...; // setup details  
block = &amp;__tmp_2;  
</code></pre>

<p>}
```</p>

<h3>3，如何在 block 中修改外部变量</h3>

<p>考虑到 block 的目的是为了支持并行编程，对于普通的 local 变量，我们就不能在 block 里面随意修改（原因很简单，block 可以被多个线程并行运行，会有问题的），而且如果你在 block 中修改普通的 local 变量，编译器也会报错。那么该如何修改外部变量呢？有两种办法，第一种是可以修改 static 全局变量；第二种是可以修改用新关键字 __block 修饰的变量。请看：</p>

<p><div class='bogus-wrapper'><notextile><figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
<span class='line-number'>11</span>
<span class='line-number'>12</span>
<span class='line-number'>13</span>
<span class='line-number'>14</span>
<span class='line-number'>15</span>
<span class='line-number'>16</span>
<span class='line-number'>17</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>__block int blockLocal  = 100;&lt;br/>
</span><span class='line'>static int staticLocal  = 100;&lt;/p>
</span><span class='line'>
</span><span class='line'>&lt;p>void (^aBlock)(void) = ^(void){&lt;/p>
</span><span class='line'>
</span><span class='line'>&lt;pre>&lt;code>NSLog(@" &gt;&gt; Sum: %d\n", global + staticLocal);  
</span><span class='line'>
</span><span class='line'>global++;  
</span><span class='line'>blockLocal++;  
</span><span class='line'>staticLocal++;  
</span><span class='line'>&lt;/code>&lt;/pre>
</span><span class='line'>
</span><span class='line'>&lt;p>};&lt;/p>
</span><span class='line'>
</span><span class='line'>&lt;p>aBlock();&lt;/p>
</span><span class='line'>
</span><span class='line'>&lt;p>NSLog(@&ldquo;After modified, global: %d, block local: %d, static local: %d\n&rdquo;, global, blockLocal, staticLocal);&lt;br/></span></code></pre></td></tr></table></div></figure></notextile></div></p>

<p>相似的情况，我们也可以引用 static block 或 __block block。比如我们可以用他们来实现 block 递归：</p>

<p><div class='bogus-wrapper'><notextile><figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
<span class='line-number'>11</span>
<span class='line-number'>12</span>
<span class='line-number'>13</span>
<span class='line-number'>14</span>
<span class='line-number'>15</span>
<span class='line-number'>16</span>
<span class='line-number'>17</span>
<span class='line-number'>18</span>
<span class='line-number'>19</span>
<span class='line-number'>20</span>
<span class='line-number'>21</span>
<span class='line-number'>22</span>
<span class='line-number'>23</span>
<span class='line-number'>24</span>
<span class='line-number'>25</span>
<span class='line-number'>26</span>
<span class='line-number'>27</span>
<span class='line-number'>28</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>// 1&lt;br/>
</span><span class='line'>void (^aBlock)(int) = 0;&lt;br/>
</span><span class='line'>static void (^ const staticBlock)(int) = ^(int i) {&lt;/p>
</span><span class='line'>
</span><span class='line'>&lt;pre>&lt;code>if (i &gt; 0) {  
</span><span class='line'>    NSLog(@" &gt;&gt; static %d", i);  
</span><span class='line'>    staticBlock(i - 1);  
</span><span class='line'>}  
</span><span class='line'>&lt;/code>&lt;/pre>
</span><span class='line'>
</span><span class='line'>&lt;p>};&lt;/p>
</span><span class='line'>
</span><span class='line'>&lt;p>aBlock = staticBlock;&lt;br/>
</span><span class='line'>aBlock(5);&lt;/p>
</span><span class='line'>
</span><span class='line'>&lt;p>// 2&lt;br/>
</span><span class='line'>__block void (^blockBlock)(int);&lt;br/>
</span><span class='line'>blockBlock = ^(int i) {&lt;/p>
</span><span class='line'>
</span><span class='line'>&lt;pre>&lt;code>if (i &gt; 0) {  
</span><span class='line'>    NSLog(@" &gt;&gt; block %d", i);  
</span><span class='line'>    blockBlock(i - 1);  
</span><span class='line'>}  
</span><span class='line'>&lt;/code>&lt;/pre>
</span><span class='line'>
</span><span class='line'>&lt;p>};&lt;/p>
</span><span class='line'>
</span><span class='line'>&lt;p>blockBlock(5);&lt;br/></span></code></pre></td></tr></table></div></figure></notextile></div></p>

<h3>4，上面我们介绍了 block 及其基本用法，但还没有涉及并行编程。 block 与 Dispatch Queue 分发队列结合起来使用，是 iOS 中并行编程的利器。请看代码：</h3>

<p><div class='bogus-wrapper'><notextile><figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
<span class='line-number'>11</span>
<span class='line-number'>12</span>
<span class='line-number'>13</span>
<span class='line-number'>14</span>
<span class='line-number'>15</span>
<span class='line-number'>16</span>
<span class='line-number'>17</span>
<span class='line-number'>18</span>
<span class='line-number'>19</span>
<span class='line-number'>20</span>
<span class='line-number'>21</span>
<span class='line-number'>22</span>
<span class='line-number'>23</span>
<span class='line-number'>24</span>
<span class='line-number'>25</span>
<span class='line-number'>26</span>
<span class='line-number'>27</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>NSAutoreleasePool * pool = [[NSAutoreleasePool alloc] init];&lt;/p>
</span><span class='line'>
</span><span class='line'>&lt;p>initData();&lt;/p>
</span><span class='line'>
</span><span class='line'>&lt;p>// create dispatch queue&lt;br/>
</span><span class='line'>//&lt;br/>
</span><span class='line'>dispatch_queue_t queue = dispatch_queue_create(&ldquo;StudyBlocks&rdquo;, NULL);&lt;/p>
</span><span class='line'>
</span><span class='line'>&lt;p>dispatch_async(queue, ^(void) {&lt;/p>
</span><span class='line'>
</span><span class='line'>&lt;pre>&lt;code>int sum = 0;  
</span><span class='line'>for(int i = 0; i &lt; Length; i++)  
</span><span class='line'>    sum += data[i];  
</span><span class='line'>
</span><span class='line'>NSLog(@" &gt;&gt; Sum: %d", sum);  
</span><span class='line'>
</span><span class='line'>flag = YES;  
</span><span class='line'>&lt;/code>&lt;/pre>
</span><span class='line'>
</span><span class='line'>&lt;p>});&lt;/p>
</span><span class='line'>
</span><span class='line'>&lt;p>// wait util work is done.&lt;br/>
</span><span class='line'>//&lt;br/>
</span><span class='line'>while (!flag);&lt;br/>
</span><span class='line'>dispatch_release(queue);&lt;/p>
</span><span class='line'>
</span><span class='line'>&lt;p>[pool drain];&lt;br/></span></code></pre></td></tr></table></div></figure></notextile></div></p>

<p>上面的 block 仅仅是将数组求和。</p>

<p>首先，我们创建一个串行分发队列，然后将一个 block 任务加入到其中并行运行，这样 block 就会在新的线程中运行，直到结束返回主线程。在这里要注意 flag 的使用。flag 是 static 的，所以我们可以 block 中修改它。 语句 while (!flag); 的目的是保证主线程不会 blcok 所在线程之前结束。</p>

<p>dispatch_queue_t 的定义如下：
typedef void (^dispatch_block_t)( void);
这意味着加入 dispatch_queue 中的 block 必须是无参数也无返回值的。</p>

<p>dispatch_queue_create 的定义如下：</p>

<p><code>
dispatch_queue_t dispatch_queue_create(const char *label, dispatch_queue_attr_t attr);
</code></p>

<p>这个函数带有两个参数：一个用于标识 dispatch_queue 的字符串；一个是保留的 dispatch_queue 属性，将其设置为 NULL 即可。</p>

<p>我们也可以使用</p>

<p><code>
dispatch_queue_t dispatch_get_global_queue(long priority, unsigned long flags);
</code></p>

<p>来获得全局的 dispatch_queue，参数 priority 表示优先级，值得注意的是：我们不能修改该函数返回的 dispatch_queue。</p>

<p>dispatch_async 函数的定义如下：</p>

<p><code>
void dispatch_async(dispatch_queue_t queue, dispatch_block_t block);
</code></p>

<p>它是将一个 block 加入一个 dispatch_queue，这个 block 会再其后得到调度时，并行运行。
相应的 dispatch_sync 函数就是同步执行了，一般很少用到。比如上面的代码如果我们修改为 dispatch_sync，那么就无需编写 flag 同步代码了。</p>

<h3>5，dispatch_queue 的运作机制及线程间同步</h3>

<p>我们可以将许多 blocks 用 dispatch_async 函数提交到到 dispatch_queue 串行运行。这些 blocks 是按照 FIFO(先入先出)规则调度的，也就是说，先加入的先执行，后加入的一定后执行，但在某一个时刻，可能有多个 block 同时在执行。</p>

<p>在上面的例子中，我们的主线程一直在轮询 flag 以便知晓 block 线程是否执行完毕，这样做的效率是很低的，严重浪费 CPU 资源。我们可以使用一些通信机制来解决这个问题，如：semaphore（信号量）。 semaphore 的原理很简单，就是生产-消费模式，必须生产一些资源才能消费，没有资源的时候，那我就啥也不干，直到资源就绪。下面来看代码：</p>

<p><div class='bogus-wrapper'><notextile><figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
<span class='line-number'>11</span>
<span class='line-number'>12</span>
<span class='line-number'>13</span>
<span class='line-number'>14</span>
<span class='line-number'>15</span>
<span class='line-number'>16</span>
<span class='line-number'>17</span>
<span class='line-number'>18</span>
<span class='line-number'>19</span>
<span class='line-number'>20</span>
<span class='line-number'>21</span>
<span class='line-number'>22</span>
<span class='line-number'>23</span>
<span class='line-number'>24</span>
<span class='line-number'>25</span>
<span class='line-number'>26</span>
<span class='line-number'>27</span>
<span class='line-number'>28</span>
<span class='line-number'>29</span>
<span class='line-number'>30</span>
<span class='line-number'>31</span>
<span class='line-number'>32</span>
<span class='line-number'>33</span>
<span class='line-number'>34</span>
<span class='line-number'>35</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>NSAutoreleasePool * pool = [[NSAutoreleasePool alloc] init];&lt;/p>
</span><span class='line'>
</span><span class='line'>&lt;p>initData();&lt;/p>
</span><span class='line'>
</span><span class='line'>&lt;p>// Create a semaphore with 0 resource&lt;br/>
</span><span class='line'>//&lt;br/>
</span><span class='line'>__block dispatch_semaphore_t sem = dispatch_semaphore_create(0);&lt;/p>
</span><span class='line'>
</span><span class='line'>&lt;p>// create dispatch semaphore&lt;br/>
</span><span class='line'>//&lt;br/>
</span><span class='line'>dispatch_queue_t queue = dispatch_queue_create(&ldquo;StudyBlocks&rdquo;, NULL);&lt;/p>
</span><span class='line'>
</span><span class='line'>&lt;p>dispatch_async(queue, ^(void) {&lt;/p>
</span><span class='line'>
</span><span class='line'>&lt;pre>&lt;code>int sum = 0;  
</span><span class='line'>for(int i = 0; i &lt; Length; i++)  
</span><span class='line'>    sum += data[i];  
</span><span class='line'>
</span><span class='line'>NSLog(@" &gt;&gt; Sum: %d", sum);  
</span><span class='line'>
</span><span class='line'>// signal the semaphore: add 1 resource  
</span><span class='line'>//  
</span><span class='line'>dispatch_semaphore_signal(sem);  
</span><span class='line'>&lt;/code>&lt;/pre>
</span><span class='line'>
</span><span class='line'>&lt;p>});&lt;/p>
</span><span class='line'>
</span><span class='line'>&lt;p>// wait for the semaphore: wait until resource is ready.&lt;br/>
</span><span class='line'>//&lt;br/>
</span><span class='line'>dispatch_semaphore_wait(sem, DISPATCH_TIME_FOREVER);&lt;/p>
</span><span class='line'>
</span><span class='line'>&lt;p>dispatch_release(sem);&lt;br/>
</span><span class='line'>dispatch_release(queue);&lt;/p>
</span><span class='line'>
</span><span class='line'>&lt;p>[pool drain];&lt;br/></span></code></pre></td></tr></table></div></figure></notextile></div></p>

<p>首先我们创建一个 <code>__block semaphore</code>，并将其资源初始值设置为 0 (不能少于 0)，在这里表示任务还没有完成，没有资源可用主线程不要做事情。然后在 block 任务完成之后，使用 dispatch_semaphore_signal 增加 semaphore 计数（可理解为资源数），表明任务完成，有资源可用主线程可以做事情了。而主线程中的 dispatch_semaphore_wait 就是减少 semaphore 的计数，如果资源数少于 0，则表明资源还可不得，我得按照FIFO（先等先得）的规则等待资源就绪，一旦资源就绪并且得到调度了，我再执行。</p>

<h3>6 示例：</h3>

<p>下面我们来看一个按照 FIFO 顺序执行并用 semaphore 同步的例子：先将数组求和再依次减去数组。</p>

<p><div class='bogus-wrapper'><notextile><figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
<span class='line-number'>11</span>
<span class='line-number'>12</span>
<span class='line-number'>13</span>
<span class='line-number'>14</span>
<span class='line-number'>15</span>
<span class='line-number'>16</span>
<span class='line-number'>17</span>
<span class='line-number'>18</span>
<span class='line-number'>19</span>
<span class='line-number'>20</span>
<span class='line-number'>21</span>
<span class='line-number'>22</span>
<span class='line-number'>23</span>
<span class='line-number'>24</span>
<span class='line-number'>25</span>
<span class='line-number'>26</span>
<span class='line-number'>27</span>
<span class='line-number'>28</span>
<span class='line-number'>29</span>
<span class='line-number'>30</span>
<span class='line-number'>31</span>
<span class='line-number'>32</span>
<span class='line-number'>33</span>
<span class='line-number'>34</span>
<span class='line-number'>35</span>
<span class='line-number'>36</span>
<span class='line-number'>37</span>
<span class='line-number'>38</span>
<span class='line-number'>39</span>
<span class='line-number'>40</span>
<span class='line-number'>41</span>
<span class='line-number'>42</span>
<span class='line-number'>43</span>
<span class='line-number'>44</span>
<span class='line-number'>45</span>
<span class='line-number'>46</span>
<span class='line-number'>47</span>
<span class='line-number'>48</span>
<span class='line-number'>49</span>
<span class='line-number'>50</span>
<span class='line-number'>51</span>
<span class='line-number'>52</span>
<span class='line-number'>53</span>
<span class='line-number'>54</span>
<span class='line-number'>55</span>
<span class='line-number'>56</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>NSAutoreleasePool * pool = [[NSAutoreleasePool alloc] init];&lt;/p>
</span><span class='line'>
</span><span class='line'>&lt;p>initData();&lt;/p>
</span><span class='line'>
</span><span class='line'>&lt;p>__block int sum = 0;&lt;/p>
</span><span class='line'>
</span><span class='line'>&lt;p>// Create a semaphore with 0 resource&lt;br/>
</span><span class='line'>//&lt;br/>
</span><span class='line'>&lt;strong>block dispatch_semaphore_t sem = dispatch_semaphore_create(0);&lt;br/>
</span><span class='line'>&lt;/strong>block dispatch_semaphore_t taskSem = dispatch_semaphore_create(0);&lt;/p>
</span><span class='line'>
</span><span class='line'>&lt;p>// create dispatch semaphore&lt;br/>
</span><span class='line'>//&lt;br/>
</span><span class='line'>dispatch_queue_t queue = dispatch_queue_create(&ldquo;StudyBlocks&rdquo;, NULL);&lt;/p>
</span><span class='line'>
</span><span class='line'>&lt;p>dispatch_block_t task1 = ^(void) {&lt;/p>
</span><span class='line'>
</span><span class='line'>&lt;pre>&lt;code>int s = 0;  
</span><span class='line'>for (int i = 0; i &lt; Length; i++)  
</span><span class='line'>    s += data[i];  
</span><span class='line'>sum = s;  
</span><span class='line'>
</span><span class='line'>NSLog(@" &gt;&gt; after add: %d", sum);  
</span><span class='line'>
</span><span class='line'>dispatch_semaphore_signal(taskSem);  
</span><span class='line'>&lt;/code>&lt;/pre>
</span><span class='line'>
</span><span class='line'>&lt;p>};&lt;/p>
</span><span class='line'>
</span><span class='line'>&lt;p>dispatch_block_t task2 = ^(void) {&lt;/p>
</span><span class='line'>
</span><span class='line'>&lt;pre>&lt;code>dispatch_semaphore_wait(taskSem, DISPATCH_TIME_FOREVER);  
</span><span class='line'>
</span><span class='line'>int s = sum;  
</span><span class='line'>for (int i = 0; i &lt; Length; i++)  
</span><span class='line'>    s -= data[i];  
</span><span class='line'>sum = s;  
</span><span class='line'>
</span><span class='line'>NSLog(@" &gt;&gt; after subtract: %d", sum);  
</span><span class='line'>dispatch_semaphore_signal(sem);  
</span><span class='line'>&lt;/code>&lt;/pre>
</span><span class='line'>
</span><span class='line'>&lt;p>};&lt;/p>
</span><span class='line'>
</span><span class='line'>&lt;p>dispatch_async(queue, task1);&lt;br/>
</span><span class='line'>dispatch_async(queue, task2);&lt;/p>
</span><span class='line'>
</span><span class='line'>&lt;p>// wait for the semaphore: wait until resource is ready.&lt;br/>
</span><span class='line'>//&lt;br/>
</span><span class='line'>dispatch_semaphore_wait(sem, DISPATCH_TIME_FOREVER);&lt;/p>
</span><span class='line'>
</span><span class='line'>&lt;p>dispatch_release(taskSem);&lt;br/>
</span><span class='line'>dispatch_release(sem);&lt;br/>
</span><span class='line'>dispatch_release(queue);&lt;/p>
</span><span class='line'>
</span><span class='line'>&lt;p>[pool drain];&lt;br/></span></code></pre></td></tr></table></div></figure></notextile></div></p>

<p>在上面的代码中，我们利用了 dispatch_queue 的 FIFO 特性，确保 task1 先于 task2 执行，而 task2 必须等待直到 task1 执行完毕才开始干正事，主线程又必须等待 task2 才能干正事。 这样我们就可以保证先求和，再相减，然后再让主线程运行结束这个顺序。</p>

<h3>7，使用 dispatch_apply 进行并发迭代：</h3>

<p>对于上面的求和操作，我们也可以使用 dispatch_apply 来简化代码的编写：</p>

<p><div class='bogus-wrapper'><notextile><figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
<span class='line-number'>11</span>
<span class='line-number'>12</span>
<span class='line-number'>13</span>
<span class='line-number'>14</span>
<span class='line-number'>15</span>
<span class='line-number'>16</span>
<span class='line-number'>17</span>
<span class='line-number'>18</span>
<span class='line-number'>19</span>
<span class='line-number'>20</span>
<span class='line-number'>21</span>
<span class='line-number'>22</span>
<span class='line-number'>23</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>NSAutoreleasePool * pool = [[NSAutoreleasePool alloc] init];&lt;/p>
</span><span class='line'>
</span><span class='line'>&lt;p>initData();&lt;/p>
</span><span class='line'>
</span><span class='line'>&lt;p>dispatch_queue_t queue = dispatch_get_global_queue(DISPATCH_QUEUE_PRIORITY_DEFAULT, 0);&lt;/p>
</span><span class='line'>
</span><span class='line'>&lt;p>&lt;strong>block int sum = 0;&lt;br/>
</span><span class='line'>&lt;/strong>block int *pArray = data;&lt;/p>
</span><span class='line'>
</span><span class='line'>&lt;p>// iterations&lt;br/>
</span><span class='line'>//&lt;br/>
</span><span class='line'>dispatch_apply(Length, queue, ^(size_t i) {&lt;/p>
</span><span class='line'>
</span><span class='line'>&lt;pre>&lt;code>sum += pArray[i];  
</span><span class='line'>&lt;/code>&lt;/pre>
</span><span class='line'>
</span><span class='line'>&lt;p>});&lt;/p>
</span><span class='line'>
</span><span class='line'>&lt;p>NSLog(@&ldquo; >> sum: %d&rdquo;, sum);&lt;/p>
</span><span class='line'>
</span><span class='line'>&lt;p>dispatch_release(queue);&lt;/p>
</span><span class='line'>
</span><span class='line'>&lt;p>[pool drain];&lt;br/></span></code></pre></td></tr></table></div></figure></notextile></div></p>

<p>注意这里使用了全局 dispatch_queue。</p>

<p>dispatch_apply 的定义如下：</p>

<p><code>
dispatch_apply(size_t iterations, dispatch_queue_t queue, void (^block)(size_t));
</code></p>

<p>参数 iterations 表示迭代的次数，void (^block)(size_t) 是 block 循环体。这么做与 for 循环相比有什么好处呢？答案是：并行，这里的求和是并行的，并不是按照顺序依次执行求和的。</p>

<h3>8, dispatch group</h3>

<p>我们可以将完成一组相关任务的 block 添加到一个 dispatch group 中去，这样可以在 group 中所有 block 任务都完成之后，再做其他事情。比如 6 中的示例也可以使用 dispatch group 实现：</p>

<p><div class='bogus-wrapper'><notextile><figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
<span class='line-number'>11</span>
<span class='line-number'>12</span>
<span class='line-number'>13</span>
<span class='line-number'>14</span>
<span class='line-number'>15</span>
<span class='line-number'>16</span>
<span class='line-number'>17</span>
<span class='line-number'>18</span>
<span class='line-number'>19</span>
<span class='line-number'>20</span>
<span class='line-number'>21</span>
<span class='line-number'>22</span>
<span class='line-number'>23</span>
<span class='line-number'>24</span>
<span class='line-number'>25</span>
<span class='line-number'>26</span>
<span class='line-number'>27</span>
<span class='line-number'>28</span>
<span class='line-number'>29</span>
<span class='line-number'>30</span>
<span class='line-number'>31</span>
<span class='line-number'>32</span>
<span class='line-number'>33</span>
<span class='line-number'>34</span>
<span class='line-number'>35</span>
<span class='line-number'>36</span>
<span class='line-number'>37</span>
<span class='line-number'>38</span>
<span class='line-number'>39</span>
<span class='line-number'>40</span>
<span class='line-number'>41</span>
<span class='line-number'>42</span>
<span class='line-number'>43</span>
<span class='line-number'>44</span>
<span class='line-number'>45</span>
<span class='line-number'>46</span>
<span class='line-number'>47</span>
<span class='line-number'>48</span>
<span class='line-number'>49</span>
<span class='line-number'>50</span>
<span class='line-number'>51</span>
<span class='line-number'>52</span>
<span class='line-number'>53</span>
<span class='line-number'>54</span>
<span class='line-number'>55</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>NSAutoreleasePool * pool = [[NSAutoreleasePool alloc] init];&lt;/p>
</span><span class='line'>
</span><span class='line'>&lt;p>initData();&lt;/p>
</span><span class='line'>
</span><span class='line'>&lt;p>__block int sum = 0;&lt;/p>
</span><span class='line'>
</span><span class='line'>&lt;p>// Create a semaphore with 0 resource&lt;br/>
</span><span class='line'>//&lt;br/>
</span><span class='line'>__block dispatch_semaphore_t taskSem = dispatch_semaphore_create(0);&lt;/p>
</span><span class='line'>
</span><span class='line'>&lt;p>// create dispatch semaphore&lt;br/>
</span><span class='line'>//&lt;br/>
</span><span class='line'>dispatch_queue_t queue = dispatch_queue_create(&ldquo;StudyBlocks&rdquo;, NULL);&lt;br/>
</span><span class='line'>dispatch_group_t group = dispatch_group_create();&lt;/p>
</span><span class='line'>
</span><span class='line'>&lt;p>dispatch_block_t task1 = ^(void) {&lt;/p>
</span><span class='line'>
</span><span class='line'>&lt;pre>&lt;code>int s = 0;  
</span><span class='line'>for (int i = 0; i &lt; Length; i++)  
</span><span class='line'>    s += data[i];  
</span><span class='line'>sum = s;  
</span><span class='line'>
</span><span class='line'>NSLog(@" &gt;&gt; after add: %d", sum);  
</span><span class='line'>
</span><span class='line'>dispatch_semaphore_signal(taskSem);  
</span><span class='line'>&lt;/code>&lt;/pre>
</span><span class='line'>
</span><span class='line'>&lt;p>};&lt;/p>
</span><span class='line'>
</span><span class='line'>&lt;p>dispatch_block_t task2 = ^(void) {&lt;/p>
</span><span class='line'>
</span><span class='line'>&lt;pre>&lt;code>dispatch_semaphore_wait(taskSem, DISPATCH_TIME_FOREVER);  
</span><span class='line'>
</span><span class='line'>int s = sum;  
</span><span class='line'>for (int i = 0; i &lt; Length; i++)  
</span><span class='line'>    s -= data[i];  
</span><span class='line'>sum = s;  
</span><span class='line'>
</span><span class='line'>NSLog(@" &gt;&gt; after subtract: %d", sum);  
</span><span class='line'>&lt;/code>&lt;/pre>
</span><span class='line'>
</span><span class='line'>&lt;p>};&lt;/p>
</span><span class='line'>
</span><span class='line'>&lt;p>// Fork&lt;br/>
</span><span class='line'>dispatch_group_async(group, queue, task1);&lt;br/>
</span><span class='line'>dispatch_group_async(group, queue, task2);&lt;/p>
</span><span class='line'>
</span><span class='line'>&lt;p>// Join&lt;br/>
</span><span class='line'>dispatch_group_wait(group, DISPATCH_TIME_FOREVER);&lt;/p>
</span><span class='line'>
</span><span class='line'>&lt;p>dispatch_release(taskSem);&lt;br/>
</span><span class='line'>dispatch_release(queue);&lt;br/>
</span><span class='line'>dispatch_release(group);&lt;/p>
</span><span class='line'>
</span><span class='line'>&lt;p>[pool drain];&lt;br/></span></code></pre></td></tr></table></div></figure></notextile></div></p>

<p>在上面的代码中，我们使用 dispatch_group_create 创建一个 dispatch_group_t，然后使用语句：dispatch_group_async(group, queue, task1); 将 block 任务加入队列中，并与组关联，这样我们就可以使用 dispatch_group_wait(group, DISPATCH_TIME_FOREVER); 来等待组中所有的 block 任务完成再继续执行。</p>

<p>至此我们了解了 dispatch queue 以及 block 并行编程相关基本知识，开始在项目中运用它们吧，</p>

<p><em>参考资料：</em>
Concurrency Programming Guide：
<a href="http://developer.apple.com/library/ios/#documentation/General/Conceptual/ConcurrencyProgrammingGuide/Introduction/Introduction.html">http://developer.apple.com/library/ios/#documentation/General/Conceptual/ConcurrencyProgrammingGuide/Introduction/Introduction.html</a></p>
]]></content>
  </entry>
  
</feed>
