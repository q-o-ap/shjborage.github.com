<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">

  <title><![CDATA[Category: iOS | Saick Blog]]></title>
  <link href="http://saick.net/blog/categories/ios/atom.xml" rel="self"/>
  <link href="http://saick.net/"/>
  <updated>2013-06-08T16:19:13+08:00</updated>
  <id>http://saick.net/</id>
  <author>
    <name><![CDATA[Eric Shi]]></name>
    
  </author>
  <generator uri="http://octopress.org/">Octopress</generator>

  
  <entry>
    <title type="html"><![CDATA[Property 使用注意事项]]></title>
    <link href="http://saick.net/blog/2013/05/28/propertyshi-yong-zhu-yi-shi-xiang/"/>
    <updated>2013-05-28T11:04:00+08:00</updated>
    <id>http://saick.net/blog/2013/05/28/propertyshi-yong-zhu-yi-shi-xiang</id>
    <content type="html"><![CDATA[<ul>
<li>NSString property的属性必须是copy</li>
<li>delegate property的属性是assign</li>
<li>dealloc 时，如果有delegate，要把delegate置成nilj,避免收到消息等</li>
<li>init 和dealloc中不要用self.XX=;</li>
</ul>


<h4>NSCoping</h4>

<p>Any object that you wish to set for a copy property must support NSCopying, which means that it should conform to the NSCopying protocol.</p>

<p>If you need to set a copy property’s instance variable directly, for example in an initializer method, don’t forget to set a copy of the original object:</p>

<p>```
&ndash; (id)initWithSomeOriginalString:(NSString *)aString {</p>

<pre><code>self = [super init];
if (self) {
    _instanceVariableForCopyProperty = [aString copy];
}
return self;
</code></pre>

<p>}
```</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Category 巧用-调试程序]]></title>
    <link href="http://saick.net/blog/2013/05/28/category-qiao-yong-diao-shi-cheng-xu/"/>
    <updated>2013-05-28T10:52:00+08:00</updated>
    <id>http://saick.net/blog/2013/05/28/category-qiao-yong-diao-shi-cheng-xu</id>
    <content type="html"><![CDATA[<h3>Category可以用来调试</h3>

<p>除了隐藏私有方法外，我主要用它截住函数。</p>

<p>例1：测试时我想知道TableViewCell有没有释放，就可以这样写</p>

<p>```
@implementation UITableViewCell(dealloc)
&ndash;(void)dealloc
{
   NSLog(@&ldquo;%@&rdquo;,NSStringFromSelector(_cmd));</p>

<pre><code>NSArray *array = allSubviews(self);         // allSubviews是cookBook里的函数，可以取一个view的所有subView ,在这个文档后面也有
NSLog(@"%@",array); 
[super dealloc]; 
</code></pre>

<p>}
@end
```</p>

<p>其它的类也可以这样写，你随便输出什么</p>

<p>例2：我调试程序，觉得table的大小变了，想找到在哪改变的，这样做：</p>

<p>```
 @implementation UITableView(setframe)
&ndash;(void)setFrame:(CGRect)frame
{
   NSLog(%&ldquo;%@&rdquo;,self);</p>

<pre><code>[super setFrame: frame]; 
</code></pre>

<p>}
@end
```</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[iOS 开发常见低级错误]]></title>
    <link href="http://saick.net/blog/2013/05/28/ios-kai-fa-chang-jian-di-ji-cuo-wu/"/>
    <updated>2013-05-28T10:19:00+08:00</updated>
    <id>http://saick.net/blog/2013/05/28/ios-kai-fa-chang-jian-di-ji-cuo-wu</id>
    <content type="html"><![CDATA[<p><strong><em>不断更新中。。。</em></strong></p>

<p>May 28, 2013</p>

<ul>
<li><h3>不要调用[super  release]</h3>

<p>在dealloc里要调用[super dealloc]，千万不要调用[super release]</p></li>
</ul>

]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[iOS block 编程]]></title>
    <link href="http://saick.net/blog/2013/05/28/ios-block-bian-cheng/"/>
    <updated>2013-05-28T09:57:00+08:00</updated>
    <id>http://saick.net/blog/2013/05/28/ios-block-bian-cheng</id>
    <content type="html"><![CDATA[<h2>block</h2>

<p>Blocks are often used to simplify common tasks such as collection enumeration, sorting and testing. They also make it easy to schedule tasks for concurrent or asynchronous execution using technologies like Grand Central Dispatch (GCD).</p>

<h4>声明block：</h4>

<p><code>
void (^simpleBlock)(void);
</code></p>

<h4>定义block：</h4>

<p>```
simpleBlock = ^{</p>

<pre><code>    NSLog(@"This is a block");
</code></pre>

<p>};
```</p>

<h4>声明和定义在一起：</h4>

<p>```
void (^simpleBlock)(void) = ^{</p>

<pre><code>NSLog(@"This is a block");
</code></pre>

<p>};
```</p>

<h4>调用block：</h4>

<p><code>
simpleBlock();
</code></p>

<h4>带返回值和参数的block:</h4>

<p>```
double (^multiplyTwoValues)(double, double) =</p>

<pre><code>                          ^(double firstValue, double secondValue) {
                              return firstValue * secondValue;
                          };
double result = multiplyTwoValues(2,4);
NSLog(@"The result is %f", result);
</code></pre>

<p>```</p>

<p>If you need to be able to change the value of a captured variable from within a block, you can use the __block storage type modifier on the original variable declaration.</p>

<h4>如果block是递归调用的，必须设置成 __block。e.g.</h4>

<p>```
__block int (^recursiveBlock)(int) = ^(int param) {</p>

<pre><code>    if (param == 1) {
        return 1;
    }
    return (param--) * recursiveBlock(param);
</code></pre>

<p>};<br/>
recursiveBlock(5);  // 计算5的阶乘
```</p>

<p>You Can Pass Blocks as Arguments to Methods or Functions
&ndash; (void)beginTaskWithCallbackBlock:(void (^)(void))callbackBlock;
The (void (^)(void)) specifies that the parameter is a block that doesn’t take any arguments or return any values. The implementation of the method can invoke the block in the usual way:</p>

<p>```
&ndash; (void)beginTaskWithCallbackBlock:(void (^)(void))callbackBlock {</p>

<pre><code>...
callbackBlock();
</code></pre>

<p>}
```</p>

<p>A Block Should Always Be the Last Argument to a Method
Objects Use Properties to Keep Track of Blocks
The syntax to define a property to keep track of a block is similar to a block variable:</p>

<p><code>
@interface XYZObject : NSObject
@property (copy) void (^blockProperty)(void);
@end
</code></p>

<p>Note: You should specify copy as the property attribute, because a block needs to be copied to keep track of its captured state outside of the original scope.
A block property is set or invoked like any other block variable:</p>

<p>```</p>

<pre><code>self.blockProperty = ^{
    ...
};
self.blockProperty();
</code></pre>

<p>typedef void(^BlockCC)(void);
```</p>

<p>// e.g.更新myTableview并显示最后一行</p>

<p>```
if (dataArray.count > 0) {</p>

<pre><code>    [myTableView reloadData];   
    // reloadData后不能直接调用scrollToRowAtIndexPath，有可能lastIndex在table中不存在，
 // 所以要[NSObject performBlock: afterDelay:0];
    [myTableView retain];   // 防止关闭视图，myTableView释放之后scrollToBottom出错
    NSIndexPath *lastIndex = [NSIndexPath indexPathForRow:dataArray.count-1 inSection:0];
    void (^scrollToBottom)(void) = ^{
        [myTableView scrollToRowAtIndexPath:lastIndex atScrollPosition:UITableViewScrollPositionBottom animated:YES];
        [myTableView release];
    };
    //
    [NSObject performBlock:scrollToBottom afterDelay:0];
</code></pre>

<p>}
```</p>
]]></content>
  </entry>
  
</feed>
